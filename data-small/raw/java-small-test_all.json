[
  {
    "dir": "jenkinspipeline",
    "files": [],
    "subdirs": [
      {
        "dir": "webapp",
        "files": [],
        "subdirs": [
          {
            "dir": "src",
            "files": [],
            "subdirs": [
              {
                "dir": "site",
                "files": [],
                "subdirs": [
                  {
                    "dir": "apt",
                    "files": [],
                    "subdirs": []
                  }
                ]
              },
              {
                "dir": "main",
                "files": [],
                "subdirs": [
                  {
                    "dir": "webapp",
                    "files": [],
                    "subdirs": [
                      {
                        "dir": "WEB-INF",
                        "files": [],
                        "subdirs": []
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "dir": "server",
        "files": [],
        "subdirs": [
          {
            "dir": "src",
            "files": [],
            "subdirs": [
              {
                "dir": "site",
                "files": [],
                "subdirs": [
                  {
                    "dir": "apt",
                    "files": [],
                    "subdirs": []
                  }
                ]
              },
              {
                "dir": "test",
                "files": [],
                "subdirs": [
                  {
                    "dir": "java",
                    "files": [],
                    "subdirs": [
                      {
                        "dir": "com",
                        "files": [],
                        "subdirs": [
                          {
                            "dir": "example",
                            "files": [
                              {
                                "name": "TestGreeter.java",
                                "content": "package com.example;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.Matchers.greaterThan;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.matchers.JUnitMatchers.containsString;\n\npublic class TestGreeter {\n\n  private Greeter greeter;\n\n  @Before\n  public void setup() {\n    greeter = new Greeter();\n  }\n\n  @Test\n  public void greetShouldIncludeTheOneBeingGreeted() {\n    String someone = \"World\";\n\n    assertThat(greeter.greet(someone), containsString(someone));\n  }\n\n  @Test\n  public void greetShouldIncludeGreetingPhrase() {\n    String someone = \"World\";\n\n    assertThat(greeter.greet(someone).length(), is(greaterThan(someone.length())));\n  }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.example;",
                                    "import org.junit.Before;",
                                    "import org.junit.Test;",
                                    "import static org.hamcrest.CoreMatchers.is;",
                                    "import static org.hamcrest.Matchers.greaterThan;",
                                    "import static org.junit.Assert.assertThat;",
                                    "import static org.junit.matchers.JUnitMatchers.containsString;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class TestGreeter {\n\n  private Greeter greeter;\n\n  @Before\n  public void setup() {\n    greeter = new Greeter();\n  }\n\n  @Test\n  public void greetShouldIncludeTheOneBeingGreeted() {\n    String someone = \"World\";\n\n    assertThat(greeter.greet(someone), containsString(someone));\n  }\n\n  @Test\n  public void greetShouldIncludeGreetingPhrase() {\n    String someone = \"World\";\n\n    assertThat(greeter.greet(someone).length(), is(greaterThan(someone.length())));\n  }\n}",
                                      "definition": "public class TestGreeter",
                                      "byte_span": [
                                        271,
                                        738
                                      ],
                                      "start_point": [
                                        10,
                                        0
                                      ],
                                      "end_point": [
                                        32,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "TestGreeter",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "  private Greeter greeter;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Greeter",
                                            "name": "greeter",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            329,
                                            393
                                          ],
                                          "original_string": "  @Before\n  public void setup() {\n    greeter = new Greeter();\n  }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Before\n  public",
                                            "marker_annotations": [
                                              "@Before"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setup",
                                          "body": "                      {\n    greeter = new Greeter();\n  }",
                                          "identifiers": "greeter",
                                          "signature": "  @Before\n  public void setup()",
                                          "signature_woname": "  @Before\n  public void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            397,
                                            557
                                          ],
                                          "original_string": "  @Test\n  public void greetShouldIncludeTheOneBeingGreeted() {\n    String someone = \"World\";\n\n    assertThat(greeter.greet(someone), containsString(someone));\n  }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Test\n  public",
                                            "marker_annotations": [
                                              "@Test"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "greetShouldIncludeTheOneBeingGreeted",
                                          "body": "                                                     {\n    String someone = \"World\";\n\n    assertThat(greeter.greet(someone), containsString(someone));\n  }",
                                          "identifiers": "someone assertThat greeter greet someone containsString someone",
                                          "signature": "  @Test\n  public void greetShouldIncludeTheOneBeingGreeted()",
                                          "signature_woname": "  @Test\n  public void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            561,
                                            736
                                          ],
                                          "original_string": "  @Test\n  public void greetShouldIncludeGreetingPhrase() {\n    String someone = \"World\";\n\n    assertThat(greeter.greet(someone).length(), is(greaterThan(someone.length())));\n  }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Test\n  public",
                                            "marker_annotations": [
                                              "@Test"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "greetShouldIncludeGreetingPhrase",
                                          "body": "                                                 {\n    String someone = \"World\";\n\n    assertThat(greeter.greet(someone).length(), is(greaterThan(someone.length())));\n  }",
                                          "identifiers": "someone assertThat greeter greet someone length is greaterThan someone length",
                                          "signature": "  @Test\n  public void greetShouldIncludeGreetingPhrase()",
                                          "signature_woname": "  @Test\n  public void ()"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": []
                              }
                            ],
                            "subdirs": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "dir": "main",
                "files": [],
                "subdirs": [
                  {
                    "dir": "java",
                    "files": [],
                    "subdirs": [
                      {
                        "dir": "com",
                        "files": [],
                        "subdirs": [
                          {
                            "dir": "example",
                            "files": [
                              {
                                "name": "Greeter.java",
                                "content": "package com.example;\n\n/**\n * This is a class.\n */\npublic class Greeter {\n\n  /**\n   * This is a constructor.\n   */\n  public Greeter() {\n\n  }\n\n  //TODO: Add javadoc comment\n  public String greet(String someone) {\n    return String.format(\"Hello, %s!\", someone);\n  }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.example;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class Greeter {\n\n  /**\n   * This is a constructor.\n   */\n  public Greeter() {\n\n  }\n\n  //TODO: Add javadoc comment\n  public String greet(String someone) {\n    return String.format(\"Hello, %s!\", someone);\n  }\n}",
                                      "definition": "public class Greeter",
                                      "byte_span": [
                                        50,
                                        265
                                      ],
                                      "start_point": [
                                        5,
                                        0
                                      ],
                                      "end_point": [
                                        18,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "Greeter",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            116,
                                            139
                                          ],
                                          "original_string": "  public Greeter() {\n\n  }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "Greeter",
                                          "body": "                   {\n\n  }",
                                          "identifiers": "",
                                          "signature": "  public Greeter()",
                                          "signature_woname": "  public ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            173,
                                            263
                                          ],
                                          "original_string": "  public String greet(String someone) {\n    return String.format(\"Hello, %s!\", someone);\n  }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "greet",
                                          "body": "                                      {\n    return String.format(\"Hello, %s!\", someone);\n  }",
                                          "identifiers": "String format someone",
                                          "signature": "  public String greet(String someone)",
                                          "signature_woname": "  public String (String someone)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": []
                              }
                            ],
                            "subdirs": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "dir": "shadowsocks-java",
    "files": [],
    "subdirs": [
      {
        "dir": "src",
        "files": [],
        "subdirs": [
          {
            "dir": "main",
            "files": [],
            "subdirs": [
              {
                "dir": "java",
                "files": [],
                "subdirs": [
                  {
                    "dir": "com",
                    "files": [],
                    "subdirs": [
                      {
                        "dir": "stfl",
                        "files": [
                          {
                            "name": "Constant.java",
                            "content": "package com.stfl;\n\nimport java.util.Locale;\n\npublic class Constant {\n    public static final String PROG_NAME = \"shadowsocks-java\";\n    public static final String VERSION = \"0.2\";\n    public static final int BUFFER_SIZE = 16384;\n    public static final String CONF_FILE = \"config.json\";\n    public static final Locale LOCALE = Locale.getDefault();\n}\n",
                            "schema": {
                              "file_docstring": "",
                              "contexts": [
                                "package com.stfl;",
                                "import java.util.Locale;"
                              ],
                              "methods": [],
                              "classes": [
                                {
                                  "original_string": "public class Constant {\n    public static final String PROG_NAME = \"shadowsocks-java\";\n    public static final String VERSION = \"0.2\";\n    public static final int BUFFER_SIZE = 16384;\n    public static final String CONF_FILE = \"config.json\";\n    public static final Locale LOCALE = Locale.getDefault();\n}",
                                  "definition": "public class Constant",
                                  "byte_span": [
                                    45,
                                    349
                                  ],
                                  "start_point": [
                                    4,
                                    0
                                  ],
                                  "end_point": [
                                    10,
                                    1
                                  ],
                                  "class_docstring": "",
                                  "name": "Constant",
                                  "attributes": {
                                    "modifiers": "public",
                                    "marker_annotations": [],
                                    "non_marker_annotations": [
                                      "public"
                                    ],
                                    "comments": [],
                                    "fields": [
                                      {
                                        "attribute_expression": "    public static final String PROG_NAME = \"shadowsocks-java\";",
                                        "docstring": "",
                                        "modifiers": "public static final",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public",
                                          "static",
                                          "final"
                                        ],
                                        "comments": [],
                                        "type": "String",
                                        "name": "PROG_NAME = \"shadowsocks-java\"",
                                        "syntax_pass": true
                                      },
                                      {
                                        "attribute_expression": "    public static final String VERSION = \"0.2\";",
                                        "docstring": "",
                                        "modifiers": "public static final",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public",
                                          "static",
                                          "final"
                                        ],
                                        "comments": [],
                                        "type": "String",
                                        "name": "VERSION = \"0.2\"",
                                        "syntax_pass": true
                                      },
                                      {
                                        "attribute_expression": "    public static final int BUFFER_SIZE = 16384;",
                                        "docstring": "",
                                        "modifiers": "public static final",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public",
                                          "static",
                                          "final"
                                        ],
                                        "comments": [],
                                        "type": "int",
                                        "name": "BUFFER_SIZE = 16384",
                                        "syntax_pass": true
                                      },
                                      {
                                        "attribute_expression": "    public static final String CONF_FILE = \"config.json\";",
                                        "docstring": "",
                                        "modifiers": "public static final",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public",
                                          "static",
                                          "final"
                                        ],
                                        "comments": [],
                                        "type": "String",
                                        "name": "CONF_FILE = \"config.json\"",
                                        "syntax_pass": true
                                      },
                                      {
                                        "attribute_expression": "    public static final Locale LOCALE = Locale.getDefault();",
                                        "docstring": "",
                                        "modifiers": "public static final",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public",
                                          "static",
                                          "final"
                                        ],
                                        "comments": [],
                                        "type": "Locale",
                                        "name": "LOCALE = Locale.getDefault()",
                                        "syntax_pass": true
                                      }
                                    ],
                                    "classes": []
                                  },
                                  "syntax_pass": true,
                                  "methods": []
                                }
                              ]
                            },
                            "imports": []
                          },
                          {
                            "name": "Main.java",
                            "content": "package com.stfl;\n\nimport com.stfl.misc.Config;\nimport com.stfl.misc.Util;\nimport com.stfl.network.LocalServer;\nimport com.stfl.network.NioLocalServer;\nimport com.stfl.network.proxy.IProxy;\nimport com.stfl.network.proxy.ProxyFactory;\nimport com.stfl.ss.CryptFactory;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.logging.Logger;\n\npublic class Main {\n    private static Logger logger = Logger.getLogger(Main.class.getName());\n\n    public static void main(String[] args) {\n        if (args.length != 0) {\n            startCommandLine(args);\n        }\n        else {\n            MainGui.launch(MainGui.class);\n        }\n    }\n\n    private static void startCommandLine(String[] args) {\n        Config config;\n\n        config = parseArgument(args);\n        if (config == null) {\n            printUsage();\n            return;\n        }\n\n        Util.saveFile(Constant.CONF_FILE, config.saveToJson());\n\n        try {\n            //LocalServer server = new LocalServer(config);\n            NioLocalServer server = new NioLocalServer(config);\n            Thread t = new Thread(server);\n            t.start();\n            t.join();\n        } catch (Exception e) {\n            logger.warning(\"Unable to start server: \" + e.toString());\n        }\n    }\n\n    private static Config parseArgument(String[] args) {\n        Config config = new Config();\n\n        if (args.length == 2) {\n            if (args[0].equals(\"--config\")) {\n                Path path = Paths.get(args[1]);\n                try {\n                    String json = new String(Files.readAllBytes(path));\n                    config.loadFromJson(json);\n                } catch (IOException e) {\n                    System.out.println(\"Unable to read configuration file: \" + args[1]);\n                    return null;\n                }\n                return config;\n            }\n            else {\n                return null;\n            }\n        }\n\n        if (args.length != 8) {\n            return null;\n        }\n\n        // parse arguments\n        for (int i = 0; i < args.length; i+=2) {\n            String[] tempArgs;\n            if (args[i].equals(\"--local\")) {\n                tempArgs = args[i+1].split(\":\");\n                if (tempArgs.length < 2) {\n                    System.out.println(\"Invalid argument: \" + args[i]);\n                    return null;\n                }\n                config.setLocalIpAddress(tempArgs[0]);\n                config.setLocalPort(Integer.parseInt(tempArgs[1]));\n            }\n            else if (args[i].equals(\"--remote\")) {\n                tempArgs = args[i+1].split(\":\");\n                if (tempArgs.length < 2) {\n                    System.out.println(\"Invalid argument: \" + args[i]);\n                    return null;\n                }\n                config.setRemoteIpAddress(tempArgs[0]);\n                config.setRemotePort(Integer.parseInt(tempArgs[1]));\n            }\n            else if (args[i].equals(\"--cipher\")) {\n                config.setMethod(args[i+1]);\n            }\n            else if (args[i].equals(\"--password\")) {\n                config.setPassword(args[i + 1]);\n            }\n            else if (args[i].equals(\"--proxy\")) {\n                config.setProxyType(args[i + 1]);\n            }\n        }\n\n        return config;\n    }\n\n    private static void printUsage() {\n        System.out.println(\"Usage: ss --[option] value --[option] value...\");\n        System.out.println(\"Option:\");\n        System.out.println(\"  --local [IP:PORT]\");\n        System.out.println(\"  --remote [IP:PORT]\");\n        System.out.println(\"  --cipher [CIPHER_NAME]\");\n        System.out.println(\"  --password [PASSWORD]\");\n        System.out.println(\"  --config [CONFIG_FILE]\");\n        System.out.println(\"  --proxy [TYPE]\");\n        System.out.println(\"Support Proxy Type:\");\n        for (IProxy.TYPE t : ProxyFactory.getSupportedProxyTypes()) {\n            System.out.printf(\"  %s\\n\", t.toString().toLowerCase());\n        }\n        System.out.println(\"Support Ciphers:\");\n        for (String s : CryptFactory.getSupportedCiphers()) {\n            System.out.printf(\"  %s\\n\", s);\n        }\n        System.out.println(\"Example:\");\n        System.out.println(\"  ss --local \\\"127.0.0.1:1080\\\" --remote \\\"[SS_SERVER_IP]:1080\\\" --cipher \\\"aes-256-cfb\\\" --password \\\"HelloWorld\\\"\");\n        System.out.println(\"  ss --config config.json\");\n    }\n}\n",
                            "schema": {
                              "file_docstring": "",
                              "contexts": [
                                "package com.stfl;",
                                "import com.stfl.misc.Config;",
                                "import com.stfl.misc.Util;",
                                "import com.stfl.network.LocalServer;",
                                "import com.stfl.network.NioLocalServer;",
                                "import com.stfl.network.proxy.IProxy;",
                                "import com.stfl.network.proxy.ProxyFactory;",
                                "import com.stfl.ss.CryptFactory;",
                                "import java.io.IOException;",
                                "import java.nio.file.Files;",
                                "import java.nio.file.Path;",
                                "import java.nio.file.Paths;",
                                "import java.util.logging.Logger;"
                              ],
                              "methods": [],
                              "classes": [
                                {
                                  "original_string": "public class Main {\n    private static Logger logger = Logger.getLogger(Main.class.getName());\n\n    public static void main(String[] args) {\n        if (args.length != 0) {\n            startCommandLine(args);\n        }\n        else {\n            MainGui.launch(MainGui.class);\n        }\n    }\n\n    private static void startCommandLine(String[] args) {\n        Config config;\n\n        config = parseArgument(args);\n        if (config == null) {\n            printUsage();\n            return;\n        }\n\n        Util.saveFile(Constant.CONF_FILE, config.saveToJson());\n\n        try {\n            //LocalServer server = new LocalServer(config);\n            NioLocalServer server = new NioLocalServer(config);\n            Thread t = new Thread(server);\n            t.start();\n            t.join();\n        } catch (Exception e) {\n            logger.warning(\"Unable to start server: \" + e.toString());\n        }\n    }\n\n    private static Config parseArgument(String[] args) {\n        Config config = new Config();\n\n        if (args.length == 2) {\n            if (args[0].equals(\"--config\")) {\n                Path path = Paths.get(args[1]);\n                try {\n                    String json = new String(Files.readAllBytes(path));\n                    config.loadFromJson(json);\n                } catch (IOException e) {\n                    System.out.println(\"Unable to read configuration file: \" + args[1]);\n                    return null;\n                }\n                return config;\n            }\n            else {\n                return null;\n            }\n        }\n\n        if (args.length != 8) {\n            return null;\n        }\n\n        // parse arguments\n        for (int i = 0; i < args.length; i+=2) {\n            String[] tempArgs;\n            if (args[i].equals(\"--local\")) {\n                tempArgs = args[i+1].split(\":\");\n                if (tempArgs.length < 2) {\n                    System.out.println(\"Invalid argument: \" + args[i]);\n                    return null;\n                }\n                config.setLocalIpAddress(tempArgs[0]);\n                config.setLocalPort(Integer.parseInt(tempArgs[1]));\n            }\n            else if (args[i].equals(\"--remote\")) {\n                tempArgs = args[i+1].split(\":\");\n                if (tempArgs.length < 2) {\n                    System.out.println(\"Invalid argument: \" + args[i]);\n                    return null;\n                }\n                config.setRemoteIpAddress(tempArgs[0]);\n                config.setRemotePort(Integer.parseInt(tempArgs[1]));\n            }\n            else if (args[i].equals(\"--cipher\")) {\n                config.setMethod(args[i+1]);\n            }\n            else if (args[i].equals(\"--password\")) {\n                config.setPassword(args[i + 1]);\n            }\n            else if (args[i].equals(\"--proxy\")) {\n                config.setProxyType(args[i + 1]);\n            }\n        }\n\n        return config;\n    }\n\n    private static void printUsage() {\n        System.out.println(\"Usage: ss --[option] value --[option] value...\");\n        System.out.println(\"Option:\");\n        System.out.println(\"  --local [IP:PORT]\");\n        System.out.println(\"  --remote [IP:PORT]\");\n        System.out.println(\"  --cipher [CIPHER_NAME]\");\n        System.out.println(\"  --password [PASSWORD]\");\n        System.out.println(\"  --config [CONFIG_FILE]\");\n        System.out.println(\"  --proxy [TYPE]\");\n        System.out.println(\"Support Proxy Type:\");\n        for (IProxy.TYPE t : ProxyFactory.getSupportedProxyTypes()) {\n            System.out.printf(\"  %s\\n\", t.toString().toLowerCase());\n        }\n        System.out.println(\"Support Ciphers:\");\n        for (String s : CryptFactory.getSupportedCiphers()) {\n            System.out.printf(\"  %s\\n\", s);\n        }\n        System.out.println(\"Example:\");\n        System.out.println(\"  ss --local \\\"127.0.0.1:1080\\\" --remote \\\"[SS_SERVER_IP]:1080\\\" --cipher \\\"aes-256-cfb\\\" --password \\\"HelloWorld\\\"\");\n        System.out.println(\"  ss --config config.json\");\n    }\n}",
                                  "definition": "public class Main",
                                  "byte_span": [
                                    412,
                                    4434
                                  ],
                                  "start_point": [
                                    15,
                                    0
                                  ],
                                  "end_point": [
                                    129,
                                    1
                                  ],
                                  "class_docstring": "",
                                  "name": "Main",
                                  "attributes": {
                                    "modifiers": "public",
                                    "marker_annotations": [],
                                    "non_marker_annotations": [
                                      "public"
                                    ],
                                    "comments": [],
                                    "fields": [
                                      {
                                        "attribute_expression": "    private static Logger logger = Logger.getLogger(Main.class.getName());",
                                        "docstring": "",
                                        "modifiers": "private static",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "private",
                                          "static"
                                        ],
                                        "comments": [],
                                        "type": "Logger",
                                        "name": "logger = Logger.getLogger(Main.class.getName())",
                                        "syntax_pass": true
                                      }
                                    ],
                                    "classes": []
                                  },
                                  "syntax_pass": true,
                                  "methods": [
                                    {
                                      "syntax_pass": true,
                                      "byte_span": [
                                        512,
                                        704
                                      ],
                                      "original_string": "    public static void main(String[] args) {\n        if (args.length != 0) {\n            startCommandLine(args);\n        }\n        else {\n            MainGui.launch(MainGui.class);\n        }\n    }",
                                      "docstring": "",
                                      "attributes": {
                                        "modifiers": "public static",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public",
                                          "static"
                                        ],
                                        "comments": [],
                                        "return_type": "void",
                                        "classes": []
                                      },
                                      "name": "main",
                                      "body": "                                           {\n        if (args.length != 0) {\n            startCommandLine(args);\n        }\n        else {\n            MainGui.launch(MainGui.class);\n        }\n    }",
                                      "identifiers": "args length startCommandLine args MainGui launch",
                                      "signature": "    public static void main(String[] args)",
                                      "signature_woname": "    public static void (String[] args)"
                                    },
                                    {
                                      "syntax_pass": true,
                                      "byte_span": [
                                        710,
                                        1322
                                      ],
                                      "original_string": "    private static void startCommandLine(String[] args) {\n        Config config;\n\n        config = parseArgument(args);\n        if (config == null) {\n            printUsage();\n            return;\n        }\n\n        Util.saveFile(Constant.CONF_FILE, config.saveToJson());\n\n        try {\n            //LocalServer server = new LocalServer(config);\n            NioLocalServer server = new NioLocalServer(config);\n            Thread t = new Thread(server);\n            t.start();\n            t.join();\n        } catch (Exception e) {\n            logger.warning(\"Unable to start server: \" + e.toString());\n        }\n    }",
                                      "docstring": "",
                                      "attributes": {
                                        "modifiers": "private static",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "private",
                                          "static"
                                        ],
                                        "comments": [],
                                        "return_type": "void",
                                        "classes": []
                                      },
                                      "name": "startCommandLine",
                                      "body": "                                                        {\n        Config config;\n\n        config = parseArgument(args);\n        if (config == null) {\n            printUsage();\n            return;\n        }\n\n        Util.saveFile(Constant.CONF_FILE, config.saveToJson());\n\n        try {\n            //LocalServer server = new LocalServer(config);\n            NioLocalServer server = new NioLocalServer(config);\n            Thread t = new Thread(server);\n            t.start();\n            t.join();\n        } catch (Exception e) {\n            logger.warning(\"Unable to start server: \" + e.toString());\n        }\n    }",
                                      "identifiers": "config config parseArgument args config printUsage Util saveFile Constant CONF_FILE config saveToJson server config t server t start t join e logger warning e toString",
                                      "signature": "    private static void startCommandLine(String[] args)",
                                      "signature_woname": "    private static void (String[] args)"
                                    },
                                    {
                                      "syntax_pass": true,
                                      "byte_span": [
                                        1328,
                                        3343
                                      ],
                                      "original_string": "    private static Config parseArgument(String[] args) {\n        Config config = new Config();\n\n        if (args.length == 2) {\n            if (args[0].equals(\"--config\")) {\n                Path path = Paths.get(args[1]);\n                try {\n                    String json = new String(Files.readAllBytes(path));\n                    config.loadFromJson(json);\n                } catch (IOException e) {\n                    System.out.println(\"Unable to read configuration file: \" + args[1]);\n                    return null;\n                }\n                return config;\n            }\n            else {\n                return null;\n            }\n        }\n\n        if (args.length != 8) {\n            return null;\n        }\n\n        // parse arguments\n        for (int i = 0; i < args.length; i+=2) {\n            String[] tempArgs;\n            if (args[i].equals(\"--local\")) {\n                tempArgs = args[i+1].split(\":\");\n                if (tempArgs.length < 2) {\n                    System.out.println(\"Invalid argument: \" + args[i]);\n                    return null;\n                }\n                config.setLocalIpAddress(tempArgs[0]);\n                config.setLocalPort(Integer.parseInt(tempArgs[1]));\n            }\n            else if (args[i].equals(\"--remote\")) {\n                tempArgs = args[i+1].split(\":\");\n                if (tempArgs.length < 2) {\n                    System.out.println(\"Invalid argument: \" + args[i]);\n                    return null;\n                }\n                config.setRemoteIpAddress(tempArgs[0]);\n                config.setRemotePort(Integer.parseInt(tempArgs[1]));\n            }\n            else if (args[i].equals(\"--cipher\")) {\n                config.setMethod(args[i+1]);\n            }\n            else if (args[i].equals(\"--password\")) {\n                config.setPassword(args[i + 1]);\n            }\n            else if (args[i].equals(\"--proxy\")) {\n                config.setProxyType(args[i + 1]);\n            }\n        }\n\n        return config;\n    }",
                                      "docstring": "",
                                      "attributes": {
                                        "modifiers": "private static",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "private",
                                          "static"
                                        ],
                                        "comments": [],
                                        "return_type": "Config",
                                        "classes": []
                                      },
                                      "name": "parseArgument",
                                      "body": "                                                       {\n        Config config = new Config();\n\n        if (args.length == 2) {\n            if (args[0].equals(\"--config\")) {\n                Path path = Paths.get(args[1]);\n                try {\n                    String json = new String(Files.readAllBytes(path));\n                    config.loadFromJson(json);\n                } catch (IOException e) {\n                    System.out.println(\"Unable to read configuration file: \" + args[1]);\n                    return null;\n                }\n                return config;\n            }\n            else {\n                return null;\n            }\n        }\n\n        if (args.length != 8) {\n            return null;\n        }\n\n        // parse arguments\n        for (int i = 0; i < args.length; i+=2) {\n            String[] tempArgs;\n            if (args[i].equals(\"--local\")) {\n                tempArgs = args[i+1].split(\":\");\n                if (tempArgs.length < 2) {\n                    System.out.println(\"Invalid argument: \" + args[i]);\n                    return null;\n                }\n                config.setLocalIpAddress(tempArgs[0]);\n                config.setLocalPort(Integer.parseInt(tempArgs[1]));\n            }\n            else if (args[i].equals(\"--remote\")) {\n                tempArgs = args[i+1].split(\":\");\n                if (tempArgs.length < 2) {\n                    System.out.println(\"Invalid argument: \" + args[i]);\n                    return null;\n                }\n                config.setRemoteIpAddress(tempArgs[0]);\n                config.setRemotePort(Integer.parseInt(tempArgs[1]));\n            }\n            else if (args[i].equals(\"--cipher\")) {\n                config.setMethod(args[i+1]);\n            }\n            else if (args[i].equals(\"--password\")) {\n                config.setPassword(args[i + 1]);\n            }\n            else if (args[i].equals(\"--proxy\")) {\n                config.setProxyType(args[i + 1]);\n            }\n        }\n\n        return config;\n    }",
                                      "identifiers": "config args length args equals path Paths get args json Files readAllBytes path config loadFromJson json e System out println args config args length i i args length i tempArgs args i equals tempArgs args i split tempArgs length System out println args i config setLocalIpAddress tempArgs config setLocalPort Integer parseInt tempArgs args i equals tempArgs args i split tempArgs length System out println args i config setRemoteIpAddress tempArgs config setRemotePort Integer parseInt tempArgs args i equals config setMethod args i args i equals config setPassword args i args i equals config setProxyType args i config",
                                      "signature": "    private static Config parseArgument(String[] args)",
                                      "signature_woname": "    private static Config (String[] args)"
                                    },
                                    {
                                      "syntax_pass": true,
                                      "byte_span": [
                                        3349,
                                        4432
                                      ],
                                      "original_string": "    private static void printUsage() {\n        System.out.println(\"Usage: ss --[option] value --[option] value...\");\n        System.out.println(\"Option:\");\n        System.out.println(\"  --local [IP:PORT]\");\n        System.out.println(\"  --remote [IP:PORT]\");\n        System.out.println(\"  --cipher [CIPHER_NAME]\");\n        System.out.println(\"  --password [PASSWORD]\");\n        System.out.println(\"  --config [CONFIG_FILE]\");\n        System.out.println(\"  --proxy [TYPE]\");\n        System.out.println(\"Support Proxy Type:\");\n        for (IProxy.TYPE t : ProxyFactory.getSupportedProxyTypes()) {\n            System.out.printf(\"  %s\\n\", t.toString().toLowerCase());\n        }\n        System.out.println(\"Support Ciphers:\");\n        for (String s : CryptFactory.getSupportedCiphers()) {\n            System.out.printf(\"  %s\\n\", s);\n        }\n        System.out.println(\"Example:\");\n        System.out.println(\"  ss --local \\\"127.0.0.1:1080\\\" --remote \\\"[SS_SERVER_IP]:1080\\\" --cipher \\\"aes-256-cfb\\\" --password \\\"HelloWorld\\\"\");\n        System.out.println(\"  ss --config config.json\");\n    }",
                                      "docstring": "",
                                      "attributes": {
                                        "modifiers": "private static",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "private",
                                          "static"
                                        ],
                                        "comments": [],
                                        "return_type": "void",
                                        "classes": []
                                      },
                                      "name": "printUsage",
                                      "body": "                                     {\n        System.out.println(\"Usage: ss --[option] value --[option] value...\");\n        System.out.println(\"Option:\");\n        System.out.println(\"  --local [IP:PORT]\");\n        System.out.println(\"  --remote [IP:PORT]\");\n        System.out.println(\"  --cipher [CIPHER_NAME]\");\n        System.out.println(\"  --password [PASSWORD]\");\n        System.out.println(\"  --config [CONFIG_FILE]\");\n        System.out.println(\"  --proxy [TYPE]\");\n        System.out.println(\"Support Proxy Type:\");\n        for (IProxy.TYPE t : ProxyFactory.getSupportedProxyTypes()) {\n            System.out.printf(\"  %s\\n\", t.toString().toLowerCase());\n        }\n        System.out.println(\"Support Ciphers:\");\n        for (String s : CryptFactory.getSupportedCiphers()) {\n            System.out.printf(\"  %s\\n\", s);\n        }\n        System.out.println(\"Example:\");\n        System.out.println(\"  ss --local \\\"127.0.0.1:1080\\\" --remote \\\"[SS_SERVER_IP]:1080\\\" --cipher \\\"aes-256-cfb\\\" --password \\\"HelloWorld\\\"\");\n        System.out.println(\"  ss --config config.json\");\n    }",
                                      "identifiers": "System out println System out println System out println System out println System out println System out println System out println System out println System out println t ProxyFactory getSupportedProxyTypes System out printf t toString toLowerCase System out println s CryptFactory getSupportedCiphers System out printf s System out println System out println System out println",
                                      "signature": "    private static void printUsage()",
                                      "signature_woname": "    private static void ()"
                                    }
                                  ]
                                }
                              ]
                            },
                            "imports": [
                              {
                                "original_string": "public class Config {\n    private String _ipAddr;\n    private int _port;\n    private String _localIpAddr;\n    private int _localPort;\n    private String _method;\n    private String _password;\n    private String _logLevel;\n    private IProxy.TYPE _proxyType;\n\n    public Config() {\n        loadFromJson(\"\");\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }\n\n    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }\n\n    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }\n\n    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }\n\n    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }\n\n    public void setRemotePort(int value) {\n        _port = value;\n    }\n\n    public int getRemotePort() {\n        return _port;\n    }\n\n    public void setLocalPort(int value) {\n        _localPort = value;\n    }\n\n    public int getLocalPort() {\n        return _localPort;\n    }\n\n    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }\n\n    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }\n    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }\n\n    public void setMethod(String value) {\n        _method = value;\n    }\n\n    public String getMethod() {\n        return _method;\n    }\n\n    public void setPassword(String value) {\n        _password = value;\n    }\n\n    public String getPassword() {\n        return _password;\n    }\n\n    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }\n\n    public String getLogLevel() {\n        return _logLevel;\n    }\n\n    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }\n\n    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }\n}",
                                "definition": "public class Config",
                                "byte_span": [
                                  1735,
                                  5565
                                ],
                                "start_point": [
                                  41,
                                  0
                                ],
                                "end_point": [
                                  175,
                                  1
                                ],
                                "class_docstring": "",
                                "name": "Config",
                                "attributes": {
                                  "modifiers": "public",
                                  "marker_annotations": [],
                                  "non_marker_annotations": [
                                    "public"
                                  ],
                                  "comments": [],
                                  "fields": [
                                    {
                                      "attribute_expression": "    private String _ipAddr;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "String",
                                      "name": "_ipAddr",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private int _port;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "int",
                                      "name": "_port",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private String _localIpAddr;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "String",
                                      "name": "_localIpAddr",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private int _localPort;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "int",
                                      "name": "_localPort",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private String _method;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "String",
                                      "name": "_method",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private String _password;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "String",
                                      "name": "_password",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private String _logLevel;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "String",
                                      "name": "_logLevel",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private IProxy.TYPE _proxyType;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "IProxy.TYPE",
                                      "name": "_proxyType",
                                      "syntax_pass": true
                                    }
                                  ],
                                  "classes": []
                                },
                                "syntax_pass": true,
                                "methods": [
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      1998,
                                      2047
                                    ],
                                    "original_string": "    public Config() {\n        loadFromJson(\"\");\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "",
                                      "classes": []
                                    },
                                    "name": "Config",
                                    "body": "                    {\n        loadFromJson(\"\");\n    }",
                                    "identifiers": "loadFromJson",
                                    "signature": "    public Config()",
                                    "signature_woname": "    public ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2053,
                                      2393
                                    ],
                                    "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "",
                                      "classes": []
                                    },
                                    "name": "Config",
                                    "body": "                                                                                                              {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                    "identifiers": "_ipAddr ipAddr _port port _localIpAddr localIpAddr _localPort localPort _method method _password password _proxyType IProxy TYPE AUTO",
                                    "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password)",
                                    "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2399,
                                      2627
                                    ],
                                    "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "",
                                      "classes": []
                                    },
                                    "name": "Config",
                                    "body": "                                                                                                                                {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                    "identifiers": "ipAddr port localIpAddr localPort method password _proxyType type",
                                    "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)",
                                    "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2633,
                                      2710
                                    ],
                                    "original_string": "    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "setRemoteIpAddress",
                                    "body": "                                                 {\n        _ipAddr = value;\n    }",
                                    "identifiers": "_ipAddr value",
                                    "signature": "    public void setRemoteIpAddress(String value)",
                                    "signature_woname": "    public void (String value)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2716,
                                      2782
                                    ],
                                    "original_string": "    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "getRemoteIpAddress",
                                    "body": "                                       {\n        return _ipAddr;\n    }",
                                    "identifiers": "_ipAddr",
                                    "signature": "    public String getRemoteIpAddress()",
                                    "signature_woname": "    public String ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2788,
                                      2869
                                    ],
                                    "original_string": "    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "setLocalIpAddress",
                                    "body": "                                                {\n        _localIpAddr = value;\n    }",
                                    "identifiers": "_localIpAddr value",
                                    "signature": "    public void setLocalIpAddress(String value)",
                                    "signature_woname": "    public void (String value)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2875,
                                      2945
                                    ],
                                    "original_string": "    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "getLocalIpAddress",
                                    "body": "                                      {\n        return _localIpAddr;\n    }",
                                    "identifiers": "_localIpAddr",
                                    "signature": "    public String getLocalIpAddress()",
                                    "signature_woname": "    public String ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2951,
                                      3018
                                    ],
                                    "original_string": "    public void setRemotePort(int value) {\n        _port = value;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "setRemotePort",
                                    "body": "                                         {\n        _port = value;\n    }",
                                    "identifiers": "_port value",
                                    "signature": "    public void setRemotePort(int value)",
                                    "signature_woname": "    public void (int value)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3024,
                                      3080
                                    ],
                                    "original_string": "    public int getRemotePort() {\n        return _port;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "int",
                                      "classes": []
                                    },
                                    "name": "getRemotePort",
                                    "body": "                               {\n        return _port;\n    }",
                                    "identifiers": "_port",
                                    "signature": "    public int getRemotePort()",
                                    "signature_woname": "    public int ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3086,
                                      3157
                                    ],
                                    "original_string": "    public void setLocalPort(int value) {\n        _localPort = value;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "setLocalPort",
                                    "body": "                                        {\n        _localPort = value;\n    }",
                                    "identifiers": "_localPort value",
                                    "signature": "    public void setLocalPort(int value)",
                                    "signature_woname": "    public void (int value)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3163,
                                      3223
                                    ],
                                    "original_string": "    public int getLocalPort() {\n        return _localPort;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "int",
                                      "classes": []
                                    },
                                    "name": "getLocalPort",
                                    "body": "                              {\n        return _localPort;\n    }",
                                    "identifiers": "_localPort",
                                    "signature": "    public int getLocalPort()",
                                    "signature_woname": "    public int ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3229,
                                      3599
                                    ],
                                    "original_string": "    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "setProxyType",
                                    "body": "                                           {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                    "identifiers": "_proxyType IProxy TYPE AUTO value toLowerCase equals IProxy TYPE HTTP toString toLowerCase _proxyType IProxy TYPE HTTP value toLowerCase equals IProxy TYPE SOCKS5 toString toLowerCase _proxyType IProxy TYPE SOCKS5",
                                    "signature": "    public void setProxyType(String value)",
                                    "signature_woname": "    public void (String value)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3605,
                                      3684
                                    ],
                                    "original_string": "    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "setProxyType",
                                    "body": "                                                {\n        _proxyType = value;\n    }",
                                    "identifiers": "_proxyType value",
                                    "signature": "    public void setProxyType(IProxy.TYPE value)",
                                    "signature_woname": "    public void (IProxy.TYPE value)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3689,
                                      3757
                                    ],
                                    "original_string": "    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "IProxy.TYPE",
                                      "classes": []
                                    },
                                    "name": "getProxyType",
                                    "body": "                                      {\n        return _proxyType;\n    }",
                                    "identifiers": "_proxyType",
                                    "signature": "    public IProxy.TYPE getProxyType()",
                                    "signature_woname": "    public IProxy.TYPE ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3763,
                                      3831
                                    ],
                                    "original_string": "    public void setMethod(String value) {\n        _method = value;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "setMethod",
                                    "body": "                                        {\n        _method = value;\n    }",
                                    "identifiers": "_method value",
                                    "signature": "    public void setMethod(String value)",
                                    "signature_woname": "    public void (String value)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3837,
                                      3894
                                    ],
                                    "original_string": "    public String getMethod() {\n        return _method;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "getMethod",
                                    "body": "                              {\n        return _method;\n    }",
                                    "identifiers": "_method",
                                    "signature": "    public String getMethod()",
                                    "signature_woname": "    public String ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3900,
                                      3972
                                    ],
                                    "original_string": "    public void setPassword(String value) {\n        _password = value;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "setPassword",
                                    "body": "                                          {\n        _password = value;\n    }",
                                    "identifiers": "_password value",
                                    "signature": "    public void setPassword(String value)",
                                    "signature_woname": "    public void (String value)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3978,
                                      4039
                                    ],
                                    "original_string": "    public String getPassword() {\n        return _password;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "getPassword",
                                    "body": "                                {\n        return _password;\n    }",
                                    "identifiers": "_password",
                                    "signature": "    public String getPassword()",
                                    "signature_woname": "    public String ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      4045,
                                      4150
                                    ],
                                    "original_string": "    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "setLogLevel",
                                    "body": "                                          {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                    "identifiers": "_logLevel value Log init getLogLevel",
                                    "signature": "    public void setLogLevel(String value)",
                                    "signature_woname": "    public void (String value)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      4156,
                                      4217
                                    ],
                                    "original_string": "    public String getLogLevel() {\n        return _logLevel;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "getLogLevel",
                                    "body": "                                {\n        return _logLevel;\n    }",
                                    "identifiers": "_logLevel",
                                    "signature": "    public String getLogLevel()",
                                    "signature_woname": "    public String ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      4223,
                                      5070
                                    ],
                                    "original_string": "    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "loadFromJson",
                                    "body": "                                             {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                    "identifiers": "jsonStr length jsonStr jObj JSONValue parse jsonStr _ipAddr jObj getOrDefault _port jObj getOrDefault intValue _localIpAddr jObj getOrDefault _localPort jObj getOrDefault intValue _method jObj getOrDefault AesCrypt CIPHER_AES_256_CFB _password jObj getOrDefault _logLevel jObj getOrDefault setProxyType jObj getOrDefault IProxy TYPE SOCKS5 toString toLowerCase setLogLevel _logLevel",
                                    "signature": "    public void loadFromJson(String jsonStr)",
                                    "signature_woname": "    public void (String jsonStr)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      5076,
                                      5563
                                    ],
                                    "original_string": "    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "saveToJson",
                                    "body": "                               {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                    "identifiers": "jObj jObj put _ipAddr jObj put _port jObj put _localIpAddr jObj put _localPort jObj put _method jObj put _password jObj put _proxyType toString toLowerCase jObj put _logLevel Util prettyPrintJson jObj",
                                    "signature": "    public String saveToJson()",
                                    "signature_woname": "    public String ()"
                                  }
                                ]
                              },
                              {
                                "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                "definition": "public class Util",
                                "byte_span": [
                                  1779,
                                  7484
                                ],
                                "start_point": [
                                  45,
                                  0
                                ],
                                "end_point": [
                                  219,
                                  1
                                ],
                                "class_docstring": "",
                                "name": "Util",
                                "attributes": {
                                  "modifiers": "public",
                                  "marker_annotations": [],
                                  "non_marker_annotations": [
                                    "public"
                                  ],
                                  "comments": [],
                                  "fields": [],
                                  "classes": []
                                },
                                "syntax_pass": true,
                                "methods": [
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      1803,
                                      2018
                                    ],
                                    "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "dumpBytes",
                                    "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                    "identifiers": "sb a length b a sb append String format b sb toString",
                                    "signature": "    public static String dumpBytes(byte[] a)",
                                    "signature_woname": "    public static String (byte[] a)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2024,
                                      2180
                                    ],
                                    "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "byte[]",
                                      "classes": []
                                    },
                                    "name": "randomBytes",
                                    "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                    "identifiers": "bytes size nextBytes bytes bytes",
                                    "signature": "    public static byte[] randomBytes(int size)",
                                    "signature_woname": "    public static byte[] (int size)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2186,
                                      2412
                                    ],
                                    "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "getErrorMessage",
                                    "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                    "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                    "signature": "    public static String getErrorMessage(Throwable e)",
                                    "signature_woname": "    public static String (Throwable e)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2418,
                                      4165
                                    ],
                                    "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "prettyPrintJson",
                                    "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                    "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                    "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                    "signature_woname": "    public static String (JSONObject jObj)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      4171,
                                      5829
                                    ],
                                    "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "getRequestedHostInfo",
                                    "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                    "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                    "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                    "signature_woname": "    public static String (byte[] data)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      5835,
                                      6128
                                    ],
                                    "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "bytesToString",
                                    "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                    "identifiers": "str str data start length e e printStackTrace str",
                                    "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                    "signature_woname": "    public static String (byte[] data, int start, int length)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      6134,
                                      6648
                                    ],
                                    "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "byte[]",
                                      "classes": []
                                    },
                                    "name": "composeSSHeader",
                                    "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                    "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                    "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                    "signature_woname": "    public static byte[] (String host, int port)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      6654,
                                      6969
                                    ],
                                    "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "boolean",
                                      "classes": []
                                    },
                                    "name": "saveFile",
                                    "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                    "identifiers": "writer writer fn writer println content writer close e",
                                    "signature": "    public static boolean saveFile(String fn, String content)",
                                    "signature_woname": "    public static boolean (String fn, String content)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      6975,
                                      7262
                                    ],
                                    "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "String",
                                      "classes": []
                                    },
                                    "name": "getFileContent",
                                    "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                    "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                    "signature": "    public static String getFileContent(String fn)",
                                    "signature_woname": "    public static String (String fn)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      7268,
                                      7357
                                    ],
                                    "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "private static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "short",
                                      "classes": []
                                    },
                                    "name": "byteToUnsignedByte",
                                    "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                    "identifiers": "b",
                                    "signature": "    private static short byteToUnsignedByte(byte b)",
                                    "signature_woname": "    private static short (byte b)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      7363,
                                      7482
                                    ],
                                    "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "private static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "int",
                                      "classes": []
                                    },
                                    "name": "getPort",
                                    "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                    "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                    "signature": "    private static int getPort(byte b, byte b1)",
                                    "signature_woname": "    private static int (byte b, byte b1)"
                                  }
                                ]
                              },
                              {
                                "original_string": "public class LocalServer implements IServer {\n    private Logger logger = Logger.getLogger(LocalServer.class.getName());\n    private Config _config;\n    private ServerSocket _serverSocket;\n    private Executor _executor;\n    private List<PipeSocket> _pipes;\n\n    public LocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        if (!CryptFactory.isCipherExisted(config.getMethod())) {\n            throw new InvalidAlgorithmParameterException(config.getMethod());\n        }\n        _config = config;\n        _serverSocket = new ServerSocket(config.getLocalPort(), 128);\n        _executor = Executors.newCachedThreadPool();\n        _pipes = new ArrayList<>();\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Socket localSocket = _serverSocket.accept();\n                PipeSocket pipe = new PipeSocket(_executor, localSocket, _config);\n                _pipes.add(pipe);\n                _executor.execute(pipe);\n            } catch (IOException e) {\n                logger.warning(Util.getErrorMessage(e));\n            }\n        }\n    }\n\n    public void close() {\n        try {\n            for (PipeSocket p : _pipes) {\n                p.close();\n            }\n            _pipes.clear();\n            _serverSocket.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n    }\n\n}",
                                "definition": "public class LocalServer implements IServer",
                                "byte_span": [
                                  2047,
                                  3656
                                ],
                                "start_point": [
                                  52,
                                  0
                                ],
                                "end_point": [
                                  99,
                                  1
                                ],
                                "class_docstring": "",
                                "name": "LocalServer",
                                "attributes": {
                                  "modifiers": "public",
                                  "marker_annotations": [],
                                  "non_marker_annotations": [
                                    "public"
                                  ],
                                  "comments": [],
                                  "fields": [
                                    {
                                      "attribute_expression": "    private Logger logger = Logger.getLogger(LocalServer.class.getName());",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "Logger",
                                      "name": "logger = Logger.getLogger(LocalServer.class.getName())",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private Config _config;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "Config",
                                      "name": "_config",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private ServerSocket _serverSocket;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "ServerSocket",
                                      "name": "_serverSocket",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private Executor _executor;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "Executor",
                                      "name": "_executor",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private List<PipeSocket> _pipes;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "List<PipeSocket>",
                                      "name": "_pipes",
                                      "syntax_pass": true
                                    }
                                  ],
                                  "classes": []
                                },
                                "syntax_pass": true,
                                "methods": [
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2310,
                                      2939
                                    ],
                                    "original_string": "    public LocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        if (!CryptFactory.isCipherExisted(config.getMethod())) {\n            throw new InvalidAlgorithmParameterException(config.getMethod());\n        }\n        _config = config;\n        _serverSocket = new ServerSocket(config.getLocalPort(), 128);\n        _executor = Executors.newCachedThreadPool();\n        _pipes = new ArrayList<>();\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "",
                                      "classes": []
                                    },
                                    "name": "LocalServer",
                                    "body": "                                                                                             {\n        if (!CryptFactory.isCipherExisted(config.getMethod())) {\n            throw new InvalidAlgorithmParameterException(config.getMethod());\n        }\n        _config = config;\n        _serverSocket = new ServerSocket(config.getLocalPort(), 128);\n        _executor = Executors.newCachedThreadPool();\n        _pipes = new ArrayList<>();\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }",
                                    "identifiers": "CryptFactory isCipherExisted config getMethod config getMethod _config config _serverSocket config getLocalPort _executor Executors newCachedThreadPool _pipes logger info Constant VERSION logger info config getProxyType config getLocalPort",
                                    "signature": "    public LocalServer(Config config)",
                                    "signature_woname": "    public (Config config)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2945,
                                      3363
                                    ],
                                    "original_string": "    @Override\n    public void run() {\n        while (true) {\n            try {\n                Socket localSocket = _serverSocket.accept();\n                PipeSocket pipe = new PipeSocket(_executor, localSocket, _config);\n                _pipes.add(pipe);\n                _executor.execute(pipe);\n            } catch (IOException e) {\n                logger.warning(Util.getErrorMessage(e));\n            }\n        }\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "@Override\n    public",
                                      "marker_annotations": [
                                        "@Override"
                                      ],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "run",
                                    "body": "                      {\n        while (true) {\n            try {\n                Socket localSocket = _serverSocket.accept();\n                PipeSocket pipe = new PipeSocket(_executor, localSocket, _config);\n                _pipes.add(pipe);\n                _executor.execute(pipe);\n            } catch (IOException e) {\n                logger.warning(Util.getErrorMessage(e));\n            }\n        }\n    }",
                                    "identifiers": "localSocket _serverSocket accept pipe _executor localSocket _config _pipes add pipe _executor execute pipe e logger warning Util getErrorMessage e",
                                    "signature": "    @Override\n    public void run()",
                                    "signature_woname": "    @Override\n    public void ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3369,
                                      3653
                                    ],
                                    "original_string": "    public void close() {\n        try {\n            for (PipeSocket p : _pipes) {\n                p.close();\n            }\n            _pipes.clear();\n            _serverSocket.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "close",
                                    "body": "                        {\n        try {\n            for (PipeSocket p : _pipes) {\n                p.close();\n            }\n            _pipes.clear();\n            _serverSocket.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n    }",
                                    "identifiers": "p _pipes p close _pipes clear _serverSocket close e logger warning Util getErrorMessage e",
                                    "signature": "    public void close()",
                                    "signature_woname": "    public void ()"
                                  }
                                ]
                              },
                              {
                                "original_string": "public class NioLocalServer extends SocketHandlerBase {\n    private Logger logger = Logger.getLogger(NioLocalServer.class.getName());\n\n    private ServerSocketChannel _serverChannel;\n    private RemoteSocketHandler _remoteSocketHandler;\n    private ExecutorService _executor;\n\n    public NioLocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        super(config);\n        _executor = Executors.newCachedThreadPool();\n\n        // init remote socket handler\n        _remoteSocketHandler = new RemoteSocketHandler(_config);\n        _executor.execute(_remoteSocketHandler);\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(\"Cipher: \" + config.getMethod());\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }\n\n    @Override\n    protected Selector initSelector() throws IOException {\n        Selector socketSelector = SelectorProvider.provider().openSelector();\n        _serverChannel = ServerSocketChannel.open();\n        _serverChannel.configureBlocking(false);\n        InetSocketAddress isa = new InetSocketAddress(_config.getLocalIpAddress(), _config.getLocalPort());\n        _serverChannel.socket().bind(isa);\n        _serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n\n        return socketSelector;\n    }\n\n    @Override\n    protected boolean processPendingRequest(ChangeRequest request) {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                SelectionKey key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"NioLocalServer::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n        return true;\n    }\n\n    @Override\n    protected void processSelect(SelectionKey key) {\n        // Handle event\n        try {\n            if (key.isAcceptable()) {\n                accept(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        }\n        catch (IOException e) {\n            cleanUp((SocketChannel)key.channel());\n        }\n    }\n\n    private void accept(SelectionKey key) throws IOException {\n        // local socket established\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(_selector, SelectionKey.OP_READ);\n\n        // prepare local socket write queue\n        createWriteBuffer(socketChannel);\n\n        // create pipe between local and remote socket\n        PipeWorker pipe = _remoteSocketHandler.createPipe(this, socketChannel, _config.getRemoteIpAddress(), _config.getRemotePort());\n        _pipes.put(socketChannel, pipe);\n        _executor.execute(pipe);\n    }\n\n    private void read(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        int readCount;\n        PipeWorker pipe = _pipes.get(socketChannel);\n        byte[] data;\n\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        _readBuffer.clear();\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        data = _readBuffer.array();\n        pipe.processData(data, readCount, true);\n    }\n\n    private void write(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // Write data\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"LocalSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }\n\n    @Override\n    protected void cleanUp(SocketChannel socketChannel) {\n        //logger.warning(\"LocalSocket closed: \" + socketChannel);\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"LocalSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"LocalSocket closed (NULL): \" + socketChannel);\n        }\n\n    }\n\n    @Override\n    public void close() {\n        super.close();\n        _executor.shutdownNow();\n\n        try {\n            _serverChannel.close();\n            _remoteSocketHandler.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n        logger.info(\"Server closed.\");\n    }\n}",
                                "definition": "public class NioLocalServer extends SocketHandlerBase",
                                "byte_span": [
                                  2202,
                                  7856
                                ],
                                "start_point": [
                                  55,
                                  0
                                ],
                                "end_point": [
                                  225,
                                  1
                                ],
                                "class_docstring": "",
                                "name": "NioLocalServer",
                                "attributes": {
                                  "modifiers": "public",
                                  "marker_annotations": [],
                                  "non_marker_annotations": [
                                    "public"
                                  ],
                                  "comments": [],
                                  "fields": [
                                    {
                                      "attribute_expression": "    private Logger logger = Logger.getLogger(NioLocalServer.class.getName());",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "Logger",
                                      "name": "logger = Logger.getLogger(NioLocalServer.class.getName())",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private ServerSocketChannel _serverChannel;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "ServerSocketChannel",
                                      "name": "_serverChannel",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private RemoteSocketHandler _remoteSocketHandler;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "RemoteSocketHandler",
                                      "name": "_remoteSocketHandler",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private ExecutorService _executor;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "ExecutorService",
                                      "name": "_executor",
                                      "syntax_pass": true
                                    }
                                  ],
                                  "classes": []
                                },
                                "syntax_pass": true,
                                "methods": [
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2483,
                                      3060
                                    ],
                                    "original_string": "    public NioLocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        super(config);\n        _executor = Executors.newCachedThreadPool();\n\n        // init remote socket handler\n        _remoteSocketHandler = new RemoteSocketHandler(_config);\n        _executor.execute(_remoteSocketHandler);\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(\"Cipher: \" + config.getMethod());\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "",
                                      "classes": []
                                    },
                                    "name": "NioLocalServer",
                                    "body": "                                                                                                {\n        super(config);\n        _executor = Executors.newCachedThreadPool();\n\n        // init remote socket handler\n        _remoteSocketHandler = new RemoteSocketHandler(_config);\n        _executor.execute(_remoteSocketHandler);\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(\"Cipher: \" + config.getMethod());\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }",
                                    "identifiers": "config _executor Executors newCachedThreadPool _remoteSocketHandler _config _executor execute _remoteSocketHandler logger info Constant VERSION logger info config getMethod logger info config getProxyType config getLocalPort",
                                    "signature": "    public NioLocalServer(Config config)",
                                    "signature_woname": "    public (Config config)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3066,
                                      3576
                                    ],
                                    "original_string": "    @Override\n    protected Selector initSelector() throws IOException {\n        Selector socketSelector = SelectorProvider.provider().openSelector();\n        _serverChannel = ServerSocketChannel.open();\n        _serverChannel.configureBlocking(false);\n        InetSocketAddress isa = new InetSocketAddress(_config.getLocalIpAddress(), _config.getLocalPort());\n        _serverChannel.socket().bind(isa);\n        _serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n\n        return socketSelector;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "@Override\n    protected",
                                      "marker_annotations": [
                                        "@Override"
                                      ],
                                      "non_marker_annotations": [
                                        "protected"
                                      ],
                                      "comments": [],
                                      "return_type": "Selector",
                                      "classes": []
                                    },
                                    "name": "initSelector",
                                    "body": "                                                         {\n        Selector socketSelector = SelectorProvider.provider().openSelector();\n        _serverChannel = ServerSocketChannel.open();\n        _serverChannel.configureBlocking(false);\n        InetSocketAddress isa = new InetSocketAddress(_config.getLocalIpAddress(), _config.getLocalPort());\n        _serverChannel.socket().bind(isa);\n        _serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n\n        return socketSelector;\n    }",
                                    "identifiers": "socketSelector SelectorProvider provider openSelector _serverChannel ServerSocketChannel open _serverChannel configureBlocking isa _config getLocalIpAddress _config getLocalPort _serverChannel socket bind isa _serverChannel register socketSelector SelectionKey OP_ACCEPT socketSelector",
                                    "signature": "    @Override\n    protected Selector initSelector()",
                                    "signature_woname": "    @Override\n    protected Selector ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3582,
                                      4235
                                    ],
                                    "original_string": "    @Override\n    protected boolean processPendingRequest(ChangeRequest request) {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                SelectionKey key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"NioLocalServer::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n        return true;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "@Override\n    protected",
                                      "marker_annotations": [
                                        "@Override"
                                      ],
                                      "non_marker_annotations": [
                                        "protected"
                                      ],
                                      "comments": [],
                                      "return_type": "boolean",
                                      "classes": []
                                    },
                                    "name": "processPendingRequest",
                                    "body": "                                                                   {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                SelectionKey key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"NioLocalServer::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n        return true;\n    }",
                                    "identifiers": "request type ChangeRequest CHANGE_SOCKET_OP key request socket keyFor _selector key key isValid key interestOps request op logger warning key request socket ChangeRequest CLOSE_CHANNEL cleanUp request socket",
                                    "signature": "    @Override\n    protected boolean processPendingRequest(ChangeRequest request)",
                                    "signature_woname": "    @Override\n    protected boolean (ChangeRequest request)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      4241,
                                      4672
                                    ],
                                    "original_string": "    @Override\n    protected void processSelect(SelectionKey key) {\n        // Handle event\n        try {\n            if (key.isAcceptable()) {\n                accept(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        }\n        catch (IOException e) {\n            cleanUp((SocketChannel)key.channel());\n        }\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "@Override\n    protected",
                                      "marker_annotations": [
                                        "@Override"
                                      ],
                                      "non_marker_annotations": [
                                        "protected"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "processSelect",
                                    "body": "                                                   {\n        // Handle event\n        try {\n            if (key.isAcceptable()) {\n                accept(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        }\n        catch (IOException e) {\n            cleanUp((SocketChannel)key.channel());\n        }\n    }",
                                    "identifiers": "key isAcceptable accept key key isReadable read key key isWritable write key e cleanUp key channel",
                                    "signature": "    @Override\n    protected void processSelect(SelectionKey key)",
                                    "signature_woname": "    @Override\n    protected void (SelectionKey key)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      4678,
                                      5398
                                    ],
                                    "original_string": "    private void accept(SelectionKey key) throws IOException {\n        // local socket established\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(_selector, SelectionKey.OP_READ);\n\n        // prepare local socket write queue\n        createWriteBuffer(socketChannel);\n\n        // create pipe between local and remote socket\n        PipeWorker pipe = _remoteSocketHandler.createPipe(this, socketChannel, _config.getRemoteIpAddress(), _config.getRemotePort());\n        _pipes.put(socketChannel, pipe);\n        _executor.execute(pipe);\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "accept",
                                    "body": "                                                             {\n        // local socket established\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(_selector, SelectionKey.OP_READ);\n\n        // prepare local socket write queue\n        createWriteBuffer(socketChannel);\n\n        // create pipe between local and remote socket\n        PipeWorker pipe = _remoteSocketHandler.createPipe(this, socketChannel, _config.getRemoteIpAddress(), _config.getRemotePort());\n        _pipes.put(socketChannel, pipe);\n        _executor.execute(pipe);\n    }",
                                    "identifiers": "serverSocketChannel key channel socketChannel serverSocketChannel accept socketChannel configureBlocking socketChannel register _selector SelectionKey OP_READ createWriteBuffer socketChannel pipe _remoteSocketHandler createPipe socketChannel _config getRemoteIpAddress _config getRemotePort _pipes put socketChannel pipe _executor execute pipe",
                                    "signature": "    private void accept(SelectionKey key)",
                                    "signature_woname": "    private void (SelectionKey key)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      5404,
                                      6145
                                    ],
                                    "original_string": "    private void read(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        int readCount;\n        PipeWorker pipe = _pipes.get(socketChannel);\n        byte[] data;\n\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        _readBuffer.clear();\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        data = _readBuffer.array();\n        pipe.processData(data, readCount, true);\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "read",
                                    "body": "                                                           {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        int readCount;\n        PipeWorker pipe = _pipes.get(socketChannel);\n        byte[] data;\n\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        _readBuffer.clear();\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        data = _readBuffer.array();\n        pipe.processData(data, readCount, true);\n    }",
                                    "identifiers": "socketChannel key channel readCount pipe _pipes get socketChannel data pipe cleanUp socketChannel _readBuffer clear readCount socketChannel read _readBuffer e cleanUp socketChannel readCount cleanUp socketChannel data _readBuffer array pipe processData data readCount",
                                    "signature": "    private void read(SelectionKey key)",
                                    "signature_woname": "    private void (SelectionKey key)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      6151,
                                      7014
                                    ],
                                    "original_string": "    private void write(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // Write data\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"LocalSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "write",
                                    "body": "                                                            {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // Write data\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"LocalSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }",
                                    "identifiers": "socketChannel key channel queue _pendingData get socketChannel queue queue queue isEmpty buf queue get socketChannel write buf buf remaining queue remove queue isEmpty key interestOps SelectionKey OP_READ logger warning socketChannel",
                                    "signature": "    private void write(SelectionKey key)",
                                    "signature_woname": "    private void (SelectionKey key)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      7020,
                                      7522
                                    ],
                                    "original_string": "    @Override\n    protected void cleanUp(SocketChannel socketChannel) {\n        //logger.warning(\"LocalSocket closed: \" + socketChannel);\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"LocalSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"LocalSocket closed (NULL): \" + socketChannel);\n        }\n\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "@Override\n    protected",
                                      "marker_annotations": [
                                        "@Override"
                                      ],
                                      "non_marker_annotations": [
                                        "protected"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "cleanUp",
                                    "body": "                                                        {\n        //logger.warning(\"LocalSocket closed: \" + socketChannel);\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"LocalSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"LocalSocket closed (NULL): \" + socketChannel);\n        }\n\n    }",
                                    "identifiers": "cleanUp socketChannel pipe _pipes get socketChannel pipe pipe close _pipes remove socketChannel logger fine pipe socketInfo logger fine socketChannel",
                                    "signature": "    @Override\n    protected void cleanUp(SocketChannel socketChannel)",
                                    "signature_woname": "    @Override\n    protected void (SocketChannel socketChannel)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      7528,
                                      7854
                                    ],
                                    "original_string": "    @Override\n    public void close() {\n        super.close();\n        _executor.shutdownNow();\n\n        try {\n            _serverChannel.close();\n            _remoteSocketHandler.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n        logger.info(\"Server closed.\");\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "@Override\n    public",
                                      "marker_annotations": [
                                        "@Override"
                                      ],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "close",
                                    "body": "                        {\n        super.close();\n        _executor.shutdownNow();\n\n        try {\n            _serverChannel.close();\n            _remoteSocketHandler.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n        logger.info(\"Server closed.\");\n    }",
                                    "identifiers": "close _executor shutdownNow _serverChannel close _remoteSocketHandler close e logger warning Util getErrorMessage e logger info",
                                    "signature": "    @Override\n    public void close()",
                                    "signature_woname": "    @Override\n    public void ()"
                                  }
                                ]
                              },
                              {
                                "original_string": "public class ProxyFactory {\n    public static final Map<IProxy.TYPE, String> proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }};\n    private static Logger logger = Logger.getLogger(ProxyFactory.class.getName());\n\n    public static boolean isProxyTypeExisted(String name) {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }\n\n    public static IProxy get(IProxy.TYPE type) {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<IProxy.TYPE> getSupportedProxyTypes() {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                "definition": "public class ProxyFactory",
                                "byte_span": [
                                  1660,
                                  2707
                                ],
                                "start_point": [
                                  40,
                                  0
                                ],
                                "end_point": [
                                  70,
                                  1
                                ],
                                "class_docstring": "",
                                "name": "ProxyFactory",
                                "attributes": {
                                  "modifiers": "public",
                                  "marker_annotations": [],
                                  "non_marker_annotations": [
                                    "public"
                                  ],
                                  "comments": [],
                                  "fields": [
                                    {
                                      "attribute_expression": "    public static final Map<IProxy.TYPE, String> proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }};",
                                      "docstring": "",
                                      "modifiers": "public static final",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static",
                                        "final"
                                      ],
                                      "comments": [],
                                      "type": "Map<IProxy.TYPE, String>",
                                      "name": "proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }}",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private static Logger logger = Logger.getLogger(ProxyFactory.class.getName());",
                                      "docstring": "",
                                      "modifiers": "private static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private",
                                        "static"
                                      ],
                                      "comments": [],
                                      "type": "Logger",
                                      "name": "logger = Logger.getLogger(ProxyFactory.class.getName())",
                                      "syntax_pass": true
                                    }
                                  ],
                                  "classes": []
                                },
                                "syntax_pass": true,
                                "methods": [
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2059,
                                      2218
                                    ],
                                    "original_string": "    public static boolean isProxyTypeExisted(String name) {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "boolean",
                                      "classes": []
                                    },
                                    "name": "isProxyTypeExisted",
                                    "body": "                                                          {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }",
                                    "identifiers": "type IProxy TYPE valueOf name proxies get type",
                                    "signature": "    public static boolean isProxyTypeExisted(String name)",
                                    "signature_woname": "    public static boolean (String name)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2224,
                                      2509
                                    ],
                                    "original_string": "    public static IProxy get(IProxy.TYPE type) {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "IProxy",
                                      "classes": []
                                    },
                                    "name": "get",
                                    "body": "                                               {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                    "identifiers": "obj Reflection get proxies get type obj e logger info com stfl misc Util getErrorMessage e",
                                    "signature": "    public static IProxy get(IProxy.TYPE type)",
                                    "signature_woname": "    public static IProxy (IProxy.TYPE type)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2515,
                                      2705
                                    ],
                                    "original_string": "    public static List<IProxy.TYPE> getSupportedProxyTypes() {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "List<IProxy.TYPE>",
                                      "classes": []
                                    },
                                    "name": "getSupportedProxyTypes",
                                    "body": "                                                             {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                    "identifiers": "sortedKeys proxies keySet Collections sort sortedKeys sortedKeys",
                                    "signature": "    public static List<IProxy.TYPE> getSupportedProxyTypes()",
                                    "signature_woname": "    public static List<IProxy.TYPE> ()"
                                  }
                                ]
                              },
                              {
                                "original_string": "public class CryptFactory {\n    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};\n    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());\n\n    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }\n\n    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                "definition": "public class CryptFactory",
                                "byte_span": [
                                  1649,
                                  2693
                                ],
                                "start_point": [
                                  40,
                                  0
                                ],
                                "end_point": [
                                  71,
                                  1
                                ],
                                "class_docstring": "",
                                "name": "CryptFactory",
                                "attributes": {
                                  "modifiers": "public",
                                  "marker_annotations": [],
                                  "non_marker_annotations": [
                                    "public"
                                  ],
                                  "comments": [],
                                  "fields": [
                                    {
                                      "attribute_expression": "    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};",
                                      "docstring": "",
                                      "modifiers": "private static final",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private",
                                        "static",
                                        "final"
                                      ],
                                      "comments": [],
                                      "type": "Map<String, String>",
                                      "name": "crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }}",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());",
                                      "docstring": "",
                                      "modifiers": "private static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private",
                                        "static"
                                      ],
                                      "comments": [],
                                      "type": "Logger",
                                      "name": "logger = Logger.getLogger(CryptFactory.class.getName())",
                                      "syntax_pass": true
                                    }
                                  ],
                                  "classes": []
                                },
                                "syntax_pass": true,
                                "methods": [
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2057,
                                      2158
                                    ],
                                    "original_string": "    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "boolean",
                                      "classes": []
                                    },
                                    "name": "isCipherExisted",
                                    "body": "                                                       {\n        return (crypts.get(name) != null);\n    }",
                                    "identifiers": "crypts get name",
                                    "signature": "    public static boolean isCipherExisted(String name)",
                                    "signature_woname": "    public static boolean (String name)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2164,
                                      2504
                                    ],
                                    "original_string": "    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "ICrypt",
                                      "classes": []
                                    },
                                    "name": "get",
                                    "body": "                                                           {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                    "identifiers": "obj Reflection get crypts get name name password obj e logger info com stfl misc Util getErrorMessage e",
                                    "signature": "    public static ICrypt get(String name, String password)",
                                    "signature_woname": "    public static ICrypt (String name, String password)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      2510,
                                      2691
                                    ],
                                    "original_string": "    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public static",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public",
                                        "static"
                                      ],
                                      "comments": [],
                                      "return_type": "List<String>",
                                      "classes": []
                                    },
                                    "name": "getSupportedCiphers",
                                    "body": "                                                     {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                    "identifiers": "sortedKeys crypts keySet Collections sort sortedKeys sortedKeys",
                                    "signature": "    public static List<String> getSupportedCiphers()",
                                    "signature_woname": "    public static List<String> ()"
                                  }
                                ]
                              }
                            ]
                          },
                          {
                            "name": "MainGui.java",
                            "content": "package com.stfl;\n\nimport com.stfl.misc.UTF8Control;\nimport com.stfl.ui.MainLayoutController;\nimport javafx.application.Application;\nimport javafx.application.Platform;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Scene;\nimport javafx.scene.image.Image;\nimport javafx.scene.layout.Pane;\nimport javafx.stage.Stage;\n\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.IOException;\nimport java.util.ResourceBundle;\nimport java.util.logging.Logger;\n\npublic class MainGui extends Application {\n    private static Logger logger = Logger.getLogger(MainGui.class.getName());\n    private Stage primaryStage;\n    private Scene rootScene;\n    private MainLayoutController controller;\n    private TrayIcon trayIcon;\n\n    @Override\n    public void start(Stage primaryStage) throws Exception {\n\n        Platform.setImplicitExit(false);\n        this.primaryStage = primaryStage;\n        this.primaryStage.setTitle(\"Server Configuration\");\n\n        try {\n            // Load the root layout from the fxml file\n            FXMLLoader mainLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/MainLayout.fxml\"));\n            mainLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane rootLayout = mainLayoutLoader.load();\n\n            rootScene = new Scene(rootLayout);\n            primaryStage.setScene(rootScene);\n            primaryStage.setResizable(false);\n\n            controller = mainLayoutLoader.getController();\n            controller.setMainGui(this);\n\n            addToTray();\n\n            primaryStage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n            primaryStage.show();\n        } catch (IOException e) {\n            // Exception gets thrown if the fxml file could not be loaded\n            e.printStackTrace();\n        }\n    }\n\n\n    private void addToTray() {\n        // ensure awt is initialized\n        java.awt.Toolkit.getDefaultToolkit();\n\n        // make sure system tray is supported\n        if (!java.awt.SystemTray.isSupported()) {\n            logger.warning(\"No system tray support!\");\n        }\n\n        final java.awt.SystemTray tray = java.awt.SystemTray.getSystemTray();\n        try {\n\n            java.awt.Image image = ImageIO.read(MainGui.class.getResource(\"/resources/image/icon.png\"));\n            trayIcon = new TrayIcon(image);\n            trayIcon.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            primaryStage.show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem openItem = new java.awt.MenuItem(\"Configuration\");\n            openItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem exitItem = new java.awt.MenuItem(\"Exit\");\n            exitItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    controller.closeServer();\n                    Platform.exit();\n                    tray.remove(trayIcon);\n                }\n            });\n\n            PopupMenu popup = new PopupMenu();\n            popup.add(openItem);\n            popup.addSeparator();\n            popup.add(exitItem);\n            trayIcon.setPopupMenu(popup);\n            trayIcon.setToolTip(\"Not Connected\");\n            tray.add(trayIcon);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (AWTException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void show() {\n        primaryStage.show();\n    }\n\n    public void hide() {\n        primaryStage.hide();\n    }\n\n    public void setTooltip(String message) {\n        if (trayIcon != null) {\n            trayIcon.setToolTip(message);\n        }\n    }\n\n    public void showNotification(String message) {\n        trayIcon.displayMessage(\n                \"shadowsocks-java\",\n                message,\n                java.awt.TrayIcon.MessageType.INFO\n        );\n    }\n}\n",
                            "schema": {
                              "file_docstring": "",
                              "contexts": [
                                "package com.stfl;",
                                "import com.stfl.misc.UTF8Control;",
                                "import com.stfl.ui.MainLayoutController;",
                                "import javafx.application.Application;",
                                "import javafx.application.Platform;",
                                "import javafx.fxml.FXMLLoader;",
                                "import javafx.scene.Scene;",
                                "import javafx.scene.image.Image;",
                                "import javafx.scene.layout.Pane;",
                                "import javafx.stage.Stage;",
                                "import javax.imageio.ImageIO;",
                                "import java.awt.*;",
                                "import java.awt.event.ActionEvent;",
                                "import java.awt.event.ActionListener;",
                                "import java.io.IOException;",
                                "import java.util.ResourceBundle;",
                                "import java.util.logging.Logger;"
                              ],
                              "methods": [],
                              "classes": [
                                {
                                  "original_string": "public class MainGui extends Application {\n    private static Logger logger = Logger.getLogger(MainGui.class.getName());\n    private Stage primaryStage;\n    private Scene rootScene;\n    private MainLayoutController controller;\n    private TrayIcon trayIcon;\n\n    @Override\n    public void start(Stage primaryStage) throws Exception {\n\n        Platform.setImplicitExit(false);\n        this.primaryStage = primaryStage;\n        this.primaryStage.setTitle(\"Server Configuration\");\n\n        try {\n            // Load the root layout from the fxml file\n            FXMLLoader mainLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/MainLayout.fxml\"));\n            mainLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane rootLayout = mainLayoutLoader.load();\n\n            rootScene = new Scene(rootLayout);\n            primaryStage.setScene(rootScene);\n            primaryStage.setResizable(false);\n\n            controller = mainLayoutLoader.getController();\n            controller.setMainGui(this);\n\n            addToTray();\n\n            primaryStage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n            primaryStage.show();\n        } catch (IOException e) {\n            // Exception gets thrown if the fxml file could not be loaded\n            e.printStackTrace();\n        }\n    }\n\n\n    private void addToTray() {\n        // ensure awt is initialized\n        java.awt.Toolkit.getDefaultToolkit();\n\n        // make sure system tray is supported\n        if (!java.awt.SystemTray.isSupported()) {\n            logger.warning(\"No system tray support!\");\n        }\n\n        final java.awt.SystemTray tray = java.awt.SystemTray.getSystemTray();\n        try {\n\n            java.awt.Image image = ImageIO.read(MainGui.class.getResource(\"/resources/image/icon.png\"));\n            trayIcon = new TrayIcon(image);\n            trayIcon.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            primaryStage.show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem openItem = new java.awt.MenuItem(\"Configuration\");\n            openItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem exitItem = new java.awt.MenuItem(\"Exit\");\n            exitItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    controller.closeServer();\n                    Platform.exit();\n                    tray.remove(trayIcon);\n                }\n            });\n\n            PopupMenu popup = new PopupMenu();\n            popup.add(openItem);\n            popup.addSeparator();\n            popup.add(exitItem);\n            trayIcon.setPopupMenu(popup);\n            trayIcon.setToolTip(\"Not Connected\");\n            tray.add(trayIcon);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (AWTException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void show() {\n        primaryStage.show();\n    }\n\n    public void hide() {\n        primaryStage.hide();\n    }\n\n    public void setTooltip(String message) {\n        if (trayIcon != null) {\n            trayIcon.setToolTip(message);\n        }\n    }\n\n    public void showNotification(String message) {\n        trayIcon.displayMessage(\n                \"shadowsocks-java\",\n                message,\n                java.awt.TrayIcon.MessageType.INFO\n        );\n    }\n}",
                                  "definition": "public class MainGui extends Application",
                                  "byte_span": [
                                    538,
                                    4662
                                  ],
                                  "start_point": [
                                    20,
                                    0
                                  ],
                                  "end_point": [
                                    142,
                                    1
                                  ],
                                  "class_docstring": "",
                                  "name": "MainGui",
                                  "attributes": {
                                    "modifiers": "public",
                                    "marker_annotations": [],
                                    "non_marker_annotations": [
                                      "public"
                                    ],
                                    "comments": [],
                                    "fields": [
                                      {
                                        "attribute_expression": "    private static Logger logger = Logger.getLogger(MainGui.class.getName());",
                                        "docstring": "",
                                        "modifiers": "private static",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "private",
                                          "static"
                                        ],
                                        "comments": [],
                                        "type": "Logger",
                                        "name": "logger = Logger.getLogger(MainGui.class.getName())",
                                        "syntax_pass": true
                                      },
                                      {
                                        "attribute_expression": "    private Stage primaryStage;",
                                        "docstring": "",
                                        "modifiers": "private",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "private"
                                        ],
                                        "comments": [],
                                        "type": "Stage",
                                        "name": "primaryStage",
                                        "syntax_pass": true
                                      },
                                      {
                                        "attribute_expression": "    private Scene rootScene;",
                                        "docstring": "",
                                        "modifiers": "private",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "private"
                                        ],
                                        "comments": [],
                                        "type": "Scene",
                                        "name": "rootScene",
                                        "syntax_pass": true
                                      },
                                      {
                                        "attribute_expression": "    private MainLayoutController controller;",
                                        "docstring": "",
                                        "modifiers": "private",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "private"
                                        ],
                                        "comments": [],
                                        "type": "MainLayoutController",
                                        "name": "controller",
                                        "syntax_pass": true
                                      },
                                      {
                                        "attribute_expression": "    private TrayIcon trayIcon;",
                                        "docstring": "",
                                        "modifiers": "private",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "private"
                                        ],
                                        "comments": [],
                                        "type": "TrayIcon",
                                        "name": "trayIcon",
                                        "syntax_pass": true
                                      }
                                    ],
                                    "classes": []
                                  },
                                  "syntax_pass": true,
                                  "methods": [
                                    {
                                      "syntax_pass": true,
                                      "byte_span": [
                                        801,
                                        1963
                                      ],
                                      "original_string": "    @Override\n    public void start(Stage primaryStage) throws Exception {\n\n        Platform.setImplicitExit(false);\n        this.primaryStage = primaryStage;\n        this.primaryStage.setTitle(\"Server Configuration\");\n\n        try {\n            // Load the root layout from the fxml file\n            FXMLLoader mainLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/MainLayout.fxml\"));\n            mainLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane rootLayout = mainLayoutLoader.load();\n\n            rootScene = new Scene(rootLayout);\n            primaryStage.setScene(rootScene);\n            primaryStage.setResizable(false);\n\n            controller = mainLayoutLoader.getController();\n            controller.setMainGui(this);\n\n            addToTray();\n\n            primaryStage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n            primaryStage.show();\n        } catch (IOException e) {\n            // Exception gets thrown if the fxml file could not be loaded\n            e.printStackTrace();\n        }\n    }",
                                      "docstring": "",
                                      "attributes": {
                                        "modifiers": "@Override\n    public",
                                        "marker_annotations": [
                                          "@Override"
                                        ],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "return_type": "void",
                                        "classes": []
                                      },
                                      "name": "start",
                                      "body": "                                                           {\n\n        Platform.setImplicitExit(false);\n        this.primaryStage = primaryStage;\n        this.primaryStage.setTitle(\"Server Configuration\");\n\n        try {\n            // Load the root layout from the fxml file\n            FXMLLoader mainLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/MainLayout.fxml\"));\n            mainLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane rootLayout = mainLayoutLoader.load();\n\n            rootScene = new Scene(rootLayout);\n            primaryStage.setScene(rootScene);\n            primaryStage.setResizable(false);\n\n            controller = mainLayoutLoader.getController();\n            controller.setMainGui(this);\n\n            addToTray();\n\n            primaryStage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n            primaryStage.show();\n        } catch (IOException e) {\n            // Exception gets thrown if the fxml file could not be loaded\n            e.printStackTrace();\n        }\n    }",
                                      "identifiers": "Platform setImplicitExit primaryStage primaryStage primaryStage setTitle mainLayoutLoader getResource mainLayoutLoader setResources ResourceBundle getBundle Constant LOCALE rootLayout mainLayoutLoader load rootScene rootLayout primaryStage setScene rootScene primaryStage setResizable controller mainLayoutLoader getController controller setMainGui addToTray primaryStage getIcons add getResource toString primaryStage show e e printStackTrace",
                                      "signature": "    @Override\n    public void start(Stage primaryStage)",
                                      "signature_woname": "    @Override\n    public void (Stage primaryStage)"
                                    },
                                    {
                                      "syntax_pass": true,
                                      "byte_span": [
                                        1970,
                                        4188
                                      ],
                                      "original_string": "    private void addToTray() {\n        // ensure awt is initialized\n        java.awt.Toolkit.getDefaultToolkit();\n\n        // make sure system tray is supported\n        if (!java.awt.SystemTray.isSupported()) {\n            logger.warning(\"No system tray support!\");\n        }\n\n        final java.awt.SystemTray tray = java.awt.SystemTray.getSystemTray();\n        try {\n\n            java.awt.Image image = ImageIO.read(MainGui.class.getResource(\"/resources/image/icon.png\"));\n            trayIcon = new TrayIcon(image);\n            trayIcon.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            primaryStage.show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem openItem = new java.awt.MenuItem(\"Configuration\");\n            openItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem exitItem = new java.awt.MenuItem(\"Exit\");\n            exitItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    controller.closeServer();\n                    Platform.exit();\n                    tray.remove(trayIcon);\n                }\n            });\n\n            PopupMenu popup = new PopupMenu();\n            popup.add(openItem);\n            popup.addSeparator();\n            popup.add(exitItem);\n            trayIcon.setPopupMenu(popup);\n            trayIcon.setToolTip(\"Not Connected\");\n            tray.add(trayIcon);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (AWTException e) {\n            e.printStackTrace();\n        }\n    }",
                                      "docstring": "",
                                      "attributes": {
                                        "modifiers": "private",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "private"
                                        ],
                                        "comments": [],
                                        "return_type": "void",
                                        "classes": []
                                      },
                                      "name": "addToTray",
                                      "body": "                             {\n        // ensure awt is initialized\n        java.awt.Toolkit.getDefaultToolkit();\n\n        // make sure system tray is supported\n        if (!java.awt.SystemTray.isSupported()) {\n            logger.warning(\"No system tray support!\");\n        }\n\n        final java.awt.SystemTray tray = java.awt.SystemTray.getSystemTray();\n        try {\n\n            java.awt.Image image = ImageIO.read(MainGui.class.getResource(\"/resources/image/icon.png\"));\n            trayIcon = new TrayIcon(image);\n            trayIcon.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            primaryStage.show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem openItem = new java.awt.MenuItem(\"Configuration\");\n            openItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem exitItem = new java.awt.MenuItem(\"Exit\");\n            exitItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    controller.closeServer();\n                    Platform.exit();\n                    tray.remove(trayIcon);\n                }\n            });\n\n            PopupMenu popup = new PopupMenu();\n            popup.add(openItem);\n            popup.addSeparator();\n            popup.add(exitItem);\n            trayIcon.setPopupMenu(popup);\n            trayIcon.setToolTip(\"Not Connected\");\n            tray.add(trayIcon);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (AWTException e) {\n            e.printStackTrace();\n        }\n    }",
                                      "identifiers": "java awt Toolkit getDefaultToolkit java awt SystemTray isSupported logger warning tray java awt SystemTray getSystemTray image ImageIO read getResource trayIcon image trayIcon addActionListener Override actionPerformed e Platform runLater Override run primaryStage show openItem openItem addActionListener Override actionPerformed e Platform runLater Override run show exitItem exitItem addActionListener Override actionPerformed e controller closeServer Platform exit tray remove trayIcon popup popup add openItem popup addSeparator popup add exitItem trayIcon setPopupMenu popup trayIcon setToolTip tray add trayIcon e e printStackTrace e e printStackTrace",
                                      "signature": "    private void addToTray()",
                                      "signature_woname": "    private void ()"
                                    },
                                    {
                                      "syntax_pass": true,
                                      "byte_span": [
                                        4194,
                                        4249
                                      ],
                                      "original_string": "    public void show() {\n        primaryStage.show();\n    }",
                                      "docstring": "",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "return_type": "void",
                                        "classes": []
                                      },
                                      "name": "show",
                                      "body": "                       {\n        primaryStage.show();\n    }",
                                      "identifiers": "primaryStage show",
                                      "signature": "    public void show()",
                                      "signature_woname": "    public void ()"
                                    },
                                    {
                                      "syntax_pass": true,
                                      "byte_span": [
                                        4255,
                                        4310
                                      ],
                                      "original_string": "    public void hide() {\n        primaryStage.hide();\n    }",
                                      "docstring": "",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "return_type": "void",
                                        "classes": []
                                      },
                                      "name": "hide",
                                      "body": "                       {\n        primaryStage.hide();\n    }",
                                      "identifiers": "primaryStage hide",
                                      "signature": "    public void hide()",
                                      "signature_woname": "    public void ()"
                                    },
                                    {
                                      "syntax_pass": true,
                                      "byte_span": [
                                        4316,
                                        4446
                                      ],
                                      "original_string": "    public void setTooltip(String message) {\n        if (trayIcon != null) {\n            trayIcon.setToolTip(message);\n        }\n    }",
                                      "docstring": "",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "return_type": "void",
                                        "classes": []
                                      },
                                      "name": "setTooltip",
                                      "body": "                                           {\n        if (trayIcon != null) {\n            trayIcon.setToolTip(message);\n        }\n    }",
                                      "identifiers": "trayIcon trayIcon setToolTip message",
                                      "signature": "    public void setTooltip(String message)",
                                      "signature_woname": "    public void (String message)"
                                    },
                                    {
                                      "syntax_pass": true,
                                      "byte_span": [
                                        4452,
                                        4660
                                      ],
                                      "original_string": "    public void showNotification(String message) {\n        trayIcon.displayMessage(\n                \"shadowsocks-java\",\n                message,\n                java.awt.TrayIcon.MessageType.INFO\n        );\n    }",
                                      "docstring": "",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "return_type": "void",
                                        "classes": []
                                      },
                                      "name": "showNotification",
                                      "body": "                                                 {\n        trayIcon.displayMessage(\n                \"shadowsocks-java\",\n                message,\n                java.awt.TrayIcon.MessageType.INFO\n        );\n    }",
                                      "identifiers": "trayIcon displayMessage message java awt TrayIcon MessageType INFO",
                                      "signature": "    public void showNotification(String message)",
                                      "signature_woname": "    public void (String message)"
                                    }
                                  ]
                                }
                              ]
                            },
                            "imports": [
                              {
                                "original_string": "public class UTF8Control extends ResourceBundle.Control {\n    public ResourceBundle newBundle\n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)\n            throws IllegalAccessException, InstantiationException, IOException\n    {\n        // below is the original implementation\n        String bundleName = toBundleName(baseName, locale);\n        String resourceName = toResourceName(bundleName, \"properties\");\n        ResourceBundle bundle = null;\n        InputStream stream = null;\n        if (reload) {\n            URL url = loader.getResource(resourceName);\n            if (url != null) {\n                URLConnection connection = url.openConnection();\n                if (connection != null) {\n                    connection.setUseCaches(false);\n                    stream = connection.getInputStream();\n                }\n            }\n        } else {\n            stream = loader.getResourceAsStream(resourceName);\n        }\n\n        if (stream != null) {\n            try {\n                // load string use UTF-8 encoding\n                bundle = new PropertyResourceBundle(new InputStreamReader(stream, \"UTF-8\"));\n            } finally {\n                stream.close();\n            }\n        }\n        return bundle;\n    }\n}",
                                "definition": "public class UTF8Control extends ResourceBundle.Control",
                                "byte_span": [
                                  266,
                                  1544
                                ],
                                "start_point": [
                                  11,
                                  0
                                ],
                                "end_point": [
                                  44,
                                  1
                                ],
                                "class_docstring": "",
                                "name": "UTF8Control",
                                "attributes": {
                                  "modifiers": "public",
                                  "marker_annotations": [],
                                  "non_marker_annotations": [
                                    "public"
                                  ],
                                  "comments": [],
                                  "fields": [],
                                  "classes": []
                                },
                                "syntax_pass": true,
                                "methods": [
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      328,
                                      1542
                                    ],
                                    "original_string": "    public ResourceBundle newBundle\n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)\n            throws IllegalAccessException, InstantiationException, IOException\n    {\n        // below is the original implementation\n        String bundleName = toBundleName(baseName, locale);\n        String resourceName = toResourceName(bundleName, \"properties\");\n        ResourceBundle bundle = null;\n        InputStream stream = null;\n        if (reload) {\n            URL url = loader.getResource(resourceName);\n            if (url != null) {\n                URLConnection connection = url.openConnection();\n                if (connection != null) {\n                    connection.setUseCaches(false);\n                    stream = connection.getInputStream();\n                }\n            }\n        } else {\n            stream = loader.getResourceAsStream(resourceName);\n        }\n\n        if (stream != null) {\n            try {\n                // load string use UTF-8 encoding\n                bundle = new PropertyResourceBundle(new InputStreamReader(stream, \"UTF-8\"));\n            } finally {\n                stream.close();\n            }\n        }\n        return bundle;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "ResourceBundle",
                                      "classes": []
                                    },
                                    "name": "newBundle",
                                    "body": "    {\n        // below is the original implementation\n        String bundleName = toBundleName(baseName, locale);\n        String resourceName = toResourceName(bundleName, \"properties\");\n        ResourceBundle bundle = null;\n        InputStream stream = null;\n        if (reload) {\n            URL url = loader.getResource(resourceName);\n            if (url != null) {\n                URLConnection connection = url.openConnection();\n                if (connection != null) {\n                    connection.setUseCaches(false);\n                    stream = connection.getInputStream();\n                }\n            }\n        } else {\n            stream = loader.getResourceAsStream(resourceName);\n        }\n\n        if (stream != null) {\n            try {\n                // load string use UTF-8 encoding\n                bundle = new PropertyResourceBundle(new InputStreamReader(stream, \"UTF-8\"));\n            } finally {\n                stream.close();\n            }\n        }\n        return bundle;\n    }",
                                    "identifiers": "bundleName toBundleName baseName locale resourceName toResourceName bundleName bundle stream reload url loader getResource resourceName url connection url openConnection connection connection setUseCaches stream connection getInputStream stream loader getResourceAsStream resourceName stream bundle stream stream close bundle",
                                    "signature": "    public ResourceBundle newBundle\n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)",
                                    "signature_woname": "    public ResourceBundle \n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)"
                                  }
                                ]
                              },
                              {
                                "original_string": "public class MainLayoutController {\n    @FXML\n    private TextField txtServerIP;\n    @FXML\n    private TextField txtServerPort;\n    @FXML\n    private ComboBox cboCipher;\n    @FXML\n    private TextField txtPassword;\n    @FXML\n    private TextField txtLocalPort;\n    @FXML\n    private ComboBox cboProxyType;\n    @FXML\n    private Button btnStart;\n    @FXML\n    private Button btnStop;\n    @FXML\n    private Button btnLog;\n    @FXML\n    private Button btnClose;\n\n    private Logger logger = Logger.getLogger(MainLayoutController.class.getName());\n    private MainGui gui;\n    private IServer server;\n    private Stage logStage;\n    private Config config;\n\n    @FXML\n    private void initialize() {\n        // set cipher options\n        ObservableList<String> ciphers = FXCollections.observableArrayList();\n        ciphers.addAll(CryptFactory.getSupportedCiphers());\n        cboCipher.setItems(ciphers);\n\n        // set proxy options\n        ObservableList<IProxy.TYPE> proxyTypes = FXCollections.observableArrayList();\n        proxyTypes.addAll(ProxyFactory.getSupportedProxyTypes());\n        cboProxyType.setItems(proxyTypes);\n\n        // prepare configuration\n        config = new Config();\n        config.loadFromJson(Util.getFileContent(Constant.CONF_FILE));\n        txtServerIP.setText(config.getRemoteIpAddress());\n        txtServerPort.setText(String.valueOf(config.getRemotePort()));\n        txtLocalPort.setText(String.valueOf(config.getLocalPort()));\n        txtPassword.setText(config.getPassword());\n        cboCipher.setValue(config.getMethod());\n        cboProxyType.setValue(config.getProxyType());\n\n        // prepare log window\n        Stage stage = new Stage();\n        try {\n            FXMLLoader logLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/LogLayout.fxml\"));\n            logLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane logLayout = logLayoutLoader.load();\n            Scene logScene = new Scene(logLayout);\n            stage.setTitle(\"Log\");\n            stage.setScene(logScene);\n            stage.setResizable(false);\n            stage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n\n            LogLayoutController controller = logLayoutLoader.getController();\n            controller.setStage(stage);\n            logStage = stage;\n        } catch (IOException e) {\n            logger.warning(\"Unable to load ICON: \" + e.toString());\n        }\n\n        btnStop.setDisable(true);\n    }\n\n    @FXML\n    private void handleStart() {\n        boolean isValidated = false;\n        do {\n            if (!txtServerIP.getText().matches(\"[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid IP address\", Alert.AlertType.ERROR);\n                break;\n            }\n            String ip = txtServerIP.getText();\n            if (!txtServerPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int port = Integer.parseInt(txtServerPort.getText());\n\n            String method = (String) cboCipher.getValue();\n            if (txtPassword.getText().length() == 0) {\n                showAlert(Constant.PROG_NAME, \"Please specified password\", Alert.AlertType.ERROR);\n                break;\n            }\n            String password = txtPassword.getText();\n            IProxy.TYPE type = (IProxy.TYPE) cboProxyType.getValue();\n            if (!txtLocalPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int localPort = Integer.parseInt(txtLocalPort.getText());\n\n            // create config\n            config.setRemoteIpAddress(ip);\n            config.setRemotePort(port);\n            config.setLocalIpAddress(\"127.0.0.1\");\n            config.setLocalPort(localPort);\n            config.setMethod(method);\n            config.setPassword(password);\n            config.setProxyType(type);\n            Util.saveFile(Constant.CONF_FILE, config.saveToJson());\n\n            isValidated = true;\n        } while (false);\n\n        if (!isValidated)\n            return;\n\n        // start start\n        try {\n            server = new NioLocalServer(config);\n            Thread t = new Thread(server);\n            t.setDaemon(true);\n            t.start();\n            String message = String.format(\"(Connected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.setTooltip(message);\n            gui.showNotification(message);\n        } catch (IOException | InvalidAlgorithmParameterException e) {\n            logger.warning(\"Unable to start server: \" + e.toString());\n        }\n        btnStop.setDisable(false);\n        btnStart.setDisable(true);\n    }\n\n    @FXML\n    private void handleStop() {\n        if (server != null) {\n            server.close();\n            String message = String.format(\"(Disconnected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.showNotification(message);\n            gui.setTooltip(\"Not Connected\");\n        }\n\n        btnStop.setDisable(true);\n        btnStart.setDisable(false);\n    }\n\n    @FXML\n    private void handleLog() {\n        logStage.show();\n    }\n\n    @FXML\n    private void handleClose() {\n        gui.hide();\n    }\n\n    public void setMainGui(MainGui gui) {\n        this.gui = gui;\n    }\n\n    public void closeServer() {\n        handleStop();\n    }\n\n    private boolean validationInput(String pattern, String text) {\n        return false;\n    }\n\n    private void showAlert(String title, String message, Alert.AlertType type) {\n        Alert a = new Alert(type);\n        a.setTitle(title);\n        a.setHeaderText(type.name());\n        a.setResizable(false);\n        a.setContentText(message);\n        a.showAndWait();\n    }\n}",
                                "definition": "public class MainLayoutController",
                                "byte_span": [
                                  795,
                                  6779
                                ],
                                "start_point": [
                                  28,
                                  0
                                ],
                                "end_point": [
                                  203,
                                  1
                                ],
                                "class_docstring": "",
                                "name": "MainLayoutController",
                                "attributes": {
                                  "modifiers": "public",
                                  "marker_annotations": [],
                                  "non_marker_annotations": [
                                    "public"
                                  ],
                                  "comments": [],
                                  "fields": [
                                    {
                                      "attribute_expression": "    @FXML\n    private TextField txtServerIP;",
                                      "docstring": "",
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "TextField",
                                      "name": "txtServerIP",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    @FXML\n    private TextField txtServerPort;",
                                      "docstring": "",
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "TextField",
                                      "name": "txtServerPort",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    @FXML\n    private ComboBox cboCipher;",
                                      "docstring": "",
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "ComboBox",
                                      "name": "cboCipher",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    @FXML\n    private TextField txtPassword;",
                                      "docstring": "",
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "TextField",
                                      "name": "txtPassword",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    @FXML\n    private TextField txtLocalPort;",
                                      "docstring": "",
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "TextField",
                                      "name": "txtLocalPort",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    @FXML\n    private ComboBox cboProxyType;",
                                      "docstring": "",
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "ComboBox",
                                      "name": "cboProxyType",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    @FXML\n    private Button btnStart;",
                                      "docstring": "",
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "Button",
                                      "name": "btnStart",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    @FXML\n    private Button btnStop;",
                                      "docstring": "",
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "Button",
                                      "name": "btnStop",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    @FXML\n    private Button btnLog;",
                                      "docstring": "",
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "Button",
                                      "name": "btnLog",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    @FXML\n    private Button btnClose;",
                                      "docstring": "",
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "Button",
                                      "name": "btnClose",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private Logger logger = Logger.getLogger(MainLayoutController.class.getName());",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "Logger",
                                      "name": "logger = Logger.getLogger(MainLayoutController.class.getName())",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private MainGui gui;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "MainGui",
                                      "name": "gui",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private IServer server;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "IServer",
                                      "name": "server",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private Stage logStage;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "Stage",
                                      "name": "logStage",
                                      "syntax_pass": true
                                    },
                                    {
                                      "attribute_expression": "    private Config config;",
                                      "docstring": "",
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "type": "Config",
                                      "name": "config",
                                      "syntax_pass": true
                                    }
                                  ],
                                  "classes": []
                                },
                                "syntax_pass": true,
                                "methods": [
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      1452,
                                      3358
                                    ],
                                    "original_string": "    @FXML\n    private void initialize() {\n        // set cipher options\n        ObservableList<String> ciphers = FXCollections.observableArrayList();\n        ciphers.addAll(CryptFactory.getSupportedCiphers());\n        cboCipher.setItems(ciphers);\n\n        // set proxy options\n        ObservableList<IProxy.TYPE> proxyTypes = FXCollections.observableArrayList();\n        proxyTypes.addAll(ProxyFactory.getSupportedProxyTypes());\n        cboProxyType.setItems(proxyTypes);\n\n        // prepare configuration\n        config = new Config();\n        config.loadFromJson(Util.getFileContent(Constant.CONF_FILE));\n        txtServerIP.setText(config.getRemoteIpAddress());\n        txtServerPort.setText(String.valueOf(config.getRemotePort()));\n        txtLocalPort.setText(String.valueOf(config.getLocalPort()));\n        txtPassword.setText(config.getPassword());\n        cboCipher.setValue(config.getMethod());\n        cboProxyType.setValue(config.getProxyType());\n\n        // prepare log window\n        Stage stage = new Stage();\n        try {\n            FXMLLoader logLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/LogLayout.fxml\"));\n            logLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane logLayout = logLayoutLoader.load();\n            Scene logScene = new Scene(logLayout);\n            stage.setTitle(\"Log\");\n            stage.setScene(logScene);\n            stage.setResizable(false);\n            stage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n\n            LogLayoutController controller = logLayoutLoader.getController();\n            controller.setStage(stage);\n            logStage = stage;\n        } catch (IOException e) {\n            logger.warning(\"Unable to load ICON: \" + e.toString());\n        }\n\n        btnStop.setDisable(true);\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "initialize",
                                    "body": "                              {\n        // set cipher options\n        ObservableList<String> ciphers = FXCollections.observableArrayList();\n        ciphers.addAll(CryptFactory.getSupportedCiphers());\n        cboCipher.setItems(ciphers);\n\n        // set proxy options\n        ObservableList<IProxy.TYPE> proxyTypes = FXCollections.observableArrayList();\n        proxyTypes.addAll(ProxyFactory.getSupportedProxyTypes());\n        cboProxyType.setItems(proxyTypes);\n\n        // prepare configuration\n        config = new Config();\n        config.loadFromJson(Util.getFileContent(Constant.CONF_FILE));\n        txtServerIP.setText(config.getRemoteIpAddress());\n        txtServerPort.setText(String.valueOf(config.getRemotePort()));\n        txtLocalPort.setText(String.valueOf(config.getLocalPort()));\n        txtPassword.setText(config.getPassword());\n        cboCipher.setValue(config.getMethod());\n        cboProxyType.setValue(config.getProxyType());\n\n        // prepare log window\n        Stage stage = new Stage();\n        try {\n            FXMLLoader logLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/LogLayout.fxml\"));\n            logLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane logLayout = logLayoutLoader.load();\n            Scene logScene = new Scene(logLayout);\n            stage.setTitle(\"Log\");\n            stage.setScene(logScene);\n            stage.setResizable(false);\n            stage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n\n            LogLayoutController controller = logLayoutLoader.getController();\n            controller.setStage(stage);\n            logStage = stage;\n        } catch (IOException e) {\n            logger.warning(\"Unable to load ICON: \" + e.toString());\n        }\n\n        btnStop.setDisable(true);\n    }",
                                    "identifiers": "ciphers FXCollections observableArrayList ciphers addAll CryptFactory getSupportedCiphers cboCipher setItems ciphers proxyTypes FXCollections observableArrayList proxyTypes addAll ProxyFactory getSupportedProxyTypes cboProxyType setItems proxyTypes config config loadFromJson Util getFileContent Constant CONF_FILE txtServerIP setText config getRemoteIpAddress txtServerPort setText String valueOf config getRemotePort txtLocalPort setText String valueOf config getLocalPort txtPassword setText config getPassword cboCipher setValue config getMethod cboProxyType setValue config getProxyType stage logLayoutLoader getResource logLayoutLoader setResources ResourceBundle getBundle Constant LOCALE logLayout logLayoutLoader load logScene logLayout stage setTitle stage setScene logScene stage setResizable stage getIcons add getResource toString controller logLayoutLoader getController controller setStage stage logStage stage e logger warning e toString btnStop setDisable",
                                    "signature": "    @FXML\n    private void initialize()",
                                    "signature_woname": "    @FXML\n    private void ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      3364,
                                      5721
                                    ],
                                    "original_string": "    @FXML\n    private void handleStart() {\n        boolean isValidated = false;\n        do {\n            if (!txtServerIP.getText().matches(\"[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid IP address\", Alert.AlertType.ERROR);\n                break;\n            }\n            String ip = txtServerIP.getText();\n            if (!txtServerPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int port = Integer.parseInt(txtServerPort.getText());\n\n            String method = (String) cboCipher.getValue();\n            if (txtPassword.getText().length() == 0) {\n                showAlert(Constant.PROG_NAME, \"Please specified password\", Alert.AlertType.ERROR);\n                break;\n            }\n            String password = txtPassword.getText();\n            IProxy.TYPE type = (IProxy.TYPE) cboProxyType.getValue();\n            if (!txtLocalPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int localPort = Integer.parseInt(txtLocalPort.getText());\n\n            // create config\n            config.setRemoteIpAddress(ip);\n            config.setRemotePort(port);\n            config.setLocalIpAddress(\"127.0.0.1\");\n            config.setLocalPort(localPort);\n            config.setMethod(method);\n            config.setPassword(password);\n            config.setProxyType(type);\n            Util.saveFile(Constant.CONF_FILE, config.saveToJson());\n\n            isValidated = true;\n        } while (false);\n\n        if (!isValidated)\n            return;\n\n        // start start\n        try {\n            server = new NioLocalServer(config);\n            Thread t = new Thread(server);\n            t.setDaemon(true);\n            t.start();\n            String message = String.format(\"(Connected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.setTooltip(message);\n            gui.showNotification(message);\n        } catch (IOException | InvalidAlgorithmParameterException e) {\n            logger.warning(\"Unable to start server: \" + e.toString());\n        }\n        btnStop.setDisable(false);\n        btnStart.setDisable(true);\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "handleStart",
                                    "body": "                               {\n        boolean isValidated = false;\n        do {\n            if (!txtServerIP.getText().matches(\"[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid IP address\", Alert.AlertType.ERROR);\n                break;\n            }\n            String ip = txtServerIP.getText();\n            if (!txtServerPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int port = Integer.parseInt(txtServerPort.getText());\n\n            String method = (String) cboCipher.getValue();\n            if (txtPassword.getText().length() == 0) {\n                showAlert(Constant.PROG_NAME, \"Please specified password\", Alert.AlertType.ERROR);\n                break;\n            }\n            String password = txtPassword.getText();\n            IProxy.TYPE type = (IProxy.TYPE) cboProxyType.getValue();\n            if (!txtLocalPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int localPort = Integer.parseInt(txtLocalPort.getText());\n\n            // create config\n            config.setRemoteIpAddress(ip);\n            config.setRemotePort(port);\n            config.setLocalIpAddress(\"127.0.0.1\");\n            config.setLocalPort(localPort);\n            config.setMethod(method);\n            config.setPassword(password);\n            config.setProxyType(type);\n            Util.saveFile(Constant.CONF_FILE, config.saveToJson());\n\n            isValidated = true;\n        } while (false);\n\n        if (!isValidated)\n            return;\n\n        // start start\n        try {\n            server = new NioLocalServer(config);\n            Thread t = new Thread(server);\n            t.setDaemon(true);\n            t.start();\n            String message = String.format(\"(Connected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.setTooltip(message);\n            gui.showNotification(message);\n        } catch (IOException | InvalidAlgorithmParameterException e) {\n            logger.warning(\"Unable to start server: \" + e.toString());\n        }\n        btnStop.setDisable(false);\n        btnStart.setDisable(true);\n    }",
                                    "identifiers": "isValidated txtServerIP getText matches showAlert Constant PROG_NAME Alert AlertType ERROR ip txtServerIP getText txtServerPort getText matches showAlert Constant PROG_NAME Alert AlertType ERROR port Integer parseInt txtServerPort getText method cboCipher getValue txtPassword getText length showAlert Constant PROG_NAME Alert AlertType ERROR password txtPassword getText type cboProxyType getValue txtLocalPort getText matches showAlert Constant PROG_NAME Alert AlertType ERROR localPort Integer parseInt txtLocalPort getText config setRemoteIpAddress ip config setRemotePort port config setLocalIpAddress config setLocalPort localPort config setMethod method config setPassword password config setProxyType type Util saveFile Constant CONF_FILE config saveToJson isValidated isValidated server config t server t setDaemon t start message String format config getRemoteIpAddress config getRemotePort gui setTooltip message gui showNotification message e logger warning e toString btnStop setDisable btnStart setDisable",
                                    "signature": "    @FXML\n    private void handleStart()",
                                    "signature_woname": "    @FXML\n    private void ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      5727,
                                      6125
                                    ],
                                    "original_string": "    @FXML\n    private void handleStop() {\n        if (server != null) {\n            server.close();\n            String message = String.format(\"(Disconnected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.showNotification(message);\n            gui.setTooltip(\"Not Connected\");\n        }\n\n        btnStop.setDisable(true);\n        btnStart.setDisable(false);\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "handleStop",
                                    "body": "                              {\n        if (server != null) {\n            server.close();\n            String message = String.format(\"(Disconnected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.showNotification(message);\n            gui.setTooltip(\"Not Connected\");\n        }\n\n        btnStop.setDisable(true);\n        btnStart.setDisable(false);\n    }",
                                    "identifiers": "server server close message String format config getRemoteIpAddress config getRemotePort gui showNotification message gui setTooltip btnStop setDisable btnStart setDisable",
                                    "signature": "    @FXML\n    private void handleStop()",
                                    "signature_woname": "    @FXML\n    private void ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      6131,
                                      6198
                                    ],
                                    "original_string": "    @FXML\n    private void handleLog() {\n        logStage.show();\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "handleLog",
                                    "body": "                             {\n        logStage.show();\n    }",
                                    "identifiers": "logStage show",
                                    "signature": "    @FXML\n    private void handleLog()",
                                    "signature_woname": "    @FXML\n    private void ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      6204,
                                      6268
                                    ],
                                    "original_string": "    @FXML\n    private void handleClose() {\n        gui.hide();\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "@FXML\n    private",
                                      "marker_annotations": [
                                        "@FXML"
                                      ],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "handleClose",
                                    "body": "                               {\n        gui.hide();\n    }",
                                    "identifiers": "gui hide",
                                    "signature": "    @FXML\n    private void handleClose()",
                                    "signature_woname": "    @FXML\n    private void ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      6274,
                                      6341
                                    ],
                                    "original_string": "    public void setMainGui(MainGui gui) {\n        this.gui = gui;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "setMainGui",
                                    "body": "                                        {\n        this.gui = gui;\n    }",
                                    "identifiers": "gui gui",
                                    "signature": "    public void setMainGui(MainGui gui)",
                                    "signature_woname": "    public void (MainGui gui)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      6347,
                                      6402
                                    ],
                                    "original_string": "    public void closeServer() {\n        handleStop();\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "closeServer",
                                    "body": "                              {\n        handleStop();\n    }",
                                    "identifiers": "handleStop",
                                    "signature": "    public void closeServer()",
                                    "signature_woname": "    public void ()"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      6408,
                                      6498
                                    ],
                                    "original_string": "    private boolean validationInput(String pattern, String text) {\n        return false;\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "return_type": "boolean",
                                      "classes": []
                                    },
                                    "name": "validationInput",
                                    "body": "                                                                 {\n        return false;\n    }",
                                    "identifiers": "",
                                    "signature": "    private boolean validationInput(String pattern, String text)",
                                    "signature_woname": "    private boolean (String pattern, String text)"
                                  },
                                  {
                                    "syntax_pass": true,
                                    "byte_span": [
                                      6504,
                                      6777
                                    ],
                                    "original_string": "    private void showAlert(String title, String message, Alert.AlertType type) {\n        Alert a = new Alert(type);\n        a.setTitle(title);\n        a.setHeaderText(type.name());\n        a.setResizable(false);\n        a.setContentText(message);\n        a.showAndWait();\n    }",
                                    "docstring": "",
                                    "attributes": {
                                      "modifiers": "private",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "private"
                                      ],
                                      "comments": [],
                                      "return_type": "void",
                                      "classes": []
                                    },
                                    "name": "showAlert",
                                    "body": "                                                                               {\n        Alert a = new Alert(type);\n        a.setTitle(title);\n        a.setHeaderText(type.name());\n        a.setResizable(false);\n        a.setContentText(message);\n        a.showAndWait();\n    }",
                                    "identifiers": "a type a setTitle title a setHeaderText type name a setResizable a setContentText message a showAndWait",
                                    "signature": "    private void showAlert(String title, String message, Alert.AlertType type)",
                                    "signature_woname": "    private void (String title, String message, Alert.AlertType type)"
                                  }
                                ]
                              }
                            ]
                          }
                        ],
                        "subdirs": [
                          {
                            "dir": "ss",
                            "files": [
                              {
                                "name": "CamelliaCrypt.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.ss;\n\nimport org.bouncycastle.crypto.StreamBlockCipher;\nimport org.bouncycastle.crypto.engines.CamelliaEngine;\nimport org.bouncycastle.crypto.modes.CFBBlockCipher;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.ByteArrayOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Camellia cipher implementation\n */\npublic class CamelliaCrypt extends CryptBase {\n\n    public final static String CIPHER_CAMELLIA_128_CFB = \"camellia-128-cfb\";\n    public final static String CIPHER_CAMELLIA_192_CFB = \"camellia-192-cfb\";\n    public final static String CIPHER_CAMELLIA_256_CFB = \"camellia-256-cfb\";\n\n    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_CAMELLIA_128_CFB, CamelliaCrypt.class.getName());\n        ciphers.put(CIPHER_CAMELLIA_192_CFB, CamelliaCrypt.class.getName());\n        ciphers.put(CIPHER_CAMELLIA_256_CFB, CamelliaCrypt.class.getName());\n\n        return ciphers;\n    }\n\n    public CamelliaCrypt(String name, String password) {\n        super(name, password);\n    }\n\n    @Override\n    public int getKeyLength() {\n        if(_name.equals(CIPHER_CAMELLIA_128_CFB)) {\n            return 16;\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_192_CFB)) {\n            return 24;\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_256_CFB)) {\n            return 32;\n        }\n\n        return 0;\n    }\n\n    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        CamelliaEngine engine = new CamelliaEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_CAMELLIA_128_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_192_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_256_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }\n\n    @Override\n    public int getIVLength() {\n        return 16;\n    }\n\n    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }\n\n    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n\n    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.ss;",
                                    "import org.bouncycastle.crypto.StreamBlockCipher;",
                                    "import org.bouncycastle.crypto.engines.CamelliaEngine;",
                                    "import org.bouncycastle.crypto.modes.CFBBlockCipher;",
                                    "import javax.crypto.SecretKey;",
                                    "import javax.crypto.spec.SecretKeySpec;",
                                    "import java.io.ByteArrayOutputStream;",
                                    "import java.security.InvalidAlgorithmParameterException;",
                                    "import java.util.HashMap;",
                                    "import java.util.Map;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class CamelliaCrypt extends CryptBase {\n\n    public final static String CIPHER_CAMELLIA_128_CFB = \"camellia-128-cfb\";\n    public final static String CIPHER_CAMELLIA_192_CFB = \"camellia-192-cfb\";\n    public final static String CIPHER_CAMELLIA_256_CFB = \"camellia-256-cfb\";\n\n    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_CAMELLIA_128_CFB, CamelliaCrypt.class.getName());\n        ciphers.put(CIPHER_CAMELLIA_192_CFB, CamelliaCrypt.class.getName());\n        ciphers.put(CIPHER_CAMELLIA_256_CFB, CamelliaCrypt.class.getName());\n\n        return ciphers;\n    }\n\n    public CamelliaCrypt(String name, String password) {\n        super(name, password);\n    }\n\n    @Override\n    public int getKeyLength() {\n        if(_name.equals(CIPHER_CAMELLIA_128_CFB)) {\n            return 16;\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_192_CFB)) {\n            return 24;\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_256_CFB)) {\n            return 32;\n        }\n\n        return 0;\n    }\n\n    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        CamelliaEngine engine = new CamelliaEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_CAMELLIA_128_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_192_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_256_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }\n\n    @Override\n    public int getIVLength() {\n        return 16;\n    }\n\n    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }\n\n    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n\n    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n}",
                                      "definition": "public class CamelliaCrypt extends CryptBase",
                                      "byte_span": [
                                        1953,
                                        4575
                                      ],
                                      "start_point": [
                                        47,
                                        0
                                      ],
                                      "end_point": [
                                        129,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "CamelliaCrypt",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    public final static String CIPHER_CAMELLIA_128_CFB = \"camellia-128-cfb\";",
                                            "docstring": "",
                                            "modifiers": "public final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "CIPHER_CAMELLIA_128_CFB = \"camellia-128-cfb\"",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    public final static String CIPHER_CAMELLIA_192_CFB = \"camellia-192-cfb\";",
                                            "docstring": "",
                                            "modifiers": "public final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "CIPHER_CAMELLIA_192_CFB = \"camellia-192-cfb\"",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    public final static String CIPHER_CAMELLIA_256_CFB = \"camellia-256-cfb\";",
                                            "docstring": "",
                                            "modifiers": "public final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "CIPHER_CAMELLIA_256_CFB = \"camellia-256-cfb\"",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2237,
                                            2602
                                          ],
                                          "original_string": "    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_CAMELLIA_128_CFB, CamelliaCrypt.class.getName());\n        ciphers.put(CIPHER_CAMELLIA_192_CFB, CamelliaCrypt.class.getName());\n        ciphers.put(CIPHER_CAMELLIA_256_CFB, CamelliaCrypt.class.getName());\n\n        return ciphers;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "Map<String, String>",
                                            "classes": []
                                          },
                                          "name": "getCiphers",
                                          "body": "                                                   {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_CAMELLIA_128_CFB, CamelliaCrypt.class.getName());\n        ciphers.put(CIPHER_CAMELLIA_192_CFB, CamelliaCrypt.class.getName());\n        ciphers.put(CIPHER_CAMELLIA_256_CFB, CamelliaCrypt.class.getName());\n\n        return ciphers;\n    }",
                                          "identifiers": "ciphers ciphers put CIPHER_CAMELLIA_128_CFB getName ciphers put CIPHER_CAMELLIA_192_CFB getName ciphers put CIPHER_CAMELLIA_256_CFB getName ciphers",
                                          "signature": "    public static Map<String, String> getCiphers()",
                                          "signature_woname": "    public static Map<String, String> ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2608,
                                            2697
                                          ],
                                          "original_string": "    public CamelliaCrypt(String name, String password) {\n        super(name, password);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "CamelliaCrypt",
                                          "body": "                                                       {\n        super(name, password);\n    }",
                                          "identifiers": "name password",
                                          "signature": "    public CamelliaCrypt(String name, String password)",
                                          "signature_woname": "    public (String name, String password)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2703,
                                            3036
                                          ],
                                          "original_string": "    @Override\n    public int getKeyLength() {\n        if(_name.equals(CIPHER_CAMELLIA_128_CFB)) {\n            return 16;\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_192_CFB)) {\n            return 24;\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_256_CFB)) {\n            return 32;\n        }\n\n        return 0;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "int",
                                            "classes": []
                                          },
                                          "name": "getKeyLength",
                                          "body": "                              {\n        if(_name.equals(CIPHER_CAMELLIA_128_CFB)) {\n            return 16;\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_192_CFB)) {\n            return 24;\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_256_CFB)) {\n            return 32;\n        }\n\n        return 0;\n    }",
                                          "identifiers": "_name equals CIPHER_CAMELLIA_128_CFB _name equals CIPHER_CAMELLIA_192_CFB _name equals CIPHER_CAMELLIA_256_CFB",
                                          "signature": "    @Override\n    public int getKeyLength()",
                                          "signature_woname": "    @Override\n    public int ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3042,
                                            3770
                                          ],
                                          "original_string": "    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        CamelliaEngine engine = new CamelliaEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_CAMELLIA_128_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_192_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_256_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "StreamBlockCipher",
                                            "classes": []
                                          },
                                          "name": "getCipher",
                                          "body": "                                                                                                         {\n        CamelliaEngine engine = new CamelliaEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_CAMELLIA_128_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_192_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_CAMELLIA_256_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }",
                                          "identifiers": "engine cipher _name equals CIPHER_CAMELLIA_128_CFB cipher engine getIVLength _name equals CIPHER_CAMELLIA_192_CFB cipher engine getIVLength _name equals CIPHER_CAMELLIA_256_CFB cipher engine getIVLength _name cipher",
                                          "signature": "    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted)",
                                          "signature_woname": "    @Override\n    protected StreamBlockCipher (boolean isEncrypted)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3776,
                                            3841
                                          ],
                                          "original_string": "    @Override\n    public int getIVLength() {\n        return 16;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "int",
                                            "classes": []
                                          },
                                          "name": "getIVLength",
                                          "body": "                             {\n        return 16;\n    }",
                                          "identifiers": "",
                                          "signature": "    @Override\n    public int getIVLength()",
                                          "signature_woname": "    @Override\n    public int ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3847,
                                            3959
                                          ],
                                          "original_string": "    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "SecretKey",
                                            "classes": []
                                          },
                                          "name": "getKey",
                                          "body": "                                 {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }",
                                          "identifiers": "_ssKey getEncoded",
                                          "signature": "    @Override\n    protected SecretKey getKey()",
                                          "signature_woname": "    @Override\n    protected SecretKey ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3965,
                                            4266
                                          ],
                                          "original_string": "    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "_encrypt",
                                          "body": "                                                                       {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "identifiers": "noBytesProcessed buffer data length noBytesProcessed encCipher processBytes data data length buffer stream write buffer noBytesProcessed",
                                          "signature": "    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    protected void (byte[] data, ByteArrayOutputStream stream)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4272,
                                            4573
                                          ],
                                          "original_string": "    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "_decrypt",
                                          "body": "                                                                       {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "identifiers": "noBytesProcessed buffer data length noBytesProcessed decCipher processBytes data data length buffer stream write buffer noBytesProcessed",
                                          "signature": "    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    protected void (byte[] data, ByteArrayOutputStream stream)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": []
                              },
                              {
                                "name": "ShadowSocksKey.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.ss;\n\nimport com.stfl.misc.Util;\n\nimport javax.crypto.SecretKey;\nimport java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.util.logging.Logger;\n\n/**\n * Shadowsocks key generator\n */\npublic class ShadowSocksKey implements SecretKey {\n\n    private Logger logger = Logger.getLogger(ShadowSocksKey.class.getName());\n    private final static int KEY_LENGTH = 32;\n    private byte[] _key;\n    private int _length;\n\n    public ShadowSocksKey(String password) {\n        _length = KEY_LENGTH;\n        _key = init(password);\n    }\n\n    public ShadowSocksKey(String password, int length) {\n        // TODO: Invalid key length\n        _length = length;\n        _key = init(password);\n    }\n\n    private byte[] init(String password) {\n        MessageDigest md = null;\n        byte[] keys = new byte[KEY_LENGTH];\n        byte[] temp = null;\n        byte[] hash = null;\n        byte[] passwordBytes = null;\n        int i = 0;\n\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            passwordBytes = password.getBytes(\"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e) {\n            logger.info(\"ShadowSocksKey: Unsupported string encoding\");\n        }\n        catch (Exception e) {\n            logger.info(Util.getErrorMessage(e));\n            return null;\n        }\n\n        while (i < keys.length) {\n            if (i == 0) {\n                hash = md.digest(passwordBytes);\n                temp = new byte[passwordBytes.length+hash.length];\n            }\n            else {\n                System.arraycopy(hash, 0, temp, 0, hash.length);\n                System.arraycopy(passwordBytes, 0, temp, hash.length, passwordBytes.length);\n                hash = md.digest(temp);\n            }\n            System.arraycopy(hash, 0, keys, i, hash.length);\n            i += hash.length;\n        }\n\n        if (_length != KEY_LENGTH) {\n            byte[] keysl = new byte[_length];\n            System.arraycopy(keys, 0, keysl, 0, _length);\n            return keysl;\n        }\n        return keys;\n    }\n\n    @Override\n    public String getAlgorithm() {\n        return \"shadowsocks\";\n    }\n\n    @Override\n    public String getFormat() {\n        return \"RAW\";\n    }\n\n    @Override\n    public byte[] getEncoded() {\n        return _key;\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.ss;",
                                    "import com.stfl.misc.Util;",
                                    "import javax.crypto.SecretKey;",
                                    "import java.io.UnsupportedEncodingException;",
                                    "import java.security.MessageDigest;",
                                    "import java.util.logging.Logger;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class ShadowSocksKey implements SecretKey {\n\n    private Logger logger = Logger.getLogger(ShadowSocksKey.class.getName());\n    private final static int KEY_LENGTH = 32;\n    private byte[] _key;\n    private int _length;\n\n    public ShadowSocksKey(String password) {\n        _length = KEY_LENGTH;\n        _key = init(password);\n    }\n\n    public ShadowSocksKey(String password, int length) {\n        // TODO: Invalid key length\n        _length = length;\n        _key = init(password);\n    }\n\n    private byte[] init(String password) {\n        MessageDigest md = null;\n        byte[] keys = new byte[KEY_LENGTH];\n        byte[] temp = null;\n        byte[] hash = null;\n        byte[] passwordBytes = null;\n        int i = 0;\n\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            passwordBytes = password.getBytes(\"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e) {\n            logger.info(\"ShadowSocksKey: Unsupported string encoding\");\n        }\n        catch (Exception e) {\n            logger.info(Util.getErrorMessage(e));\n            return null;\n        }\n\n        while (i < keys.length) {\n            if (i == 0) {\n                hash = md.digest(passwordBytes);\n                temp = new byte[passwordBytes.length+hash.length];\n            }\n            else {\n                System.arraycopy(hash, 0, temp, 0, hash.length);\n                System.arraycopy(passwordBytes, 0, temp, hash.length, passwordBytes.length);\n                hash = md.digest(temp);\n            }\n            System.arraycopy(hash, 0, keys, i, hash.length);\n            i += hash.length;\n        }\n\n        if (_length != KEY_LENGTH) {\n            byte[] keysl = new byte[_length];\n            System.arraycopy(keys, 0, keysl, 0, _length);\n            return keysl;\n        }\n        return keys;\n    }\n\n    @Override\n    public String getAlgorithm() {\n        return \"shadowsocks\";\n    }\n\n    @Override\n    public String getFormat() {\n        return \"RAW\";\n    }\n\n    @Override\n    public byte[] getEncoded() {\n        return _key;\n    }\n}",
                                      "definition": "public class ShadowSocksKey implements SecretKey",
                                      "byte_span": [
                                        1748,
                                        3820
                                      ],
                                      "start_point": [
                                        43,
                                        0
                                      ],
                                      "end_point": [
                                        117,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "ShadowSocksKey",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    private Logger logger = Logger.getLogger(ShadowSocksKey.class.getName());",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Logger",
                                            "name": "logger = Logger.getLogger(ShadowSocksKey.class.getName())",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private final static int KEY_LENGTH = 32;",
                                            "docstring": "",
                                            "modifiers": "private final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "int",
                                            "name": "KEY_LENGTH = 32",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private byte[] _key;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "byte[]",
                                            "name": "_key",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private int _length;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "int",
                                            "name": "_length",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            1979,
                                            2086
                                          ],
                                          "original_string": "    public ShadowSocksKey(String password) {\n        _length = KEY_LENGTH;\n        _key = init(password);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "ShadowSocksKey",
                                          "body": "                                           {\n        _length = KEY_LENGTH;\n        _key = init(password);\n    }",
                                          "identifiers": "_length KEY_LENGTH _key init password",
                                          "signature": "    public ShadowSocksKey(String password)",
                                          "signature_woname": "    public (String password)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2092,
                                            2243
                                          ],
                                          "original_string": "    public ShadowSocksKey(String password, int length) {\n        // TODO: Invalid key length\n        _length = length;\n        _key = init(password);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "ShadowSocksKey",
                                          "body": "                                                       {\n        // TODO: Invalid key length\n        _length = length;\n        _key = init(password);\n    }",
                                          "identifiers": "_length length _key init password",
                                          "signature": "    public ShadowSocksKey(String password, int length)",
                                          "signature_woname": "    public (String password, int length)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2249,
                                            3582
                                          ],
                                          "original_string": "    private byte[] init(String password) {\n        MessageDigest md = null;\n        byte[] keys = new byte[KEY_LENGTH];\n        byte[] temp = null;\n        byte[] hash = null;\n        byte[] passwordBytes = null;\n        int i = 0;\n\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            passwordBytes = password.getBytes(\"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e) {\n            logger.info(\"ShadowSocksKey: Unsupported string encoding\");\n        }\n        catch (Exception e) {\n            logger.info(Util.getErrorMessage(e));\n            return null;\n        }\n\n        while (i < keys.length) {\n            if (i == 0) {\n                hash = md.digest(passwordBytes);\n                temp = new byte[passwordBytes.length+hash.length];\n            }\n            else {\n                System.arraycopy(hash, 0, temp, 0, hash.length);\n                System.arraycopy(passwordBytes, 0, temp, hash.length, passwordBytes.length);\n                hash = md.digest(temp);\n            }\n            System.arraycopy(hash, 0, keys, i, hash.length);\n            i += hash.length;\n        }\n\n        if (_length != KEY_LENGTH) {\n            byte[] keysl = new byte[_length];\n            System.arraycopy(keys, 0, keysl, 0, _length);\n            return keysl;\n        }\n        return keys;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "byte[]",
                                            "classes": []
                                          },
                                          "name": "init",
                                          "body": "                                         {\n        MessageDigest md = null;\n        byte[] keys = new byte[KEY_LENGTH];\n        byte[] temp = null;\n        byte[] hash = null;\n        byte[] passwordBytes = null;\n        int i = 0;\n\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            passwordBytes = password.getBytes(\"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e) {\n            logger.info(\"ShadowSocksKey: Unsupported string encoding\");\n        }\n        catch (Exception e) {\n            logger.info(Util.getErrorMessage(e));\n            return null;\n        }\n\n        while (i < keys.length) {\n            if (i == 0) {\n                hash = md.digest(passwordBytes);\n                temp = new byte[passwordBytes.length+hash.length];\n            }\n            else {\n                System.arraycopy(hash, 0, temp, 0, hash.length);\n                System.arraycopy(passwordBytes, 0, temp, hash.length, passwordBytes.length);\n                hash = md.digest(temp);\n            }\n            System.arraycopy(hash, 0, keys, i, hash.length);\n            i += hash.length;\n        }\n\n        if (_length != KEY_LENGTH) {\n            byte[] keysl = new byte[_length];\n            System.arraycopy(keys, 0, keysl, 0, _length);\n            return keysl;\n        }\n        return keys;\n    }",
                                          "identifiers": "md keys KEY_LENGTH temp hash passwordBytes i md MessageDigest getInstance passwordBytes password getBytes e logger info e logger info Util getErrorMessage e i keys length i hash md digest passwordBytes temp passwordBytes length hash length System arraycopy hash temp hash length System arraycopy passwordBytes temp hash length passwordBytes length hash md digest temp System arraycopy hash keys i hash length i hash length _length KEY_LENGTH keysl _length System arraycopy keys keysl _length keysl keys",
                                          "signature": "    private byte[] init(String password)",
                                          "signature_woname": "    private byte[] (String password)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3588,
                                            3668
                                          ],
                                          "original_string": "    @Override\n    public String getAlgorithm() {\n        return \"shadowsocks\";\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "getAlgorithm",
                                          "body": "                                 {\n        return \"shadowsocks\";\n    }",
                                          "identifiers": "",
                                          "signature": "    @Override\n    public String getAlgorithm()",
                                          "signature_woname": "    @Override\n    public String ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3674,
                                            3743
                                          ],
                                          "original_string": "    @Override\n    public String getFormat() {\n        return \"RAW\";\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "getFormat",
                                          "body": "                              {\n        return \"RAW\";\n    }",
                                          "identifiers": "",
                                          "signature": "    @Override\n    public String getFormat()",
                                          "signature_woname": "    @Override\n    public String ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3749,
                                            3818
                                          ],
                                          "original_string": "    @Override\n    public byte[] getEncoded() {\n        return _key;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "byte[]",
                                            "classes": []
                                          },
                                          "name": "getEncoded",
                                          "body": "                               {\n        return _key;\n    }",
                                          "identifiers": "_key",
                                          "signature": "    @Override\n    public byte[] getEncoded()",
                                          "signature_woname": "    @Override\n    public byte[] ()"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": [
                                  {
                                    "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                    "definition": "public class Util",
                                    "byte_span": [
                                      1779,
                                      7484
                                    ],
                                    "start_point": [
                                      45,
                                      0
                                    ],
                                    "end_point": [
                                      219,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Util",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          1803,
                                          2018
                                        ],
                                        "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "dumpBytes",
                                        "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                        "identifiers": "sb a length b a sb append String format b sb toString",
                                        "signature": "    public static String dumpBytes(byte[] a)",
                                        "signature_woname": "    public static String (byte[] a)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2024,
                                          2180
                                        ],
                                        "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "byte[]",
                                          "classes": []
                                        },
                                        "name": "randomBytes",
                                        "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                        "identifiers": "bytes size nextBytes bytes bytes",
                                        "signature": "    public static byte[] randomBytes(int size)",
                                        "signature_woname": "    public static byte[] (int size)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2186,
                                          2412
                                        ],
                                        "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getErrorMessage",
                                        "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                        "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                        "signature": "    public static String getErrorMessage(Throwable e)",
                                        "signature_woname": "    public static String (Throwable e)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2418,
                                          4165
                                        ],
                                        "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "prettyPrintJson",
                                        "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                        "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                        "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                        "signature_woname": "    public static String (JSONObject jObj)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4171,
                                          5829
                                        ],
                                        "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getRequestedHostInfo",
                                        "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                        "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                        "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                        "signature_woname": "    public static String (byte[] data)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          5835,
                                          6128
                                        ],
                                        "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "bytesToString",
                                        "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                        "identifiers": "str str data start length e e printStackTrace str",
                                        "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                        "signature_woname": "    public static String (byte[] data, int start, int length)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6134,
                                          6648
                                        ],
                                        "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "byte[]",
                                          "classes": []
                                        },
                                        "name": "composeSSHeader",
                                        "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                        "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                        "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                        "signature_woname": "    public static byte[] (String host, int port)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6654,
                                          6969
                                        ],
                                        "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "saveFile",
                                        "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                        "identifiers": "writer writer fn writer println content writer close e",
                                        "signature": "    public static boolean saveFile(String fn, String content)",
                                        "signature_woname": "    public static boolean (String fn, String content)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6975,
                                          7262
                                        ],
                                        "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getFileContent",
                                        "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                        "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                        "signature": "    public static String getFileContent(String fn)",
                                        "signature_woname": "    public static String (String fn)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7268,
                                          7357
                                        ],
                                        "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "short",
                                          "classes": []
                                        },
                                        "name": "byteToUnsignedByte",
                                        "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                        "identifiers": "b",
                                        "signature": "    private static short byteToUnsignedByte(byte b)",
                                        "signature_woname": "    private static short (byte b)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7363,
                                          7482
                                        ],
                                        "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getPort",
                                        "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                        "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                        "signature": "    private static int getPort(byte b, byte b1)",
                                        "signature_woname": "    private static int (byte b, byte b1)"
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "name": "BlowFishCrypt.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.ss;\n\nimport org.bouncycastle.crypto.StreamBlockCipher;\nimport org.bouncycastle.crypto.engines.BlowfishEngine;\nimport org.bouncycastle.crypto.modes.CFBBlockCipher;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.ByteArrayOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Blow fish cipher implementation\n */\npublic class BlowFishCrypt extends CryptBase {\n\n    public final static String CIPHER_BLOWFISH_CFB = \"bf-cfb\";\n\n    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_BLOWFISH_CFB, BlowFishCrypt.class.getName());\n\n        return ciphers;\n    }\n\n    public BlowFishCrypt(String name, String password) {\n        super(name, password);\n    }\n\n    @Override\n    public int getKeyLength() {\n        return 16;\n    }\n\n    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        BlowfishEngine engine = new BlowfishEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_BLOWFISH_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }\n\n    @Override\n    public int getIVLength() {\n        return 8;\n    }\n\n    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }\n\n    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n\n    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.ss;",
                                    "import org.bouncycastle.crypto.StreamBlockCipher;",
                                    "import org.bouncycastle.crypto.engines.BlowfishEngine;",
                                    "import org.bouncycastle.crypto.modes.CFBBlockCipher;",
                                    "import javax.crypto.SecretKey;",
                                    "import javax.crypto.spec.SecretKeySpec;",
                                    "import java.io.ByteArrayOutputStream;",
                                    "import java.security.InvalidAlgorithmParameterException;",
                                    "import java.util.HashMap;",
                                    "import java.util.Map;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class BlowFishCrypt extends CryptBase {\n\n    public final static String CIPHER_BLOWFISH_CFB = \"bf-cfb\";\n\n    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_BLOWFISH_CFB, BlowFishCrypt.class.getName());\n\n        return ciphers;\n    }\n\n    public BlowFishCrypt(String name, String password) {\n        super(name, password);\n    }\n\n    @Override\n    public int getKeyLength() {\n        return 16;\n    }\n\n    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        BlowfishEngine engine = new BlowfishEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_BLOWFISH_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }\n\n    @Override\n    public int getIVLength() {\n        return 8;\n    }\n\n    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }\n\n    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n\n    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n}",
                                      "definition": "public class BlowFishCrypt extends CryptBase",
                                      "byte_span": [
                                        1954,
                                        3706
                                      ],
                                      "start_point": [
                                        47,
                                        0
                                      ],
                                      "end_point": [
                                        109,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "BlowFishCrypt",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    public final static String CIPHER_BLOWFISH_CFB = \"bf-cfb\";",
                                            "docstring": "",
                                            "modifiers": "public final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "CIPHER_BLOWFISH_CFB = \"bf-cfb\"",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2070,
                                            2277
                                          ],
                                          "original_string": "    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_BLOWFISH_CFB, BlowFishCrypt.class.getName());\n\n        return ciphers;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "Map<String, String>",
                                            "classes": []
                                          },
                                          "name": "getCiphers",
                                          "body": "                                                   {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_BLOWFISH_CFB, BlowFishCrypt.class.getName());\n\n        return ciphers;\n    }",
                                          "identifiers": "ciphers ciphers put CIPHER_BLOWFISH_CFB getName ciphers",
                                          "signature": "    public static Map<String, String> getCiphers()",
                                          "signature_woname": "    public static Map<String, String> ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2283,
                                            2372
                                          ],
                                          "original_string": "    public BlowFishCrypt(String name, String password) {\n        super(name, password);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "BlowFishCrypt",
                                          "body": "                                                       {\n        super(name, password);\n    }",
                                          "identifiers": "name password",
                                          "signature": "    public BlowFishCrypt(String name, String password)",
                                          "signature_woname": "    public (String name, String password)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2378,
                                            2444
                                          ],
                                          "original_string": "    @Override\n    public int getKeyLength() {\n        return 16;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "int",
                                            "classes": []
                                          },
                                          "name": "getKeyLength",
                                          "body": "                              {\n        return 16;\n    }",
                                          "identifiers": "",
                                          "signature": "    @Override\n    public int getKeyLength()",
                                          "signature_woname": "    @Override\n    public int ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2450,
                                            2902
                                          ],
                                          "original_string": "    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        BlowfishEngine engine = new BlowfishEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_BLOWFISH_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "StreamBlockCipher",
                                            "classes": []
                                          },
                                          "name": "getCipher",
                                          "body": "                                                                                                         {\n        BlowfishEngine engine = new BlowfishEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_BLOWFISH_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }",
                                          "identifiers": "engine cipher _name equals CIPHER_BLOWFISH_CFB cipher engine getIVLength _name cipher",
                                          "signature": "    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted)",
                                          "signature_woname": "    @Override\n    protected StreamBlockCipher (boolean isEncrypted)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2908,
                                            2972
                                          ],
                                          "original_string": "    @Override\n    public int getIVLength() {\n        return 8;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "int",
                                            "classes": []
                                          },
                                          "name": "getIVLength",
                                          "body": "                             {\n        return 8;\n    }",
                                          "identifiers": "",
                                          "signature": "    @Override\n    public int getIVLength()",
                                          "signature_woname": "    @Override\n    public int ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2978,
                                            3090
                                          ],
                                          "original_string": "    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "SecretKey",
                                            "classes": []
                                          },
                                          "name": "getKey",
                                          "body": "                                 {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }",
                                          "identifiers": "_ssKey getEncoded",
                                          "signature": "    @Override\n    protected SecretKey getKey()",
                                          "signature_woname": "    @Override\n    protected SecretKey ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3096,
                                            3397
                                          ],
                                          "original_string": "    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "_encrypt",
                                          "body": "                                                                       {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "identifiers": "noBytesProcessed buffer data length noBytesProcessed encCipher processBytes data data length buffer stream write buffer noBytesProcessed",
                                          "signature": "    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    protected void (byte[] data, ByteArrayOutputStream stream)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3403,
                                            3704
                                          ],
                                          "original_string": "    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "_decrypt",
                                          "body": "                                                                       {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "identifiers": "noBytesProcessed buffer data length noBytesProcessed decCipher processBytes data data length buffer stream write buffer noBytesProcessed",
                                          "signature": "    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    protected void (byte[] data, ByteArrayOutputStream stream)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": []
                              },
                              {
                                "name": "CryptFactory.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.ss;\n\nimport com.stfl.misc.Reflection;\nimport java.util.*;\nimport java.util.logging.Logger;\n\n/**\n * Crypt factory\n */\npublic class CryptFactory {\n    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};\n    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());\n\n    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }\n\n    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.ss;",
                                    "import com.stfl.misc.Reflection;",
                                    "import java.util.*;",
                                    "import java.util.logging.Logger;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class CryptFactory {\n    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};\n    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());\n\n    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }\n\n    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                      "definition": "public class CryptFactory",
                                      "byte_span": [
                                        1649,
                                        2693
                                      ],
                                      "start_point": [
                                        40,
                                        0
                                      ],
                                      "end_point": [
                                        71,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "CryptFactory",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};",
                                            "docstring": "",
                                            "modifiers": "private static final",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private",
                                              "static",
                                              "final"
                                            ],
                                            "comments": [],
                                            "type": "Map<String, String>",
                                            "name": "crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }}",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());",
                                            "docstring": "",
                                            "modifiers": "private static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "Logger",
                                            "name": "logger = Logger.getLogger(CryptFactory.class.getName())",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2057,
                                            2158
                                          ],
                                          "original_string": "    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "boolean",
                                            "classes": []
                                          },
                                          "name": "isCipherExisted",
                                          "body": "                                                       {\n        return (crypts.get(name) != null);\n    }",
                                          "identifiers": "crypts get name",
                                          "signature": "    public static boolean isCipherExisted(String name)",
                                          "signature_woname": "    public static boolean (String name)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2164,
                                            2504
                                          ],
                                          "original_string": "    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "ICrypt",
                                            "classes": []
                                          },
                                          "name": "get",
                                          "body": "                                                           {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                          "identifiers": "obj Reflection get crypts get name name password obj e logger info com stfl misc Util getErrorMessage e",
                                          "signature": "    public static ICrypt get(String name, String password)",
                                          "signature_woname": "    public static ICrypt (String name, String password)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2510,
                                            2691
                                          ],
                                          "original_string": "    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "List<String>",
                                            "classes": []
                                          },
                                          "name": "getSupportedCiphers",
                                          "body": "                                                     {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                          "identifiers": "sortedKeys crypts keySet Collections sort sortedKeys sortedKeys",
                                          "signature": "    public static List<String> getSupportedCiphers()",
                                          "signature_woname": "    public static List<String> ()"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": [
                                  {
                                    "original_string": "public class Reflection {\n    public static Object get(String className, Object... args) {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }\n}",
                                    "definition": "public class Reflection",
                                    "byte_span": [
                                      63,
                                      1202
                                    ],
                                    "start_point": [
                                      4,
                                      0
                                    ],
                                    "end_point": [
                                      33,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Reflection",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          93,
                                          1200
                                        ],
                                        "original_string": "    public static Object get(String className, Object... args) {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "Object",
                                          "classes": []
                                        },
                                        "name": "get",
                                        "body": "                                                               {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }",
                                        "identifiers": "retValue c Class forName className args length retValue c newInstance args length oParam args length arg_i i arg_i args length arg_i i oParam i args arg_i constructor c getConstructor oParam paramObjs args length arg_i i arg_i args length arg_i i paramObjs i args arg_i retValue constructor newInstance paramObjs e e printStackTrace retValue",
                                        "signature": "    public static Object get(String className, Object... args)",
                                        "signature_woname": "    public static Object (String className, Object... args)"
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "name": "CryptBase.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.ss;\n\nimport com.stfl.misc.Util;\nimport org.bouncycastle.crypto.StreamBlockCipher;\nimport org.bouncycastle.crypto.params.KeyParameter;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\n\nimport javax.crypto.SecretKey;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Logger;\n\n/**\n * Crypt base class implementation\n */\npublic abstract class CryptBase implements ICrypt {\n\n    protected abstract StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException;\n    protected abstract SecretKey getKey();\n    protected abstract void _encrypt(byte[] data, ByteArrayOutputStream stream);\n    protected abstract void _decrypt(byte[] data, ByteArrayOutputStream stream);\n\n    protected final String _name;\n    protected final SecretKey _key;\n    protected final ShadowSocksKey _ssKey;\n    protected final int _ivLength;\n    protected final int _keyLength;\n    protected boolean _encryptIVSet;\n    protected boolean _decryptIVSet;\n    protected byte[] _encryptIV;\n    protected byte[] _decryptIV;\n    protected final Lock encLock = new ReentrantLock();\n    protected final Lock decLock = new ReentrantLock();\n    protected StreamBlockCipher encCipher;\n    protected StreamBlockCipher decCipher;\n    private Logger logger = Logger.getLogger(CryptBase.class.getName());\n\n    public CryptBase(String name, String password) {\n        _name = name.toLowerCase();\n        _ivLength = getIVLength();\n        _keyLength = getKeyLength();\n        _ssKey = new ShadowSocksKey(password, _keyLength);\n        _key = getKey();\n    }\n\n    protected void setIV(byte[] iv, boolean isEncrypt)\n    {\n        if (_ivLength == 0) {\n            return;\n        }\n\n        if (isEncrypt)\n        {\n            _encryptIV = new byte[_ivLength];\n            System.arraycopy(iv, 0, _encryptIV, 0, _ivLength);\n            try {\n                encCipher = getCipher(isEncrypt);\n                ParametersWithIV parameterIV = new ParametersWithIV(new KeyParameter(_key.getEncoded()), _encryptIV);\n                encCipher.init(isEncrypt, parameterIV);\n            } catch (InvalidAlgorithmParameterException e) {\n                logger.info(e.toString());\n            }\n        }\n        else\n        {\n            _decryptIV = new byte[_ivLength];\n            System.arraycopy(iv, 0, _decryptIV, 0, _ivLength);\n            try {\n                decCipher = getCipher(isEncrypt);\n                ParametersWithIV parameterIV = new ParametersWithIV(new KeyParameter(_key.getEncoded()), _decryptIV);\n                decCipher.init(isEncrypt, parameterIV);\n            } catch (InvalidAlgorithmParameterException e) {\n                logger.info(e.toString());\n            }\n        }\n    }\n\n    @Override\n    public void encrypt(byte[] data, ByteArrayOutputStream stream) {\n        synchronized (encLock) {\n            stream.reset();\n            if (!_encryptIVSet) {\n                _encryptIVSet = true;\n                byte[] iv = Util.randomBytes(_ivLength);\n                setIV(iv, true);\n                try {\n                    stream.write(iv);\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                }\n\n            }\n\n            _encrypt(data, stream);\n        }\n    }\n\n    @Override\n    public void encrypt(byte[] data, int length, ByteArrayOutputStream stream) {\n        byte[] d = new byte[length];\n        System.arraycopy(data, 0, d, 0, length);\n        encrypt(d, stream);\n    }\n\n    @Override\n    public void decrypt(byte[] data, ByteArrayOutputStream stream) {\n        byte[] temp;\n\n        synchronized (decLock) {\n            stream.reset();\n            if (!_decryptIVSet) {\n                _decryptIVSet = true;\n                setIV(data, false);\n                temp = new byte[data.length - _ivLength];\n                System.arraycopy(data, _ivLength, temp, 0, data.length - _ivLength);\n            } else {\n                temp = data;\n            }\n\n            _decrypt(temp, stream);\n        }\n    }\n\n    @Override\n    public void decrypt(byte[] data, int length, ByteArrayOutputStream stream) {\n        byte[] d = new byte[length];\n        System.arraycopy(data, 0, d, 0, length);\n        decrypt(d, stream);\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.ss;",
                                    "import com.stfl.misc.Util;",
                                    "import org.bouncycastle.crypto.StreamBlockCipher;",
                                    "import org.bouncycastle.crypto.params.KeyParameter;",
                                    "import org.bouncycastle.crypto.params.ParametersWithIV;",
                                    "import javax.crypto.SecretKey;",
                                    "import java.io.ByteArrayOutputStream;",
                                    "import java.io.IOException;",
                                    "import java.security.InvalidAlgorithmParameterException;",
                                    "import java.util.concurrent.locks.Lock;",
                                    "import java.util.concurrent.locks.ReentrantLock;",
                                    "import java.util.logging.Logger;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public abstract class CryptBase implements ICrypt {\n\n    protected abstract StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException;\n    protected abstract SecretKey getKey();\n    protected abstract void _encrypt(byte[] data, ByteArrayOutputStream stream);\n    protected abstract void _decrypt(byte[] data, ByteArrayOutputStream stream);\n\n    protected final String _name;\n    protected final SecretKey _key;\n    protected final ShadowSocksKey _ssKey;\n    protected final int _ivLength;\n    protected final int _keyLength;\n    protected boolean _encryptIVSet;\n    protected boolean _decryptIVSet;\n    protected byte[] _encryptIV;\n    protected byte[] _decryptIV;\n    protected final Lock encLock = new ReentrantLock();\n    protected final Lock decLock = new ReentrantLock();\n    protected StreamBlockCipher encCipher;\n    protected StreamBlockCipher decCipher;\n    private Logger logger = Logger.getLogger(CryptBase.class.getName());\n\n    public CryptBase(String name, String password) {\n        _name = name.toLowerCase();\n        _ivLength = getIVLength();\n        _keyLength = getKeyLength();\n        _ssKey = new ShadowSocksKey(password, _keyLength);\n        _key = getKey();\n    }\n\n    protected void setIV(byte[] iv, boolean isEncrypt)\n    {\n        if (_ivLength == 0) {\n            return;\n        }\n\n        if (isEncrypt)\n        {\n            _encryptIV = new byte[_ivLength];\n            System.arraycopy(iv, 0, _encryptIV, 0, _ivLength);\n            try {\n                encCipher = getCipher(isEncrypt);\n                ParametersWithIV parameterIV = new ParametersWithIV(new KeyParameter(_key.getEncoded()), _encryptIV);\n                encCipher.init(isEncrypt, parameterIV);\n            } catch (InvalidAlgorithmParameterException e) {\n                logger.info(e.toString());\n            }\n        }\n        else\n        {\n            _decryptIV = new byte[_ivLength];\n            System.arraycopy(iv, 0, _decryptIV, 0, _ivLength);\n            try {\n                decCipher = getCipher(isEncrypt);\n                ParametersWithIV parameterIV = new ParametersWithIV(new KeyParameter(_key.getEncoded()), _decryptIV);\n                decCipher.init(isEncrypt, parameterIV);\n            } catch (InvalidAlgorithmParameterException e) {\n                logger.info(e.toString());\n            }\n        }\n    }\n\n    @Override\n    public void encrypt(byte[] data, ByteArrayOutputStream stream) {\n        synchronized (encLock) {\n            stream.reset();\n            if (!_encryptIVSet) {\n                _encryptIVSet = true;\n                byte[] iv = Util.randomBytes(_ivLength);\n                setIV(iv, true);\n                try {\n                    stream.write(iv);\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                }\n\n            }\n\n            _encrypt(data, stream);\n        }\n    }\n\n    @Override\n    public void encrypt(byte[] data, int length, ByteArrayOutputStream stream) {\n        byte[] d = new byte[length];\n        System.arraycopy(data, 0, d, 0, length);\n        encrypt(d, stream);\n    }\n\n    @Override\n    public void decrypt(byte[] data, ByteArrayOutputStream stream) {\n        byte[] temp;\n\n        synchronized (decLock) {\n            stream.reset();\n            if (!_decryptIVSet) {\n                _decryptIVSet = true;\n                setIV(data, false);\n                temp = new byte[data.length - _ivLength];\n                System.arraycopy(data, _ivLength, temp, 0, data.length - _ivLength);\n            } else {\n                temp = data;\n            }\n\n            _decrypt(temp, stream);\n        }\n    }\n\n    @Override\n    public void decrypt(byte[] data, int length, ByteArrayOutputStream stream) {\n        byte[] d = new byte[length];\n        System.arraycopy(data, 0, d, 0, length);\n        decrypt(d, stream);\n    }\n}",
                                      "definition": "public abstract class CryptBase implements ICrypt",
                                      "byte_span": [
                                        2043,
                                        5917
                                      ],
                                      "start_point": [
                                        49,
                                        0
                                      ],
                                      "end_point": [
                                        163,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "CryptBase",
                                      "attributes": {
                                        "modifiers": "public abstract",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public",
                                          "abstract"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    protected final String _name;",
                                            "docstring": "",
                                            "modifiers": "protected final",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected",
                                              "final"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "_name",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected final SecretKey _key;",
                                            "docstring": "",
                                            "modifiers": "protected final",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected",
                                              "final"
                                            ],
                                            "comments": [],
                                            "type": "SecretKey",
                                            "name": "_key",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected final ShadowSocksKey _ssKey;",
                                            "docstring": "",
                                            "modifiers": "protected final",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected",
                                              "final"
                                            ],
                                            "comments": [],
                                            "type": "ShadowSocksKey",
                                            "name": "_ssKey",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected final int _ivLength;",
                                            "docstring": "",
                                            "modifiers": "protected final",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected",
                                              "final"
                                            ],
                                            "comments": [],
                                            "type": "int",
                                            "name": "_ivLength",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected final int _keyLength;",
                                            "docstring": "",
                                            "modifiers": "protected final",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected",
                                              "final"
                                            ],
                                            "comments": [],
                                            "type": "int",
                                            "name": "_keyLength",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected boolean _encryptIVSet;",
                                            "docstring": "",
                                            "modifiers": "protected",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "type": "boolean",
                                            "name": "_encryptIVSet",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected boolean _decryptIVSet;",
                                            "docstring": "",
                                            "modifiers": "protected",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "type": "boolean",
                                            "name": "_decryptIVSet",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected byte[] _encryptIV;",
                                            "docstring": "",
                                            "modifiers": "protected",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "type": "byte[]",
                                            "name": "_encryptIV",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected byte[] _decryptIV;",
                                            "docstring": "",
                                            "modifiers": "protected",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "type": "byte[]",
                                            "name": "_decryptIV",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected final Lock encLock = new ReentrantLock();",
                                            "docstring": "",
                                            "modifiers": "protected final",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected",
                                              "final"
                                            ],
                                            "comments": [],
                                            "type": "Lock",
                                            "name": "encLock = new ReentrantLock()",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected final Lock decLock = new ReentrantLock();",
                                            "docstring": "",
                                            "modifiers": "protected final",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected",
                                              "final"
                                            ],
                                            "comments": [],
                                            "type": "Lock",
                                            "name": "decLock = new ReentrantLock()",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected StreamBlockCipher encCipher;",
                                            "docstring": "",
                                            "modifiers": "protected",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "type": "StreamBlockCipher",
                                            "name": "encCipher",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    protected StreamBlockCipher decCipher;",
                                            "docstring": "",
                                            "modifiers": "protected",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "type": "StreamBlockCipher",
                                            "name": "decCipher",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private Logger logger = Logger.getLogger(CryptBase.class.getName());",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Logger",
                                            "name": "logger = Logger.getLogger(CryptBase.class.getName())",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2100,
                                            2210
                                          ],
                                          "original_string": "    protected abstract StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException;",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "protected abstract",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected",
                                              "abstract"
                                            ],
                                            "comments": [],
                                            "return_type": "StreamBlockCipher",
                                            "classes": []
                                          },
                                          "name": "getCipher",
                                          "body": "",
                                          "identifiers": "",
                                          "signature": "    protected abstract StreamBlockCipher getCipher(boolean isEncrypted)",
                                          "signature_woname": "    protected abstract StreamBlockCipher (boolean isEncrypted)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2215,
                                            2253
                                          ],
                                          "original_string": "    protected abstract SecretKey getKey();",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "protected abstract",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected",
                                              "abstract"
                                            ],
                                            "comments": [],
                                            "return_type": "SecretKey",
                                            "classes": []
                                          },
                                          "name": "getKey",
                                          "body": "",
                                          "identifiers": "",
                                          "signature": "    protected abstract SecretKey getKey()",
                                          "signature_woname": "    protected abstract SecretKey ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2258,
                                            2334
                                          ],
                                          "original_string": "    protected abstract void _encrypt(byte[] data, ByteArrayOutputStream stream);",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "protected abstract",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected",
                                              "abstract"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "_encrypt",
                                          "body": "",
                                          "identifiers": "",
                                          "signature": "    protected abstract void _encrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    protected abstract void (byte[] data, ByteArrayOutputStream stream)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2339,
                                            2415
                                          ],
                                          "original_string": "    protected abstract void _decrypt(byte[] data, ByteArrayOutputStream stream);",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "protected abstract",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected",
                                              "abstract"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "_decrypt",
                                          "body": "",
                                          "identifiers": "",
                                          "signature": "    protected abstract void _decrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    protected abstract void (byte[] data, ByteArrayOutputStream stream)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3017,
                                            3263
                                          ],
                                          "original_string": "    public CryptBase(String name, String password) {\n        _name = name.toLowerCase();\n        _ivLength = getIVLength();\n        _keyLength = getKeyLength();\n        _ssKey = new ShadowSocksKey(password, _keyLength);\n        _key = getKey();\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "CryptBase",
                                          "body": "                                                   {\n        _name = name.toLowerCase();\n        _ivLength = getIVLength();\n        _keyLength = getKeyLength();\n        _ssKey = new ShadowSocksKey(password, _keyLength);\n        _key = getKey();\n    }",
                                          "identifiers": "_name name toLowerCase _ivLength getIVLength _keyLength getKeyLength _ssKey password _keyLength _key getKey",
                                          "signature": "    public CryptBase(String name, String password)",
                                          "signature_woname": "    public (String name, String password)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3269,
                                            4406
                                          ],
                                          "original_string": "    protected void setIV(byte[] iv, boolean isEncrypt)\n    {\n        if (_ivLength == 0) {\n            return;\n        }\n\n        if (isEncrypt)\n        {\n            _encryptIV = new byte[_ivLength];\n            System.arraycopy(iv, 0, _encryptIV, 0, _ivLength);\n            try {\n                encCipher = getCipher(isEncrypt);\n                ParametersWithIV parameterIV = new ParametersWithIV(new KeyParameter(_key.getEncoded()), _encryptIV);\n                encCipher.init(isEncrypt, parameterIV);\n            } catch (InvalidAlgorithmParameterException e) {\n                logger.info(e.toString());\n            }\n        }\n        else\n        {\n            _decryptIV = new byte[_ivLength];\n            System.arraycopy(iv, 0, _decryptIV, 0, _ivLength);\n            try {\n                decCipher = getCipher(isEncrypt);\n                ParametersWithIV parameterIV = new ParametersWithIV(new KeyParameter(_key.getEncoded()), _decryptIV);\n                decCipher.init(isEncrypt, parameterIV);\n            } catch (InvalidAlgorithmParameterException e) {\n                logger.info(e.toString());\n            }\n        }\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "protected",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setIV",
                                          "body": "    {\n        if (_ivLength == 0) {\n            return;\n        }\n\n        if (isEncrypt)\n        {\n            _encryptIV = new byte[_ivLength];\n            System.arraycopy(iv, 0, _encryptIV, 0, _ivLength);\n            try {\n                encCipher = getCipher(isEncrypt);\n                ParametersWithIV parameterIV = new ParametersWithIV(new KeyParameter(_key.getEncoded()), _encryptIV);\n                encCipher.init(isEncrypt, parameterIV);\n            } catch (InvalidAlgorithmParameterException e) {\n                logger.info(e.toString());\n            }\n        }\n        else\n        {\n            _decryptIV = new byte[_ivLength];\n            System.arraycopy(iv, 0, _decryptIV, 0, _ivLength);\n            try {\n                decCipher = getCipher(isEncrypt);\n                ParametersWithIV parameterIV = new ParametersWithIV(new KeyParameter(_key.getEncoded()), _decryptIV);\n                decCipher.init(isEncrypt, parameterIV);\n            } catch (InvalidAlgorithmParameterException e) {\n                logger.info(e.toString());\n            }\n        }\n    }",
                                          "identifiers": "_ivLength isEncrypt _encryptIV _ivLength System arraycopy iv _encryptIV _ivLength encCipher getCipher isEncrypt parameterIV _key getEncoded _encryptIV encCipher init isEncrypt parameterIV e logger info e toString _decryptIV _ivLength System arraycopy iv _decryptIV _ivLength decCipher getCipher isEncrypt parameterIV _key getEncoded _decryptIV decCipher init isEncrypt parameterIV e logger info e toString",
                                          "signature": "    protected void setIV(byte[] iv, boolean isEncrypt)",
                                          "signature_woname": "    protected void (byte[] iv, boolean isEncrypt)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4412,
                                            4948
                                          ],
                                          "original_string": "    @Override\n    public void encrypt(byte[] data, ByteArrayOutputStream stream) {\n        synchronized (encLock) {\n            stream.reset();\n            if (!_encryptIVSet) {\n                _encryptIVSet = true;\n                byte[] iv = Util.randomBytes(_ivLength);\n                setIV(iv, true);\n                try {\n                    stream.write(iv);\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                }\n\n            }\n\n            _encrypt(data, stream);\n        }\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "encrypt",
                                          "body": "                                                                   {\n        synchronized (encLock) {\n            stream.reset();\n            if (!_encryptIVSet) {\n                _encryptIVSet = true;\n                byte[] iv = Util.randomBytes(_ivLength);\n                setIV(iv, true);\n                try {\n                    stream.write(iv);\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                }\n\n            }\n\n            _encrypt(data, stream);\n        }\n    }",
                                          "identifiers": "encLock stream reset _encryptIVSet _encryptIVSet iv Util randomBytes _ivLength setIV iv stream write iv e logger info e toString _encrypt data stream",
                                          "signature": "    @Override\n    public void encrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    public void (byte[] data, ByteArrayOutputStream stream)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4954,
                                            5164
                                          ],
                                          "original_string": "    @Override\n    public void encrypt(byte[] data, int length, ByteArrayOutputStream stream) {\n        byte[] d = new byte[length];\n        System.arraycopy(data, 0, d, 0, length);\n        encrypt(d, stream);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "encrypt",
                                          "body": "                                                                               {\n        byte[] d = new byte[length];\n        System.arraycopy(data, 0, d, 0, length);\n        encrypt(d, stream);\n    }",
                                          "identifiers": "d length System arraycopy data d length encrypt d stream",
                                          "signature": "    @Override\n    public void encrypt(byte[] data, int length, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    public void (byte[] data, int length, ByteArrayOutputStream stream)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            5170,
                                            5699
                                          ],
                                          "original_string": "    @Override\n    public void decrypt(byte[] data, ByteArrayOutputStream stream) {\n        byte[] temp;\n\n        synchronized (decLock) {\n            stream.reset();\n            if (!_decryptIVSet) {\n                _decryptIVSet = true;\n                setIV(data, false);\n                temp = new byte[data.length - _ivLength];\n                System.arraycopy(data, _ivLength, temp, 0, data.length - _ivLength);\n            } else {\n                temp = data;\n            }\n\n            _decrypt(temp, stream);\n        }\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "decrypt",
                                          "body": "                                                                   {\n        byte[] temp;\n\n        synchronized (decLock) {\n            stream.reset();\n            if (!_decryptIVSet) {\n                _decryptIVSet = true;\n                setIV(data, false);\n                temp = new byte[data.length - _ivLength];\n                System.arraycopy(data, _ivLength, temp, 0, data.length - _ivLength);\n            } else {\n                temp = data;\n            }\n\n            _decrypt(temp, stream);\n        }\n    }",
                                          "identifiers": "temp decLock stream reset _decryptIVSet _decryptIVSet setIV data temp data length _ivLength System arraycopy data _ivLength temp data length _ivLength temp data _decrypt temp stream",
                                          "signature": "    @Override\n    public void decrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    public void (byte[] data, ByteArrayOutputStream stream)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            5705,
                                            5915
                                          ],
                                          "original_string": "    @Override\n    public void decrypt(byte[] data, int length, ByteArrayOutputStream stream) {\n        byte[] d = new byte[length];\n        System.arraycopy(data, 0, d, 0, length);\n        decrypt(d, stream);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "decrypt",
                                          "body": "                                                                               {\n        byte[] d = new byte[length];\n        System.arraycopy(data, 0, d, 0, length);\n        decrypt(d, stream);\n    }",
                                          "identifiers": "d length System arraycopy data d length decrypt d stream",
                                          "signature": "    @Override\n    public void decrypt(byte[] data, int length, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    public void (byte[] data, int length, ByteArrayOutputStream stream)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": [
                                  {
                                    "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                    "definition": "public class Util",
                                    "byte_span": [
                                      1779,
                                      7484
                                    ],
                                    "start_point": [
                                      45,
                                      0
                                    ],
                                    "end_point": [
                                      219,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Util",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          1803,
                                          2018
                                        ],
                                        "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "dumpBytes",
                                        "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                        "identifiers": "sb a length b a sb append String format b sb toString",
                                        "signature": "    public static String dumpBytes(byte[] a)",
                                        "signature_woname": "    public static String (byte[] a)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2024,
                                          2180
                                        ],
                                        "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "byte[]",
                                          "classes": []
                                        },
                                        "name": "randomBytes",
                                        "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                        "identifiers": "bytes size nextBytes bytes bytes",
                                        "signature": "    public static byte[] randomBytes(int size)",
                                        "signature_woname": "    public static byte[] (int size)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2186,
                                          2412
                                        ],
                                        "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getErrorMessage",
                                        "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                        "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                        "signature": "    public static String getErrorMessage(Throwable e)",
                                        "signature_woname": "    public static String (Throwable e)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2418,
                                          4165
                                        ],
                                        "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "prettyPrintJson",
                                        "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                        "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                        "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                        "signature_woname": "    public static String (JSONObject jObj)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4171,
                                          5829
                                        ],
                                        "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getRequestedHostInfo",
                                        "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                        "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                        "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                        "signature_woname": "    public static String (byte[] data)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          5835,
                                          6128
                                        ],
                                        "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "bytesToString",
                                        "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                        "identifiers": "str str data start length e e printStackTrace str",
                                        "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                        "signature_woname": "    public static String (byte[] data, int start, int length)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6134,
                                          6648
                                        ],
                                        "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "byte[]",
                                          "classes": []
                                        },
                                        "name": "composeSSHeader",
                                        "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                        "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                        "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                        "signature_woname": "    public static byte[] (String host, int port)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6654,
                                          6969
                                        ],
                                        "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "saveFile",
                                        "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                        "identifiers": "writer writer fn writer println content writer close e",
                                        "signature": "    public static boolean saveFile(String fn, String content)",
                                        "signature_woname": "    public static boolean (String fn, String content)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6975,
                                          7262
                                        ],
                                        "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getFileContent",
                                        "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                        "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                        "signature": "    public static String getFileContent(String fn)",
                                        "signature_woname": "    public static String (String fn)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7268,
                                          7357
                                        ],
                                        "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "short",
                                          "classes": []
                                        },
                                        "name": "byteToUnsignedByte",
                                        "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                        "identifiers": "b",
                                        "signature": "    private static short byteToUnsignedByte(byte b)",
                                        "signature_woname": "    private static short (byte b)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7363,
                                          7482
                                        ],
                                        "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getPort",
                                        "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                        "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                        "signature": "    private static int getPort(byte b, byte b1)",
                                        "signature_woname": "    private static int (byte b, byte b1)"
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "name": "SeedCrypt.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.ss;\n\nimport org.bouncycastle.crypto.StreamBlockCipher;\nimport org.bouncycastle.crypto.engines.SEEDEngine;\nimport org.bouncycastle.crypto.modes.CFBBlockCipher;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.ByteArrayOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Seed cipher implementation\n */\npublic class SeedCrypt extends CryptBase {\n\n    public final static String CIPHER_SEED_CFB = \"seed-cfb\";\n\n    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_SEED_CFB, SeedCrypt.class.getName());\n\n        return ciphers;\n    }\n\n    public SeedCrypt(String name, String password) {\n        super(name, password);\n    }\n\n    @Override\n    public int getKeyLength() {\n        return 16;\n    }\n\n    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        SEEDEngine engine = new SEEDEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_SEED_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }\n\n    @Override\n    public int getIVLength() {\n        return 16;\n    }\n\n    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }\n\n    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n\n    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.ss;",
                                    "import org.bouncycastle.crypto.StreamBlockCipher;",
                                    "import org.bouncycastle.crypto.engines.SEEDEngine;",
                                    "import org.bouncycastle.crypto.modes.CFBBlockCipher;",
                                    "import javax.crypto.SecretKey;",
                                    "import javax.crypto.spec.SecretKeySpec;",
                                    "import java.io.ByteArrayOutputStream;",
                                    "import java.security.InvalidAlgorithmParameterException;",
                                    "import java.util.HashMap;",
                                    "import java.util.Map;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class SeedCrypt extends CryptBase {\n\n    public final static String CIPHER_SEED_CFB = \"seed-cfb\";\n\n    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_SEED_CFB, SeedCrypt.class.getName());\n\n        return ciphers;\n    }\n\n    public SeedCrypt(String name, String password) {\n        super(name, password);\n    }\n\n    @Override\n    public int getKeyLength() {\n        return 16;\n    }\n\n    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        SEEDEngine engine = new SEEDEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_SEED_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }\n\n    @Override\n    public int getIVLength() {\n        return 16;\n    }\n\n    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }\n\n    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n\n    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n}",
                                      "definition": "public class SeedCrypt extends CryptBase",
                                      "byte_span": [
                                        1945,
                                        3668
                                      ],
                                      "start_point": [
                                        47,
                                        0
                                      ],
                                      "end_point": [
                                        109,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "SeedCrypt",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    public final static String CIPHER_SEED_CFB = \"seed-cfb\";",
                                            "docstring": "",
                                            "modifiers": "public final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "CIPHER_SEED_CFB = \"seed-cfb\"",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2055,
                                            2254
                                          ],
                                          "original_string": "    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_SEED_CFB, SeedCrypt.class.getName());\n\n        return ciphers;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "Map<String, String>",
                                            "classes": []
                                          },
                                          "name": "getCiphers",
                                          "body": "                                                   {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_SEED_CFB, SeedCrypt.class.getName());\n\n        return ciphers;\n    }",
                                          "identifiers": "ciphers ciphers put CIPHER_SEED_CFB getName ciphers",
                                          "signature": "    public static Map<String, String> getCiphers()",
                                          "signature_woname": "    public static Map<String, String> ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2260,
                                            2345
                                          ],
                                          "original_string": "    public SeedCrypt(String name, String password) {\n        super(name, password);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "SeedCrypt",
                                          "body": "                                                   {\n        super(name, password);\n    }",
                                          "identifiers": "name password",
                                          "signature": "    public SeedCrypt(String name, String password)",
                                          "signature_woname": "    public (String name, String password)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2351,
                                            2417
                                          ],
                                          "original_string": "    @Override\n    public int getKeyLength() {\n        return 16;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "int",
                                            "classes": []
                                          },
                                          "name": "getKeyLength",
                                          "body": "                              {\n        return 16;\n    }",
                                          "identifiers": "",
                                          "signature": "    @Override\n    public int getKeyLength()",
                                          "signature_woname": "    @Override\n    public int ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2423,
                                            2863
                                          ],
                                          "original_string": "    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        SEEDEngine engine = new SEEDEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_SEED_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "StreamBlockCipher",
                                            "classes": []
                                          },
                                          "name": "getCipher",
                                          "body": "                                                                                                         {\n        SEEDEngine engine = new SEEDEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_SEED_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }",
                                          "identifiers": "engine cipher _name equals CIPHER_SEED_CFB cipher engine getIVLength _name cipher",
                                          "signature": "    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted)",
                                          "signature_woname": "    @Override\n    protected StreamBlockCipher (boolean isEncrypted)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2869,
                                            2934
                                          ],
                                          "original_string": "    @Override\n    public int getIVLength() {\n        return 16;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "int",
                                            "classes": []
                                          },
                                          "name": "getIVLength",
                                          "body": "                             {\n        return 16;\n    }",
                                          "identifiers": "",
                                          "signature": "    @Override\n    public int getIVLength()",
                                          "signature_woname": "    @Override\n    public int ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2940,
                                            3052
                                          ],
                                          "original_string": "    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "SecretKey",
                                            "classes": []
                                          },
                                          "name": "getKey",
                                          "body": "                                 {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }",
                                          "identifiers": "_ssKey getEncoded",
                                          "signature": "    @Override\n    protected SecretKey getKey()",
                                          "signature_woname": "    @Override\n    protected SecretKey ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3058,
                                            3359
                                          ],
                                          "original_string": "    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "_encrypt",
                                          "body": "                                                                       {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "identifiers": "noBytesProcessed buffer data length noBytesProcessed encCipher processBytes data data length buffer stream write buffer noBytesProcessed",
                                          "signature": "    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    protected void (byte[] data, ByteArrayOutputStream stream)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3365,
                                            3666
                                          ],
                                          "original_string": "    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "_decrypt",
                                          "body": "                                                                       {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "identifiers": "noBytesProcessed buffer data length noBytesProcessed decCipher processBytes data data length buffer stream write buffer noBytesProcessed",
                                          "signature": "    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    protected void (byte[] data, ByteArrayOutputStream stream)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": []
                              },
                              {
                                "name": "AesCrypt.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.ss;\n\nimport org.bouncycastle.crypto.StreamBlockCipher;\nimport org.bouncycastle.crypto.engines.AESEngine;\nimport org.bouncycastle.crypto.engines.AESFastEngine;\nimport org.bouncycastle.crypto.modes.CFBBlockCipher;\nimport org.bouncycastle.crypto.modes.OFBBlockCipher;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.ByteArrayOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * AES Crypt implementation\n */\npublic class AesCrypt extends CryptBase {\n\n    public final static String CIPHER_AES_128_CFB = \"aes-128-cfb\";\n    public final static String CIPHER_AES_192_CFB = \"aes-192-cfb\";\n    public final static String CIPHER_AES_256_CFB = \"aes-256-cfb\";\n    public final static String CIPHER_AES_128_OFB = \"aes-128-ofb\";\n    public final static String CIPHER_AES_192_OFB = \"aes-192-ofb\";\n    public final static String CIPHER_AES_256_OFB = \"aes-256-ofb\";\n\n    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_AES_128_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_128_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_OFB, AesCrypt.class.getName());\n\n        return ciphers;\n    }\n\n    public AesCrypt(String name, String password) {\n        super(name, password);\n    }\n\n    @Override\n    public int getKeyLength() {\n        if(_name.equals(CIPHER_AES_128_CFB) || _name.equals(CIPHER_AES_128_OFB)) {\n            return 16;\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB) || _name.equals(CIPHER_AES_192_OFB)) {\n            return 24;\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB) || _name.equals(CIPHER_AES_256_OFB)) {\n            return 32;\n        }\n\n        return 0;\n    }\n\n    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        AESFastEngine engine = new AESFastEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_AES_128_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_128_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }\n\n    @Override\n    public int getIVLength() {\n        return 16;\n    }\n\n    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }\n\n    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n\n    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.ss;",
                                    "import org.bouncycastle.crypto.StreamBlockCipher;",
                                    "import org.bouncycastle.crypto.engines.AESEngine;",
                                    "import org.bouncycastle.crypto.engines.AESFastEngine;",
                                    "import org.bouncycastle.crypto.modes.CFBBlockCipher;",
                                    "import org.bouncycastle.crypto.modes.OFBBlockCipher;",
                                    "import javax.crypto.SecretKey;",
                                    "import javax.crypto.spec.SecretKeySpec;",
                                    "import java.io.ByteArrayOutputStream;",
                                    "import java.security.InvalidAlgorithmParameterException;",
                                    "import java.util.HashMap;",
                                    "import java.util.Map;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class AesCrypt extends CryptBase {\n\n    public final static String CIPHER_AES_128_CFB = \"aes-128-cfb\";\n    public final static String CIPHER_AES_192_CFB = \"aes-192-cfb\";\n    public final static String CIPHER_AES_256_CFB = \"aes-256-cfb\";\n    public final static String CIPHER_AES_128_OFB = \"aes-128-ofb\";\n    public final static String CIPHER_AES_192_OFB = \"aes-192-ofb\";\n    public final static String CIPHER_AES_256_OFB = \"aes-256-ofb\";\n\n    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_AES_128_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_128_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_OFB, AesCrypt.class.getName());\n\n        return ciphers;\n    }\n\n    public AesCrypt(String name, String password) {\n        super(name, password);\n    }\n\n    @Override\n    public int getKeyLength() {\n        if(_name.equals(CIPHER_AES_128_CFB) || _name.equals(CIPHER_AES_128_OFB)) {\n            return 16;\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB) || _name.equals(CIPHER_AES_192_OFB)) {\n            return 24;\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB) || _name.equals(CIPHER_AES_256_OFB)) {\n            return 32;\n        }\n\n        return 0;\n    }\n\n    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        AESFastEngine engine = new AESFastEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_AES_128_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_128_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }\n\n    @Override\n    public int getIVLength() {\n        return 16;\n    }\n\n    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }\n\n    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n\n    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n}",
                                      "definition": "public class AesCrypt extends CryptBase",
                                      "byte_span": [
                                        2049,
                                        5472
                                      ],
                                      "start_point": [
                                        49,
                                        0
                                      ],
                                      "end_point": [
                                        146,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "AesCrypt",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    public final static String CIPHER_AES_128_CFB = \"aes-128-cfb\";",
                                            "docstring": "",
                                            "modifiers": "public final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "CIPHER_AES_128_CFB = \"aes-128-cfb\"",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    public final static String CIPHER_AES_192_CFB = \"aes-192-cfb\";",
                                            "docstring": "",
                                            "modifiers": "public final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "CIPHER_AES_192_CFB = \"aes-192-cfb\"",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    public final static String CIPHER_AES_256_CFB = \"aes-256-cfb\";",
                                            "docstring": "",
                                            "modifiers": "public final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "CIPHER_AES_256_CFB = \"aes-256-cfb\"",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    public final static String CIPHER_AES_128_OFB = \"aes-128-ofb\";",
                                            "docstring": "",
                                            "modifiers": "public final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "CIPHER_AES_128_OFB = \"aes-128-ofb\"",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    public final static String CIPHER_AES_192_OFB = \"aes-192-ofb\";",
                                            "docstring": "",
                                            "modifiers": "public final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "CIPHER_AES_192_OFB = \"aes-192-ofb\"",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    public final static String CIPHER_AES_256_OFB = \"aes-256-ofb\";",
                                            "docstring": "",
                                            "modifiers": "public final static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "final",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "CIPHER_AES_256_OFB = \"aes-256-ofb\"",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2499,
                                            3035
                                          ],
                                          "original_string": "    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_AES_128_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_128_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_OFB, AesCrypt.class.getName());\n\n        return ciphers;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "Map<String, String>",
                                            "classes": []
                                          },
                                          "name": "getCiphers",
                                          "body": "                                                   {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_AES_128_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_128_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_OFB, AesCrypt.class.getName());\n\n        return ciphers;\n    }",
                                          "identifiers": "ciphers ciphers put CIPHER_AES_128_CFB getName ciphers put CIPHER_AES_192_CFB getName ciphers put CIPHER_AES_256_CFB getName ciphers put CIPHER_AES_128_OFB getName ciphers put CIPHER_AES_192_OFB getName ciphers put CIPHER_AES_256_OFB getName ciphers",
                                          "signature": "    public static Map<String, String> getCiphers()",
                                          "signature_woname": "    public static Map<String, String> ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3041,
                                            3125
                                          ],
                                          "original_string": "    public AesCrypt(String name, String password) {\n        super(name, password);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "AesCrypt",
                                          "body": "                                                  {\n        super(name, password);\n    }",
                                          "identifiers": "name password",
                                          "signature": "    public AesCrypt(String name, String password)",
                                          "signature_woname": "    public (String name, String password)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3131,
                                            3557
                                          ],
                                          "original_string": "    @Override\n    public int getKeyLength() {\n        if(_name.equals(CIPHER_AES_128_CFB) || _name.equals(CIPHER_AES_128_OFB)) {\n            return 16;\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB) || _name.equals(CIPHER_AES_192_OFB)) {\n            return 24;\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB) || _name.equals(CIPHER_AES_256_OFB)) {\n            return 32;\n        }\n\n        return 0;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "int",
                                            "classes": []
                                          },
                                          "name": "getKeyLength",
                                          "body": "                              {\n        if(_name.equals(CIPHER_AES_128_CFB) || _name.equals(CIPHER_AES_128_OFB)) {\n            return 16;\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB) || _name.equals(CIPHER_AES_192_OFB)) {\n            return 24;\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB) || _name.equals(CIPHER_AES_256_OFB)) {\n            return 32;\n        }\n\n        return 0;\n    }",
                                          "identifiers": "_name equals CIPHER_AES_128_CFB _name equals CIPHER_AES_128_OFB _name equals CIPHER_AES_192_CFB _name equals CIPHER_AES_192_OFB _name equals CIPHER_AES_256_CFB _name equals CIPHER_AES_256_OFB",
                                          "signature": "    @Override\n    public int getKeyLength()",
                                          "signature_woname": "    @Override\n    public int ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3563,
                                            4667
                                          ],
                                          "original_string": "    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        AESFastEngine engine = new AESFastEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_AES_128_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_128_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "StreamBlockCipher",
                                            "classes": []
                                          },
                                          "name": "getCipher",
                                          "body": "                                                                                                         {\n        AESFastEngine engine = new AESFastEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_AES_128_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_128_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }",
                                          "identifiers": "engine cipher _name equals CIPHER_AES_128_CFB cipher engine getIVLength _name equals CIPHER_AES_192_CFB cipher engine getIVLength _name equals CIPHER_AES_256_CFB cipher engine getIVLength _name equals CIPHER_AES_128_OFB cipher engine getIVLength _name equals CIPHER_AES_192_OFB cipher engine getIVLength _name equals CIPHER_AES_256_OFB cipher engine getIVLength _name cipher",
                                          "signature": "    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted)",
                                          "signature_woname": "    @Override\n    protected StreamBlockCipher (boolean isEncrypted)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4673,
                                            4738
                                          ],
                                          "original_string": "    @Override\n    public int getIVLength() {\n        return 16;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "int",
                                            "classes": []
                                          },
                                          "name": "getIVLength",
                                          "body": "                             {\n        return 16;\n    }",
                                          "identifiers": "",
                                          "signature": "    @Override\n    public int getIVLength()",
                                          "signature_woname": "    @Override\n    public int ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4744,
                                            4856
                                          ],
                                          "original_string": "    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "SecretKey",
                                            "classes": []
                                          },
                                          "name": "getKey",
                                          "body": "                                 {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }",
                                          "identifiers": "_ssKey getEncoded",
                                          "signature": "    @Override\n    protected SecretKey getKey()",
                                          "signature_woname": "    @Override\n    protected SecretKey ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4862,
                                            5163
                                          ],
                                          "original_string": "    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "_encrypt",
                                          "body": "                                                                       {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "identifiers": "noBytesProcessed buffer data length noBytesProcessed encCipher processBytes data data length buffer stream write buffer noBytesProcessed",
                                          "signature": "    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    protected void (byte[] data, ByteArrayOutputStream stream)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            5169,
                                            5470
                                          ],
                                          "original_string": "    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "_decrypt",
                                          "body": "                                                                       {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                          "identifiers": "noBytesProcessed buffer data length noBytesProcessed decCipher processBytes data data length buffer stream write buffer noBytesProcessed",
                                          "signature": "    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream)",
                                          "signature_woname": "    @Override\n    protected void (byte[] data, ByteArrayOutputStream stream)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": []
                              },
                              {
                                "name": "ICrypt.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.ss;\n\nimport java.io.ByteArrayOutputStream;\nimport java.util.Map;\n\n/**\n * Interface of crypt\n */\npublic interface ICrypt {\n    void encrypt(byte[] data, ByteArrayOutputStream stream);\n    void encrypt(byte[] data, int length, ByteArrayOutputStream stream);\n    void decrypt(byte[] data, ByteArrayOutputStream stream);\n    void decrypt(byte[] data, int length, ByteArrayOutputStream stream);\n    int getIVLength();\n    int getKeyLength();\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.ss;",
                                    "import java.io.ByteArrayOutputStream;",
                                    "import java.util.Map;"
                                  ],
                                  "methods": [],
                                  "classes": []
                                },
                                "imports": []
                              }
                            ],
                            "subdirs": []
                          },
                          {
                            "dir": "misc",
                            "files": [
                              {
                                "name": "UTF8Control.java",
                                "content": "package com.stfl.misc;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Locale;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\n\npublic class UTF8Control extends ResourceBundle.Control {\n    public ResourceBundle newBundle\n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)\n            throws IllegalAccessException, InstantiationException, IOException\n    {\n        // below is the original implementation\n        String bundleName = toBundleName(baseName, locale);\n        String resourceName = toResourceName(bundleName, \"properties\");\n        ResourceBundle bundle = null;\n        InputStream stream = null;\n        if (reload) {\n            URL url = loader.getResource(resourceName);\n            if (url != null) {\n                URLConnection connection = url.openConnection();\n                if (connection != null) {\n                    connection.setUseCaches(false);\n                    stream = connection.getInputStream();\n                }\n            }\n        } else {\n            stream = loader.getResourceAsStream(resourceName);\n        }\n\n        if (stream != null) {\n            try {\n                // load string use UTF-8 encoding\n                bundle = new PropertyResourceBundle(new InputStreamReader(stream, \"UTF-8\"));\n            } finally {\n                stream.close();\n            }\n        }\n        return bundle;\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.misc;",
                                    "import java.io.IOException;",
                                    "import java.io.InputStream;",
                                    "import java.io.InputStreamReader;",
                                    "import java.net.URL;",
                                    "import java.net.URLConnection;",
                                    "import java.util.Locale;",
                                    "import java.util.PropertyResourceBundle;",
                                    "import java.util.ResourceBundle;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class UTF8Control extends ResourceBundle.Control {\n    public ResourceBundle newBundle\n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)\n            throws IllegalAccessException, InstantiationException, IOException\n    {\n        // below is the original implementation\n        String bundleName = toBundleName(baseName, locale);\n        String resourceName = toResourceName(bundleName, \"properties\");\n        ResourceBundle bundle = null;\n        InputStream stream = null;\n        if (reload) {\n            URL url = loader.getResource(resourceName);\n            if (url != null) {\n                URLConnection connection = url.openConnection();\n                if (connection != null) {\n                    connection.setUseCaches(false);\n                    stream = connection.getInputStream();\n                }\n            }\n        } else {\n            stream = loader.getResourceAsStream(resourceName);\n        }\n\n        if (stream != null) {\n            try {\n                // load string use UTF-8 encoding\n                bundle = new PropertyResourceBundle(new InputStreamReader(stream, \"UTF-8\"));\n            } finally {\n                stream.close();\n            }\n        }\n        return bundle;\n    }\n}",
                                      "definition": "public class UTF8Control extends ResourceBundle.Control",
                                      "byte_span": [
                                        266,
                                        1544
                                      ],
                                      "start_point": [
                                        11,
                                        0
                                      ],
                                      "end_point": [
                                        44,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "UTF8Control",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            328,
                                            1542
                                          ],
                                          "original_string": "    public ResourceBundle newBundle\n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)\n            throws IllegalAccessException, InstantiationException, IOException\n    {\n        // below is the original implementation\n        String bundleName = toBundleName(baseName, locale);\n        String resourceName = toResourceName(bundleName, \"properties\");\n        ResourceBundle bundle = null;\n        InputStream stream = null;\n        if (reload) {\n            URL url = loader.getResource(resourceName);\n            if (url != null) {\n                URLConnection connection = url.openConnection();\n                if (connection != null) {\n                    connection.setUseCaches(false);\n                    stream = connection.getInputStream();\n                }\n            }\n        } else {\n            stream = loader.getResourceAsStream(resourceName);\n        }\n\n        if (stream != null) {\n            try {\n                // load string use UTF-8 encoding\n                bundle = new PropertyResourceBundle(new InputStreamReader(stream, \"UTF-8\"));\n            } finally {\n                stream.close();\n            }\n        }\n        return bundle;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "ResourceBundle",
                                            "classes": []
                                          },
                                          "name": "newBundle",
                                          "body": "    {\n        // below is the original implementation\n        String bundleName = toBundleName(baseName, locale);\n        String resourceName = toResourceName(bundleName, \"properties\");\n        ResourceBundle bundle = null;\n        InputStream stream = null;\n        if (reload) {\n            URL url = loader.getResource(resourceName);\n            if (url != null) {\n                URLConnection connection = url.openConnection();\n                if (connection != null) {\n                    connection.setUseCaches(false);\n                    stream = connection.getInputStream();\n                }\n            }\n        } else {\n            stream = loader.getResourceAsStream(resourceName);\n        }\n\n        if (stream != null) {\n            try {\n                // load string use UTF-8 encoding\n                bundle = new PropertyResourceBundle(new InputStreamReader(stream, \"UTF-8\"));\n            } finally {\n                stream.close();\n            }\n        }\n        return bundle;\n    }",
                                          "identifiers": "bundleName toBundleName baseName locale resourceName toResourceName bundleName bundle stream reload url loader getResource resourceName url connection url openConnection connection connection setUseCaches stream connection getInputStream stream loader getResourceAsStream resourceName stream bundle stream stream close bundle",
                                          "signature": "    public ResourceBundle newBundle\n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)",
                                          "signature_woname": "    public ResourceBundle \n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": []
                              },
                              {
                                "name": "Log.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.misc;\n\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.logging.*;\n\n/**\n * Initialized level of root logger\n */\npublic class Log {\n    private static boolean handlerInit = false;\n\n    public static void init() {\n        init(Level.INFO);\n    }\n\n    public static void init(Level level) {\n        Logger rootLogger = getRootLogger();\n        if (handlerInit) {\n            rootLogger.setLevel(level);\n            for(Handler handler : rootLogger.getHandlers()) {\n                handler.setLevel(level);\n            }\n            return;\n        }\n\n        // disable message localization\n        Locale.setDefault(Locale.ENGLISH);\n        // config log output format\n        Properties props = System.getProperties();\n        props.setProperty(\"java.util.logging.SimpleFormatter.format\", \"%1$tY-%1$tb-%1$td %1$tT [%4$s] %5$s%n\");\n        // setup root logger\n        //Logger rootLogger = getRootLogger();\n        rootLogger.setUseParentHandlers(false);\n        for(Handler handler : rootLogger.getHandlers()) {\n            rootLogger.removeHandler(handler);\n        }\n        // set log level and format\n        rootLogger.setLevel(level);\n        ConsoleHandler handler = new ConsoleHandler();\n        handler.setLevel(level);\n        rootLogger.addHandler(handler);\n        handlerInit = true;\n    }\n\n    public static void init(String level) {\n        Level l = Level.parse(level);\n        init(l);\n    }\n\n    public static void addHandler(Handler handler) {\n        Logger rootLogger = getRootLogger();\n        Level logLevel = Level.INFO;\n        for (Handler h : rootLogger.getHandlers()) {\n            logLevel = h.getLevel();\n        }\n\n        handler.setLevel(logLevel);\n        rootLogger.addHandler(handler);\n    }\n\n    private static Logger getRootLogger() {\n        return Logger.getLogger(\"com.stfl\");\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.misc;",
                                    "import java.util.Locale;",
                                    "import java.util.Properties;",
                                    "import java.util.logging.*;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class Log {\n    private static boolean handlerInit = false;\n\n    public static void init() {\n        init(Level.INFO);\n    }\n\n    public static void init(Level level) {\n        Logger rootLogger = getRootLogger();\n        if (handlerInit) {\n            rootLogger.setLevel(level);\n            for(Handler handler : rootLogger.getHandlers()) {\n                handler.setLevel(level);\n            }\n            return;\n        }\n\n        // disable message localization\n        Locale.setDefault(Locale.ENGLISH);\n        // config log output format\n        Properties props = System.getProperties();\n        props.setProperty(\"java.util.logging.SimpleFormatter.format\", \"%1$tY-%1$tb-%1$td %1$tT [%4$s] %5$s%n\");\n        // setup root logger\n        //Logger rootLogger = getRootLogger();\n        rootLogger.setUseParentHandlers(false);\n        for(Handler handler : rootLogger.getHandlers()) {\n            rootLogger.removeHandler(handler);\n        }\n        // set log level and format\n        rootLogger.setLevel(level);\n        ConsoleHandler handler = new ConsoleHandler();\n        handler.setLevel(level);\n        rootLogger.addHandler(handler);\n        handlerInit = true;\n    }\n\n    public static void init(String level) {\n        Level l = Level.parse(level);\n        init(l);\n    }\n\n    public static void addHandler(Handler handler) {\n        Logger rootLogger = getRootLogger();\n        Level logLevel = Level.INFO;\n        for (Handler h : rootLogger.getHandlers()) {\n            logLevel = h.getLevel();\n        }\n\n        handler.setLevel(logLevel);\n        rootLogger.addHandler(handler);\n    }\n\n    private static Logger getRootLogger() {\n        return Logger.getLogger(\"com.stfl\");\n    }\n}",
                                      "definition": "public class Log",
                                      "byte_span": [
                                        1666,
                                        3379
                                      ],
                                      "start_point": [
                                        40,
                                        0
                                      ],
                                      "end_point": [
                                        95,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "Log",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    private static boolean handlerInit = false;",
                                            "docstring": "",
                                            "modifiers": "private static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private",
                                              "static"
                                            ],
                                            "comments": [],
                                            "type": "boolean",
                                            "name": "handlerInit = false",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            1738,
                                            1797
                                          ],
                                          "original_string": "    public static void init() {\n        init(Level.INFO);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "init",
                                          "body": "                              {\n        init(Level.INFO);\n    }",
                                          "identifiers": "init Level INFO",
                                          "signature": "    public static void init()",
                                          "signature_woname": "    public static void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            1803,
                                            2856
                                          ],
                                          "original_string": "    public static void init(Level level) {\n        Logger rootLogger = getRootLogger();\n        if (handlerInit) {\n            rootLogger.setLevel(level);\n            for(Handler handler : rootLogger.getHandlers()) {\n                handler.setLevel(level);\n            }\n            return;\n        }\n\n        // disable message localization\n        Locale.setDefault(Locale.ENGLISH);\n        // config log output format\n        Properties props = System.getProperties();\n        props.setProperty(\"java.util.logging.SimpleFormatter.format\", \"%1$tY-%1$tb-%1$td %1$tT [%4$s] %5$s%n\");\n        // setup root logger\n        //Logger rootLogger = getRootLogger();\n        rootLogger.setUseParentHandlers(false);\n        for(Handler handler : rootLogger.getHandlers()) {\n            rootLogger.removeHandler(handler);\n        }\n        // set log level and format\n        rootLogger.setLevel(level);\n        ConsoleHandler handler = new ConsoleHandler();\n        handler.setLevel(level);\n        rootLogger.addHandler(handler);\n        handlerInit = true;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "init",
                                          "body": "                                         {\n        Logger rootLogger = getRootLogger();\n        if (handlerInit) {\n            rootLogger.setLevel(level);\n            for(Handler handler : rootLogger.getHandlers()) {\n                handler.setLevel(level);\n            }\n            return;\n        }\n\n        // disable message localization\n        Locale.setDefault(Locale.ENGLISH);\n        // config log output format\n        Properties props = System.getProperties();\n        props.setProperty(\"java.util.logging.SimpleFormatter.format\", \"%1$tY-%1$tb-%1$td %1$tT [%4$s] %5$s%n\");\n        // setup root logger\n        //Logger rootLogger = getRootLogger();\n        rootLogger.setUseParentHandlers(false);\n        for(Handler handler : rootLogger.getHandlers()) {\n            rootLogger.removeHandler(handler);\n        }\n        // set log level and format\n        rootLogger.setLevel(level);\n        ConsoleHandler handler = new ConsoleHandler();\n        handler.setLevel(level);\n        rootLogger.addHandler(handler);\n        handlerInit = true;\n    }",
                                          "identifiers": "rootLogger getRootLogger handlerInit rootLogger setLevel level handler rootLogger getHandlers handler setLevel level Locale setDefault Locale ENGLISH props System getProperties props setProperty rootLogger setUseParentHandlers handler rootLogger getHandlers rootLogger removeHandler handler rootLogger setLevel level handler handler setLevel level rootLogger addHandler handler handlerInit",
                                          "signature": "    public static void init(Level level)",
                                          "signature_woname": "    public static void (Level level)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2862,
                                            2962
                                          ],
                                          "original_string": "    public static void init(String level) {\n        Level l = Level.parse(level);\n        init(l);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "init",
                                          "body": "                                          {\n        Level l = Level.parse(level);\n        init(l);\n    }",
                                          "identifiers": "l Level parse level init l",
                                          "signature": "    public static void init(String level)",
                                          "signature_woname": "    public static void (String level)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2968,
                                            3281
                                          ],
                                          "original_string": "    public static void addHandler(Handler handler) {\n        Logger rootLogger = getRootLogger();\n        Level logLevel = Level.INFO;\n        for (Handler h : rootLogger.getHandlers()) {\n            logLevel = h.getLevel();\n        }\n\n        handler.setLevel(logLevel);\n        rootLogger.addHandler(handler);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "addHandler",
                                          "body": "                                                   {\n        Logger rootLogger = getRootLogger();\n        Level logLevel = Level.INFO;\n        for (Handler h : rootLogger.getHandlers()) {\n            logLevel = h.getLevel();\n        }\n\n        handler.setLevel(logLevel);\n        rootLogger.addHandler(handler);\n    }",
                                          "identifiers": "rootLogger getRootLogger logLevel Level INFO h rootLogger getHandlers logLevel h getLevel handler setLevel logLevel rootLogger addHandler handler",
                                          "signature": "    public static void addHandler(Handler handler)",
                                          "signature_woname": "    public static void (Handler handler)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3287,
                                            3377
                                          ],
                                          "original_string": "    private static Logger getRootLogger() {\n        return Logger.getLogger(\"com.stfl\");\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "private static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "Logger",
                                            "classes": []
                                          },
                                          "name": "getRootLogger",
                                          "body": "                                          {\n        return Logger.getLogger(\"com.stfl\");\n    }",
                                          "identifiers": "Logger getLogger",
                                          "signature": "    private static Logger getRootLogger()",
                                          "signature_woname": "    private static Logger ()"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": []
                              },
                              {
                                "name": "Util.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.misc;\n\nimport com.stfl.network.proxy.Socks5Proxy;\nimport org.json.simple.JSONObject;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.SecureRandom;\n\n/**\n * Helper class\n */\npublic class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.misc;",
                                    "import com.stfl.network.proxy.Socks5Proxy;",
                                    "import org.json.simple.JSONObject;",
                                    "import java.io.*;",
                                    "import java.nio.file.Files;",
                                    "import java.nio.file.Path;",
                                    "import java.nio.file.Paths;",
                                    "import java.security.SecureRandom;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                      "definition": "public class Util",
                                      "byte_span": [
                                        1779,
                                        7484
                                      ],
                                      "start_point": [
                                        45,
                                        0
                                      ],
                                      "end_point": [
                                        219,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "Util",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            1803,
                                            2018
                                          ],
                                          "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "dumpBytes",
                                          "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                          "identifiers": "sb a length b a sb append String format b sb toString",
                                          "signature": "    public static String dumpBytes(byte[] a)",
                                          "signature_woname": "    public static String (byte[] a)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2024,
                                            2180
                                          ],
                                          "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "byte[]",
                                            "classes": []
                                          },
                                          "name": "randomBytes",
                                          "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                          "identifiers": "bytes size nextBytes bytes bytes",
                                          "signature": "    public static byte[] randomBytes(int size)",
                                          "signature_woname": "    public static byte[] (int size)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2186,
                                            2412
                                          ],
                                          "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "getErrorMessage",
                                          "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                          "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                          "signature": "    public static String getErrorMessage(Throwable e)",
                                          "signature_woname": "    public static String (Throwable e)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2418,
                                            4165
                                          ],
                                          "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "prettyPrintJson",
                                          "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                          "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                          "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                          "signature_woname": "    public static String (JSONObject jObj)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4171,
                                            5829
                                          ],
                                          "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "getRequestedHostInfo",
                                          "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                          "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                          "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                          "signature_woname": "    public static String (byte[] data)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            5835,
                                            6128
                                          ],
                                          "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "bytesToString",
                                          "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                          "identifiers": "str str data start length e e printStackTrace str",
                                          "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                          "signature_woname": "    public static String (byte[] data, int start, int length)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            6134,
                                            6648
                                          ],
                                          "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "byte[]",
                                            "classes": []
                                          },
                                          "name": "composeSSHeader",
                                          "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                          "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                          "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                          "signature_woname": "    public static byte[] (String host, int port)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            6654,
                                            6969
                                          ],
                                          "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "boolean",
                                            "classes": []
                                          },
                                          "name": "saveFile",
                                          "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                          "identifiers": "writer writer fn writer println content writer close e",
                                          "signature": "    public static boolean saveFile(String fn, String content)",
                                          "signature_woname": "    public static boolean (String fn, String content)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            6975,
                                            7262
                                          ],
                                          "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "getFileContent",
                                          "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                          "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                          "signature": "    public static String getFileContent(String fn)",
                                          "signature_woname": "    public static String (String fn)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            7268,
                                            7357
                                          ],
                                          "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "private static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "short",
                                            "classes": []
                                          },
                                          "name": "byteToUnsignedByte",
                                          "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                          "identifiers": "b",
                                          "signature": "    private static short byteToUnsignedByte(byte b)",
                                          "signature_woname": "    private static short (byte b)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            7363,
                                            7482
                                          ],
                                          "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "private static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "int",
                                            "classes": []
                                          },
                                          "name": "getPort",
                                          "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                          "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                          "signature": "    private static int getPort(byte b, byte b1)",
                                          "signature_woname": "    private static int (byte b, byte b1)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": [
                                  {
                                    "original_string": "public class Socks5Proxy implements IProxy {\n    public final static int ATYP_IP_V4 = 0x1;\n    public final static int ATYP_DOMAIN_NAME = 0x3;\n    public final static int ATYP_IP_V6 = 0x4;\n\n    private Logger logger = Logger.getLogger(Socks5Proxy.class.getName());\n    private enum STAGE {SOCK5_HELLO, SOCKS_ACK, SOCKS_READY}\n    private STAGE _stage;\n\n    public Socks5Proxy() {\n        _stage = STAGE.SOCK5_HELLO;\n    }\n\n    public TYPE getType() {\n        return TYPE.SOCKS5;\n    }\n\n    public boolean isReady() {\n        return (_stage == STAGE.SOCKS_READY);\n    }\n\n    public byte[] getResponse(byte[] data) {\n        byte[] respData = null;\n\n        switch (_stage) {\n            case SOCK5_HELLO:\n                if (isMine(data)) {\n                    respData = new byte[] {5, 0};\n                }\n                else {\n                    respData = new byte[] {0, 91};\n                }\n                _stage = STAGE.SOCKS_ACK;\n                break;\n            case SOCKS_ACK:\n                respData = new byte[] {5, 0, 0, 1, 0, 0, 0, 0, 0, 0};\n                _stage = STAGE.SOCKS_READY;\n                break;\n            default:\n                // TODO: exception\n                break;\n\n        }\n\n        return respData;\n    }\n\n    public List<byte[]> getRemoteResponse(byte[] data) {\n        List<byte[]> respData = null;\n        int dataLength = data.length;\n\n        /*\n        There are two stage of establish Sock5:\n            1. HELLO (3 bytes)\n            2. ACK (3 bytes + dst info)\n        as Client sending ACK, it might contain dst info.\n        In this case, server needs to send back ACK response to client and start the remote socket right away,\n        otherwise, client will wait until timeout.\n         */\n        if (_stage == STAGE.SOCKS_READY) {\n            respData = new ArrayList<>(1);\n            // remove socks5 header (partial)\n            if (dataLength > 3) {\n                dataLength -= 3;\n                byte[] temp = new byte[dataLength];\n                System.arraycopy(data, 3, temp, 0, dataLength);\n                respData.add(temp);\n            }\n        }\n\n        return respData;\n    }\n\n    @Override\n    public boolean isMine(byte[] data) {\n        if (data[0] == 0x5) {\n            return true;\n        }\n\n        return false;\n    }\n}",
                                    "definition": "public class Socks5Proxy implements IProxy",
                                    "byte_span": [
                                      1694,
                                      4001
                                    ],
                                    "start_point": [
                                      40,
                                      0
                                    ],
                                    "end_point": [
                                      121,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Socks5Proxy",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    public final static int ATYP_IP_V4 = 0x1;",
                                          "docstring": "",
                                          "modifiers": "public final static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "final",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "ATYP_IP_V4 = 0x1",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public final static int ATYP_DOMAIN_NAME = 0x3;",
                                          "docstring": "",
                                          "modifiers": "public final static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "final",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "ATYP_DOMAIN_NAME = 0x3",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public final static int ATYP_IP_V6 = 0x4;",
                                          "docstring": "",
                                          "modifiers": "public final static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "final",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "ATYP_IP_V6 = 0x4",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private Logger logger = Logger.getLogger(Socks5Proxy.class.getName());",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "Logger",
                                          "name": "logger = Logger.getLogger(Socks5Proxy.class.getName())",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private STAGE _stage;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "STAGE",
                                          "name": "_stage",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2051,
                                          2115
                                        ],
                                        "original_string": "    public Socks5Proxy() {\n        _stage = STAGE.SOCK5_HELLO;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "Socks5Proxy",
                                        "body": "                         {\n        _stage = STAGE.SOCK5_HELLO;\n    }",
                                        "identifiers": "_stage STAGE SOCK5_HELLO",
                                        "signature": "    public Socks5Proxy()",
                                        "signature_woname": "    public ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2121,
                                          2178
                                        ],
                                        "original_string": "    public TYPE getType() {\n        return TYPE.SOCKS5;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "TYPE",
                                          "classes": []
                                        },
                                        "name": "getType",
                                        "body": "                          {\n        return TYPE.SOCKS5;\n    }",
                                        "identifiers": "TYPE SOCKS5",
                                        "signature": "    public TYPE getType()",
                                        "signature_woname": "    public TYPE ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2184,
                                          2262
                                        ],
                                        "original_string": "    public boolean isReady() {\n        return (_stage == STAGE.SOCKS_READY);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "isReady",
                                        "body": "                             {\n        return (_stage == STAGE.SOCKS_READY);\n    }",
                                        "identifiers": "_stage STAGE SOCKS_READY",
                                        "signature": "    public boolean isReady()",
                                        "signature_woname": "    public boolean ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2268,
                                          2945
                                        ],
                                        "original_string": "    public byte[] getResponse(byte[] data) {\n        byte[] respData = null;\n\n        switch (_stage) {\n            case SOCK5_HELLO:\n                if (isMine(data)) {\n                    respData = new byte[] {5, 0};\n                }\n                else {\n                    respData = new byte[] {0, 91};\n                }\n                _stage = STAGE.SOCKS_ACK;\n                break;\n            case SOCKS_ACK:\n                respData = new byte[] {5, 0, 0, 1, 0, 0, 0, 0, 0, 0};\n                _stage = STAGE.SOCKS_READY;\n                break;\n            default:\n                // TODO: exception\n                break;\n\n        }\n\n        return respData;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "byte[]",
                                          "classes": []
                                        },
                                        "name": "getResponse",
                                        "body": "                                           {\n        byte[] respData = null;\n\n        switch (_stage) {\n            case SOCK5_HELLO:\n                if (isMine(data)) {\n                    respData = new byte[] {5, 0};\n                }\n                else {\n                    respData = new byte[] {0, 91};\n                }\n                _stage = STAGE.SOCKS_ACK;\n                break;\n            case SOCKS_ACK:\n                respData = new byte[] {5, 0, 0, 1, 0, 0, 0, 0, 0, 0};\n                _stage = STAGE.SOCKS_READY;\n                break;\n            default:\n                // TODO: exception\n                break;\n\n        }\n\n        return respData;\n    }",
                                        "identifiers": "respData _stage SOCK5_HELLO isMine data respData respData _stage STAGE SOCKS_ACK SOCKS_ACK respData _stage STAGE SOCKS_READY respData",
                                        "signature": "    public byte[] getResponse(byte[] data)",
                                        "signature_woname": "    public byte[] (byte[] data)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2951,
                                          3849
                                        ],
                                        "original_string": "    public List<byte[]> getRemoteResponse(byte[] data) {\n        List<byte[]> respData = null;\n        int dataLength = data.length;\n\n        /*\n        There are two stage of establish Sock5:\n            1. HELLO (3 bytes)\n            2. ACK (3 bytes + dst info)\n        as Client sending ACK, it might contain dst info.\n        In this case, server needs to send back ACK response to client and start the remote socket right away,\n        otherwise, client will wait until timeout.\n         */\n        if (_stage == STAGE.SOCKS_READY) {\n            respData = new ArrayList<>(1);\n            // remove socks5 header (partial)\n            if (dataLength > 3) {\n                dataLength -= 3;\n                byte[] temp = new byte[dataLength];\n                System.arraycopy(data, 3, temp, 0, dataLength);\n                respData.add(temp);\n            }\n        }\n\n        return respData;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "List<byte[]>",
                                          "classes": []
                                        },
                                        "name": "getRemoteResponse",
                                        "body": "                                                       {\n        List<byte[]> respData = null;\n        int dataLength = data.length;\n\n        /*\n        There are two stage of establish Sock5:\n            1. HELLO (3 bytes)\n            2. ACK (3 bytes + dst info)\n        as Client sending ACK, it might contain dst info.\n        In this case, server needs to send back ACK response to client and start the remote socket right away,\n        otherwise, client will wait until timeout.\n         */\n        if (_stage == STAGE.SOCKS_READY) {\n            respData = new ArrayList<>(1);\n            // remove socks5 header (partial)\n            if (dataLength > 3) {\n                dataLength -= 3;\n                byte[] temp = new byte[dataLength];\n                System.arraycopy(data, 3, temp, 0, dataLength);\n                respData.add(temp);\n            }\n        }\n\n        return respData;\n    }",
                                        "identifiers": "respData dataLength data length _stage STAGE SOCKS_READY respData dataLength dataLength temp dataLength System arraycopy data temp dataLength respData add temp respData",
                                        "signature": "    public List<byte[]> getRemoteResponse(byte[] data)",
                                        "signature_woname": "    public List<byte[]> (byte[] data)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3855,
                                          3999
                                        ],
                                        "original_string": "    @Override\n    public boolean isMine(byte[] data) {\n        if (data[0] == 0x5) {\n            return true;\n        }\n\n        return false;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    public",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "isMine",
                                        "body": "                                       {\n        if (data[0] == 0x5) {\n            return true;\n        }\n\n        return false;\n    }",
                                        "identifiers": "data",
                                        "signature": "    @Override\n    public boolean isMine(byte[] data)",
                                        "signature_woname": "    @Override\n    public boolean (byte[] data)"
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "name": "Reflection.java",
                                "content": "package com.stfl.misc;\n\nimport java.lang.reflect.Constructor;\n\npublic class Reflection {\n    public static Object get(String className, Object... args) {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.misc;",
                                    "import java.lang.reflect.Constructor;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class Reflection {\n    public static Object get(String className, Object... args) {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }\n}",
                                      "definition": "public class Reflection",
                                      "byte_span": [
                                        63,
                                        1202
                                      ],
                                      "start_point": [
                                        4,
                                        0
                                      ],
                                      "end_point": [
                                        33,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "Reflection",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            93,
                                            1200
                                          ],
                                          "original_string": "    public static Object get(String className, Object... args) {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public static",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "static"
                                            ],
                                            "comments": [],
                                            "return_type": "Object",
                                            "classes": []
                                          },
                                          "name": "get",
                                          "body": "                                                               {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }",
                                          "identifiers": "retValue c Class forName className args length retValue c newInstance args length oParam args length arg_i i arg_i args length arg_i i oParam i args arg_i constructor c getConstructor oParam paramObjs args length arg_i i arg_i args length arg_i i paramObjs i args arg_i retValue constructor newInstance paramObjs e e printStackTrace retValue",
                                          "signature": "    public static Object get(String className, Object... args)",
                                          "signature_woname": "    public static Object (String className, Object... args)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": []
                              },
                              {
                                "name": "Config.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.misc;\n\nimport com.stfl.network.proxy.IProxy;\nimport org.json.simple.JSONObject;\nimport org.json.simple.JSONValue;\nimport com.stfl.ss.AesCrypt;\n\n/**\n * Data class for configuration to bring up server\n */\npublic class Config {\n    private String _ipAddr;\n    private int _port;\n    private String _localIpAddr;\n    private int _localPort;\n    private String _method;\n    private String _password;\n    private String _logLevel;\n    private IProxy.TYPE _proxyType;\n\n    public Config() {\n        loadFromJson(\"\");\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }\n\n    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }\n\n    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }\n\n    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }\n\n    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }\n\n    public void setRemotePort(int value) {\n        _port = value;\n    }\n\n    public int getRemotePort() {\n        return _port;\n    }\n\n    public void setLocalPort(int value) {\n        _localPort = value;\n    }\n\n    public int getLocalPort() {\n        return _localPort;\n    }\n\n    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }\n\n    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }\n    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }\n\n    public void setMethod(String value) {\n        _method = value;\n    }\n\n    public String getMethod() {\n        return _method;\n    }\n\n    public void setPassword(String value) {\n        _password = value;\n    }\n\n    public String getPassword() {\n        return _password;\n    }\n\n    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }\n\n    public String getLogLevel() {\n        return _logLevel;\n    }\n\n    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }\n\n    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.misc;",
                                    "import com.stfl.network.proxy.IProxy;",
                                    "import org.json.simple.JSONObject;",
                                    "import org.json.simple.JSONValue;",
                                    "import com.stfl.ss.AesCrypt;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class Config {\n    private String _ipAddr;\n    private int _port;\n    private String _localIpAddr;\n    private int _localPort;\n    private String _method;\n    private String _password;\n    private String _logLevel;\n    private IProxy.TYPE _proxyType;\n\n    public Config() {\n        loadFromJson(\"\");\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }\n\n    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }\n\n    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }\n\n    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }\n\n    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }\n\n    public void setRemotePort(int value) {\n        _port = value;\n    }\n\n    public int getRemotePort() {\n        return _port;\n    }\n\n    public void setLocalPort(int value) {\n        _localPort = value;\n    }\n\n    public int getLocalPort() {\n        return _localPort;\n    }\n\n    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }\n\n    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }\n    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }\n\n    public void setMethod(String value) {\n        _method = value;\n    }\n\n    public String getMethod() {\n        return _method;\n    }\n\n    public void setPassword(String value) {\n        _password = value;\n    }\n\n    public String getPassword() {\n        return _password;\n    }\n\n    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }\n\n    public String getLogLevel() {\n        return _logLevel;\n    }\n\n    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }\n\n    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }\n}",
                                      "definition": "public class Config",
                                      "byte_span": [
                                        1735,
                                        5565
                                      ],
                                      "start_point": [
                                        41,
                                        0
                                      ],
                                      "end_point": [
                                        175,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "Config",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    private String _ipAddr;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "_ipAddr",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private int _port;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "int",
                                            "name": "_port",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private String _localIpAddr;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "_localIpAddr",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private int _localPort;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "int",
                                            "name": "_localPort",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private String _method;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "_method",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private String _password;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "_password",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private String _logLevel;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "String",
                                            "name": "_logLevel",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private IProxy.TYPE _proxyType;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "IProxy.TYPE",
                                            "name": "_proxyType",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            1998,
                                            2047
                                          ],
                                          "original_string": "    public Config() {\n        loadFromJson(\"\");\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "Config",
                                          "body": "                    {\n        loadFromJson(\"\");\n    }",
                                          "identifiers": "loadFromJson",
                                          "signature": "    public Config()",
                                          "signature_woname": "    public ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2053,
                                            2393
                                          ],
                                          "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "Config",
                                          "body": "                                                                                                              {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                          "identifiers": "_ipAddr ipAddr _port port _localIpAddr localIpAddr _localPort localPort _method method _password password _proxyType IProxy TYPE AUTO",
                                          "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password)",
                                          "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2399,
                                            2627
                                          ],
                                          "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "Config",
                                          "body": "                                                                                                                                {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                          "identifiers": "ipAddr port localIpAddr localPort method password _proxyType type",
                                          "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)",
                                          "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2633,
                                            2710
                                          ],
                                          "original_string": "    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setRemoteIpAddress",
                                          "body": "                                                 {\n        _ipAddr = value;\n    }",
                                          "identifiers": "_ipAddr value",
                                          "signature": "    public void setRemoteIpAddress(String value)",
                                          "signature_woname": "    public void (String value)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2716,
                                            2782
                                          ],
                                          "original_string": "    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "getRemoteIpAddress",
                                          "body": "                                       {\n        return _ipAddr;\n    }",
                                          "identifiers": "_ipAddr",
                                          "signature": "    public String getRemoteIpAddress()",
                                          "signature_woname": "    public String ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2788,
                                            2869
                                          ],
                                          "original_string": "    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setLocalIpAddress",
                                          "body": "                                                {\n        _localIpAddr = value;\n    }",
                                          "identifiers": "_localIpAddr value",
                                          "signature": "    public void setLocalIpAddress(String value)",
                                          "signature_woname": "    public void (String value)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2875,
                                            2945
                                          ],
                                          "original_string": "    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "getLocalIpAddress",
                                          "body": "                                      {\n        return _localIpAddr;\n    }",
                                          "identifiers": "_localIpAddr",
                                          "signature": "    public String getLocalIpAddress()",
                                          "signature_woname": "    public String ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2951,
                                            3018
                                          ],
                                          "original_string": "    public void setRemotePort(int value) {\n        _port = value;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setRemotePort",
                                          "body": "                                         {\n        _port = value;\n    }",
                                          "identifiers": "_port value",
                                          "signature": "    public void setRemotePort(int value)",
                                          "signature_woname": "    public void (int value)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3024,
                                            3080
                                          ],
                                          "original_string": "    public int getRemotePort() {\n        return _port;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "int",
                                            "classes": []
                                          },
                                          "name": "getRemotePort",
                                          "body": "                               {\n        return _port;\n    }",
                                          "identifiers": "_port",
                                          "signature": "    public int getRemotePort()",
                                          "signature_woname": "    public int ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3086,
                                            3157
                                          ],
                                          "original_string": "    public void setLocalPort(int value) {\n        _localPort = value;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setLocalPort",
                                          "body": "                                        {\n        _localPort = value;\n    }",
                                          "identifiers": "_localPort value",
                                          "signature": "    public void setLocalPort(int value)",
                                          "signature_woname": "    public void (int value)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3163,
                                            3223
                                          ],
                                          "original_string": "    public int getLocalPort() {\n        return _localPort;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "int",
                                            "classes": []
                                          },
                                          "name": "getLocalPort",
                                          "body": "                              {\n        return _localPort;\n    }",
                                          "identifiers": "_localPort",
                                          "signature": "    public int getLocalPort()",
                                          "signature_woname": "    public int ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3229,
                                            3599
                                          ],
                                          "original_string": "    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setProxyType",
                                          "body": "                                           {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                          "identifiers": "_proxyType IProxy TYPE AUTO value toLowerCase equals IProxy TYPE HTTP toString toLowerCase _proxyType IProxy TYPE HTTP value toLowerCase equals IProxy TYPE SOCKS5 toString toLowerCase _proxyType IProxy TYPE SOCKS5",
                                          "signature": "    public void setProxyType(String value)",
                                          "signature_woname": "    public void (String value)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3605,
                                            3684
                                          ],
                                          "original_string": "    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setProxyType",
                                          "body": "                                                {\n        _proxyType = value;\n    }",
                                          "identifiers": "_proxyType value",
                                          "signature": "    public void setProxyType(IProxy.TYPE value)",
                                          "signature_woname": "    public void (IProxy.TYPE value)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3689,
                                            3757
                                          ],
                                          "original_string": "    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "IProxy.TYPE",
                                            "classes": []
                                          },
                                          "name": "getProxyType",
                                          "body": "                                      {\n        return _proxyType;\n    }",
                                          "identifiers": "_proxyType",
                                          "signature": "    public IProxy.TYPE getProxyType()",
                                          "signature_woname": "    public IProxy.TYPE ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3763,
                                            3831
                                          ],
                                          "original_string": "    public void setMethod(String value) {\n        _method = value;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setMethod",
                                          "body": "                                        {\n        _method = value;\n    }",
                                          "identifiers": "_method value",
                                          "signature": "    public void setMethod(String value)",
                                          "signature_woname": "    public void (String value)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3837,
                                            3894
                                          ],
                                          "original_string": "    public String getMethod() {\n        return _method;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "getMethod",
                                          "body": "                              {\n        return _method;\n    }",
                                          "identifiers": "_method",
                                          "signature": "    public String getMethod()",
                                          "signature_woname": "    public String ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3900,
                                            3972
                                          ],
                                          "original_string": "    public void setPassword(String value) {\n        _password = value;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setPassword",
                                          "body": "                                          {\n        _password = value;\n    }",
                                          "identifiers": "_password value",
                                          "signature": "    public void setPassword(String value)",
                                          "signature_woname": "    public void (String value)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3978,
                                            4039
                                          ],
                                          "original_string": "    public String getPassword() {\n        return _password;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "getPassword",
                                          "body": "                                {\n        return _password;\n    }",
                                          "identifiers": "_password",
                                          "signature": "    public String getPassword()",
                                          "signature_woname": "    public String ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4045,
                                            4150
                                          ],
                                          "original_string": "    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setLogLevel",
                                          "body": "                                          {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                          "identifiers": "_logLevel value Log init getLogLevel",
                                          "signature": "    public void setLogLevel(String value)",
                                          "signature_woname": "    public void (String value)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4156,
                                            4217
                                          ],
                                          "original_string": "    public String getLogLevel() {\n        return _logLevel;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "getLogLevel",
                                          "body": "                                {\n        return _logLevel;\n    }",
                                          "identifiers": "_logLevel",
                                          "signature": "    public String getLogLevel()",
                                          "signature_woname": "    public String ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4223,
                                            5070
                                          ],
                                          "original_string": "    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "loadFromJson",
                                          "body": "                                             {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                          "identifiers": "jsonStr length jsonStr jObj JSONValue parse jsonStr _ipAddr jObj getOrDefault _port jObj getOrDefault intValue _localIpAddr jObj getOrDefault _localPort jObj getOrDefault intValue _method jObj getOrDefault AesCrypt CIPHER_AES_256_CFB _password jObj getOrDefault _logLevel jObj getOrDefault setProxyType jObj getOrDefault IProxy TYPE SOCKS5 toString toLowerCase setLogLevel _logLevel",
                                          "signature": "    public void loadFromJson(String jsonStr)",
                                          "signature_woname": "    public void (String jsonStr)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            5076,
                                            5563
                                          ],
                                          "original_string": "    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "String",
                                            "classes": []
                                          },
                                          "name": "saveToJson",
                                          "body": "                               {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                          "identifiers": "jObj jObj put _ipAddr jObj put _port jObj put _localIpAddr jObj put _localPort jObj put _method jObj put _password jObj put _proxyType toString toLowerCase jObj put _logLevel Util prettyPrintJson jObj",
                                          "signature": "    public String saveToJson()",
                                          "signature_woname": "    public String ()"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": [
                                  {
                                    "original_string": "public class AesCrypt extends CryptBase {\n\n    public final static String CIPHER_AES_128_CFB = \"aes-128-cfb\";\n    public final static String CIPHER_AES_192_CFB = \"aes-192-cfb\";\n    public final static String CIPHER_AES_256_CFB = \"aes-256-cfb\";\n    public final static String CIPHER_AES_128_OFB = \"aes-128-ofb\";\n    public final static String CIPHER_AES_192_OFB = \"aes-192-ofb\";\n    public final static String CIPHER_AES_256_OFB = \"aes-256-ofb\";\n\n    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_AES_128_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_128_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_OFB, AesCrypt.class.getName());\n\n        return ciphers;\n    }\n\n    public AesCrypt(String name, String password) {\n        super(name, password);\n    }\n\n    @Override\n    public int getKeyLength() {\n        if(_name.equals(CIPHER_AES_128_CFB) || _name.equals(CIPHER_AES_128_OFB)) {\n            return 16;\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB) || _name.equals(CIPHER_AES_192_OFB)) {\n            return 24;\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB) || _name.equals(CIPHER_AES_256_OFB)) {\n            return 32;\n        }\n\n        return 0;\n    }\n\n    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        AESFastEngine engine = new AESFastEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_AES_128_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_128_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }\n\n    @Override\n    public int getIVLength() {\n        return 16;\n    }\n\n    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }\n\n    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n\n    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }\n}",
                                    "definition": "public class AesCrypt extends CryptBase",
                                    "byte_span": [
                                      2049,
                                      5472
                                    ],
                                    "start_point": [
                                      49,
                                      0
                                    ],
                                    "end_point": [
                                      146,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "AesCrypt",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    public final static String CIPHER_AES_128_CFB = \"aes-128-cfb\";",
                                          "docstring": "",
                                          "modifiers": "public final static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "final",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "CIPHER_AES_128_CFB = \"aes-128-cfb\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public final static String CIPHER_AES_192_CFB = \"aes-192-cfb\";",
                                          "docstring": "",
                                          "modifiers": "public final static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "final",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "CIPHER_AES_192_CFB = \"aes-192-cfb\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public final static String CIPHER_AES_256_CFB = \"aes-256-cfb\";",
                                          "docstring": "",
                                          "modifiers": "public final static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "final",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "CIPHER_AES_256_CFB = \"aes-256-cfb\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public final static String CIPHER_AES_128_OFB = \"aes-128-ofb\";",
                                          "docstring": "",
                                          "modifiers": "public final static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "final",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "CIPHER_AES_128_OFB = \"aes-128-ofb\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public final static String CIPHER_AES_192_OFB = \"aes-192-ofb\";",
                                          "docstring": "",
                                          "modifiers": "public final static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "final",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "CIPHER_AES_192_OFB = \"aes-192-ofb\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public final static String CIPHER_AES_256_OFB = \"aes-256-ofb\";",
                                          "docstring": "",
                                          "modifiers": "public final static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "final",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "CIPHER_AES_256_OFB = \"aes-256-ofb\"",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2499,
                                          3035
                                        ],
                                        "original_string": "    public static Map<String, String> getCiphers() {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_AES_128_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_128_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_OFB, AesCrypt.class.getName());\n\n        return ciphers;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "Map<String, String>",
                                          "classes": []
                                        },
                                        "name": "getCiphers",
                                        "body": "                                                   {\n        Map<String, String> ciphers = new HashMap<>();\n        ciphers.put(CIPHER_AES_128_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_CFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_128_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_192_OFB, AesCrypt.class.getName());\n        ciphers.put(CIPHER_AES_256_OFB, AesCrypt.class.getName());\n\n        return ciphers;\n    }",
                                        "identifiers": "ciphers ciphers put CIPHER_AES_128_CFB getName ciphers put CIPHER_AES_192_CFB getName ciphers put CIPHER_AES_256_CFB getName ciphers put CIPHER_AES_128_OFB getName ciphers put CIPHER_AES_192_OFB getName ciphers put CIPHER_AES_256_OFB getName ciphers",
                                        "signature": "    public static Map<String, String> getCiphers()",
                                        "signature_woname": "    public static Map<String, String> ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3041,
                                          3125
                                        ],
                                        "original_string": "    public AesCrypt(String name, String password) {\n        super(name, password);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "AesCrypt",
                                        "body": "                                                  {\n        super(name, password);\n    }",
                                        "identifiers": "name password",
                                        "signature": "    public AesCrypt(String name, String password)",
                                        "signature_woname": "    public (String name, String password)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3131,
                                          3557
                                        ],
                                        "original_string": "    @Override\n    public int getKeyLength() {\n        if(_name.equals(CIPHER_AES_128_CFB) || _name.equals(CIPHER_AES_128_OFB)) {\n            return 16;\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB) || _name.equals(CIPHER_AES_192_OFB)) {\n            return 24;\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB) || _name.equals(CIPHER_AES_256_OFB)) {\n            return 32;\n        }\n\n        return 0;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    public",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getKeyLength",
                                        "body": "                              {\n        if(_name.equals(CIPHER_AES_128_CFB) || _name.equals(CIPHER_AES_128_OFB)) {\n            return 16;\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB) || _name.equals(CIPHER_AES_192_OFB)) {\n            return 24;\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB) || _name.equals(CIPHER_AES_256_OFB)) {\n            return 32;\n        }\n\n        return 0;\n    }",
                                        "identifiers": "_name equals CIPHER_AES_128_CFB _name equals CIPHER_AES_128_OFB _name equals CIPHER_AES_192_CFB _name equals CIPHER_AES_192_OFB _name equals CIPHER_AES_256_CFB _name equals CIPHER_AES_256_OFB",
                                        "signature": "    @Override\n    public int getKeyLength()",
                                        "signature_woname": "    @Override\n    public int ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3563,
                                          4667
                                        ],
                                        "original_string": "    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted) throws InvalidAlgorithmParameterException {\n        AESFastEngine engine = new AESFastEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_AES_128_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_128_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    protected",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "protected"
                                          ],
                                          "comments": [],
                                          "return_type": "StreamBlockCipher",
                                          "classes": []
                                        },
                                        "name": "getCipher",
                                        "body": "                                                                                                         {\n        AESFastEngine engine = new AESFastEngine();\n        StreamBlockCipher cipher;\n\n        if (_name.equals(CIPHER_AES_128_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_CFB)) {\n            cipher = new CFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_128_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_192_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else if (_name.equals(CIPHER_AES_256_OFB)) {\n            cipher = new OFBBlockCipher(engine, getIVLength() * 8);\n        }\n        else {\n            throw new InvalidAlgorithmParameterException(_name);\n        }\n\n        return cipher;\n    }",
                                        "identifiers": "engine cipher _name equals CIPHER_AES_128_CFB cipher engine getIVLength _name equals CIPHER_AES_192_CFB cipher engine getIVLength _name equals CIPHER_AES_256_CFB cipher engine getIVLength _name equals CIPHER_AES_128_OFB cipher engine getIVLength _name equals CIPHER_AES_192_OFB cipher engine getIVLength _name equals CIPHER_AES_256_OFB cipher engine getIVLength _name cipher",
                                        "signature": "    @Override\n    protected StreamBlockCipher getCipher(boolean isEncrypted)",
                                        "signature_woname": "    @Override\n    protected StreamBlockCipher (boolean isEncrypted)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4673,
                                          4738
                                        ],
                                        "original_string": "    @Override\n    public int getIVLength() {\n        return 16;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    public",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getIVLength",
                                        "body": "                             {\n        return 16;\n    }",
                                        "identifiers": "",
                                        "signature": "    @Override\n    public int getIVLength()",
                                        "signature_woname": "    @Override\n    public int ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4744,
                                          4856
                                        ],
                                        "original_string": "    @Override\n    protected SecretKey getKey() {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    protected",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "protected"
                                          ],
                                          "comments": [],
                                          "return_type": "SecretKey",
                                          "classes": []
                                        },
                                        "name": "getKey",
                                        "body": "                                 {\n        return new SecretKeySpec(_ssKey.getEncoded(), \"AES\");\n    }",
                                        "identifiers": "_ssKey getEncoded",
                                        "signature": "    @Override\n    protected SecretKey getKey()",
                                        "signature_woname": "    @Override\n    protected SecretKey ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4862,
                                          5163
                                        ],
                                        "original_string": "    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    protected",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "protected"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "_encrypt",
                                        "body": "                                                                       {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = encCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                        "identifiers": "noBytesProcessed buffer data length noBytesProcessed encCipher processBytes data data length buffer stream write buffer noBytesProcessed",
                                        "signature": "    @Override\n    protected void _encrypt(byte[] data, ByteArrayOutputStream stream)",
                                        "signature_woname": "    @Override\n    protected void (byte[] data, ByteArrayOutputStream stream)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          5169,
                                          5470
                                        ],
                                        "original_string": "    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream) {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    protected",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "protected"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "_decrypt",
                                        "body": "                                                                       {\n        int noBytesProcessed;\n        byte[] buffer = new byte[data.length];\n\n        noBytesProcessed = decCipher.processBytes(data, 0, data.length, buffer, 0);\n        stream.write(buffer, 0, noBytesProcessed);\n    }",
                                        "identifiers": "noBytesProcessed buffer data length noBytesProcessed decCipher processBytes data data length buffer stream write buffer noBytesProcessed",
                                        "signature": "    @Override\n    protected void _decrypt(byte[] data, ByteArrayOutputStream stream)",
                                        "signature_woname": "    @Override\n    protected void (byte[] data, ByteArrayOutputStream stream)"
                                      }
                                    ]
                                  }
                                ]
                              }
                            ],
                            "subdirs": []
                          },
                          {
                            "dir": "ui",
                            "files": [
                              {
                                "name": "MainLayoutController.java",
                                "content": "package com.stfl.ui;\n\nimport com.stfl.Constant;\nimport com.stfl.MainGui;\nimport com.stfl.misc.Config;\nimport com.stfl.misc.UTF8Control;\nimport com.stfl.misc.Util;\nimport com.stfl.network.IServer;\nimport com.stfl.network.NioLocalServer;\nimport com.stfl.network.proxy.IProxy;\nimport com.stfl.network.proxy.ProxyFactory;\nimport com.stfl.ss.CryptFactory;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport javafx.fxml.FXML;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Scene;\nimport javafx.scene.control.*;\nimport javafx.scene.image.Image;\nimport javafx.scene.layout.Pane;\nimport javafx.stage.Stage;\n\nimport java.io.IOException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.util.ResourceBundle;\nimport java.util.logging.Logger;\n\n\npublic class MainLayoutController {\n    @FXML\n    private TextField txtServerIP;\n    @FXML\n    private TextField txtServerPort;\n    @FXML\n    private ComboBox cboCipher;\n    @FXML\n    private TextField txtPassword;\n    @FXML\n    private TextField txtLocalPort;\n    @FXML\n    private ComboBox cboProxyType;\n    @FXML\n    private Button btnStart;\n    @FXML\n    private Button btnStop;\n    @FXML\n    private Button btnLog;\n    @FXML\n    private Button btnClose;\n\n    private Logger logger = Logger.getLogger(MainLayoutController.class.getName());\n    private MainGui gui;\n    private IServer server;\n    private Stage logStage;\n    private Config config;\n\n    @FXML\n    private void initialize() {\n        // set cipher options\n        ObservableList<String> ciphers = FXCollections.observableArrayList();\n        ciphers.addAll(CryptFactory.getSupportedCiphers());\n        cboCipher.setItems(ciphers);\n\n        // set proxy options\n        ObservableList<IProxy.TYPE> proxyTypes = FXCollections.observableArrayList();\n        proxyTypes.addAll(ProxyFactory.getSupportedProxyTypes());\n        cboProxyType.setItems(proxyTypes);\n\n        // prepare configuration\n        config = new Config();\n        config.loadFromJson(Util.getFileContent(Constant.CONF_FILE));\n        txtServerIP.setText(config.getRemoteIpAddress());\n        txtServerPort.setText(String.valueOf(config.getRemotePort()));\n        txtLocalPort.setText(String.valueOf(config.getLocalPort()));\n        txtPassword.setText(config.getPassword());\n        cboCipher.setValue(config.getMethod());\n        cboProxyType.setValue(config.getProxyType());\n\n        // prepare log window\n        Stage stage = new Stage();\n        try {\n            FXMLLoader logLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/LogLayout.fxml\"));\n            logLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane logLayout = logLayoutLoader.load();\n            Scene logScene = new Scene(logLayout);\n            stage.setTitle(\"Log\");\n            stage.setScene(logScene);\n            stage.setResizable(false);\n            stage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n\n            LogLayoutController controller = logLayoutLoader.getController();\n            controller.setStage(stage);\n            logStage = stage;\n        } catch (IOException e) {\n            logger.warning(\"Unable to load ICON: \" + e.toString());\n        }\n\n        btnStop.setDisable(true);\n    }\n\n    @FXML\n    private void handleStart() {\n        boolean isValidated = false;\n        do {\n            if (!txtServerIP.getText().matches(\"[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid IP address\", Alert.AlertType.ERROR);\n                break;\n            }\n            String ip = txtServerIP.getText();\n            if (!txtServerPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int port = Integer.parseInt(txtServerPort.getText());\n\n            String method = (String) cboCipher.getValue();\n            if (txtPassword.getText().length() == 0) {\n                showAlert(Constant.PROG_NAME, \"Please specified password\", Alert.AlertType.ERROR);\n                break;\n            }\n            String password = txtPassword.getText();\n            IProxy.TYPE type = (IProxy.TYPE) cboProxyType.getValue();\n            if (!txtLocalPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int localPort = Integer.parseInt(txtLocalPort.getText());\n\n            // create config\n            config.setRemoteIpAddress(ip);\n            config.setRemotePort(port);\n            config.setLocalIpAddress(\"127.0.0.1\");\n            config.setLocalPort(localPort);\n            config.setMethod(method);\n            config.setPassword(password);\n            config.setProxyType(type);\n            Util.saveFile(Constant.CONF_FILE, config.saveToJson());\n\n            isValidated = true;\n        } while (false);\n\n        if (!isValidated)\n            return;\n\n        // start start\n        try {\n            server = new NioLocalServer(config);\n            Thread t = new Thread(server);\n            t.setDaemon(true);\n            t.start();\n            String message = String.format(\"(Connected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.setTooltip(message);\n            gui.showNotification(message);\n        } catch (IOException | InvalidAlgorithmParameterException e) {\n            logger.warning(\"Unable to start server: \" + e.toString());\n        }\n        btnStop.setDisable(false);\n        btnStart.setDisable(true);\n    }\n\n    @FXML\n    private void handleStop() {\n        if (server != null) {\n            server.close();\n            String message = String.format(\"(Disconnected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.showNotification(message);\n            gui.setTooltip(\"Not Connected\");\n        }\n\n        btnStop.setDisable(true);\n        btnStart.setDisable(false);\n    }\n\n    @FXML\n    private void handleLog() {\n        logStage.show();\n    }\n\n    @FXML\n    private void handleClose() {\n        gui.hide();\n    }\n\n    public void setMainGui(MainGui gui) {\n        this.gui = gui;\n    }\n\n    public void closeServer() {\n        handleStop();\n    }\n\n    private boolean validationInput(String pattern, String text) {\n        return false;\n    }\n\n    private void showAlert(String title, String message, Alert.AlertType type) {\n        Alert a = new Alert(type);\n        a.setTitle(title);\n        a.setHeaderText(type.name());\n        a.setResizable(false);\n        a.setContentText(message);\n        a.showAndWait();\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.ui;",
                                    "import com.stfl.Constant;",
                                    "import com.stfl.MainGui;",
                                    "import com.stfl.misc.Config;",
                                    "import com.stfl.misc.UTF8Control;",
                                    "import com.stfl.misc.Util;",
                                    "import com.stfl.network.IServer;",
                                    "import com.stfl.network.NioLocalServer;",
                                    "import com.stfl.network.proxy.IProxy;",
                                    "import com.stfl.network.proxy.ProxyFactory;",
                                    "import com.stfl.ss.CryptFactory;",
                                    "import javafx.collections.FXCollections;",
                                    "import javafx.collections.ObservableList;",
                                    "import javafx.fxml.FXML;",
                                    "import javafx.fxml.FXMLLoader;",
                                    "import javafx.scene.Scene;",
                                    "import javafx.scene.control.*;",
                                    "import javafx.scene.image.Image;",
                                    "import javafx.scene.layout.Pane;",
                                    "import javafx.stage.Stage;",
                                    "import java.io.IOException;",
                                    "import java.security.InvalidAlgorithmParameterException;",
                                    "import java.util.ResourceBundle;",
                                    "import java.util.logging.Logger;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class MainLayoutController {\n    @FXML\n    private TextField txtServerIP;\n    @FXML\n    private TextField txtServerPort;\n    @FXML\n    private ComboBox cboCipher;\n    @FXML\n    private TextField txtPassword;\n    @FXML\n    private TextField txtLocalPort;\n    @FXML\n    private ComboBox cboProxyType;\n    @FXML\n    private Button btnStart;\n    @FXML\n    private Button btnStop;\n    @FXML\n    private Button btnLog;\n    @FXML\n    private Button btnClose;\n\n    private Logger logger = Logger.getLogger(MainLayoutController.class.getName());\n    private MainGui gui;\n    private IServer server;\n    private Stage logStage;\n    private Config config;\n\n    @FXML\n    private void initialize() {\n        // set cipher options\n        ObservableList<String> ciphers = FXCollections.observableArrayList();\n        ciphers.addAll(CryptFactory.getSupportedCiphers());\n        cboCipher.setItems(ciphers);\n\n        // set proxy options\n        ObservableList<IProxy.TYPE> proxyTypes = FXCollections.observableArrayList();\n        proxyTypes.addAll(ProxyFactory.getSupportedProxyTypes());\n        cboProxyType.setItems(proxyTypes);\n\n        // prepare configuration\n        config = new Config();\n        config.loadFromJson(Util.getFileContent(Constant.CONF_FILE));\n        txtServerIP.setText(config.getRemoteIpAddress());\n        txtServerPort.setText(String.valueOf(config.getRemotePort()));\n        txtLocalPort.setText(String.valueOf(config.getLocalPort()));\n        txtPassword.setText(config.getPassword());\n        cboCipher.setValue(config.getMethod());\n        cboProxyType.setValue(config.getProxyType());\n\n        // prepare log window\n        Stage stage = new Stage();\n        try {\n            FXMLLoader logLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/LogLayout.fxml\"));\n            logLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane logLayout = logLayoutLoader.load();\n            Scene logScene = new Scene(logLayout);\n            stage.setTitle(\"Log\");\n            stage.setScene(logScene);\n            stage.setResizable(false);\n            stage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n\n            LogLayoutController controller = logLayoutLoader.getController();\n            controller.setStage(stage);\n            logStage = stage;\n        } catch (IOException e) {\n            logger.warning(\"Unable to load ICON: \" + e.toString());\n        }\n\n        btnStop.setDisable(true);\n    }\n\n    @FXML\n    private void handleStart() {\n        boolean isValidated = false;\n        do {\n            if (!txtServerIP.getText().matches(\"[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid IP address\", Alert.AlertType.ERROR);\n                break;\n            }\n            String ip = txtServerIP.getText();\n            if (!txtServerPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int port = Integer.parseInt(txtServerPort.getText());\n\n            String method = (String) cboCipher.getValue();\n            if (txtPassword.getText().length() == 0) {\n                showAlert(Constant.PROG_NAME, \"Please specified password\", Alert.AlertType.ERROR);\n                break;\n            }\n            String password = txtPassword.getText();\n            IProxy.TYPE type = (IProxy.TYPE) cboProxyType.getValue();\n            if (!txtLocalPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int localPort = Integer.parseInt(txtLocalPort.getText());\n\n            // create config\n            config.setRemoteIpAddress(ip);\n            config.setRemotePort(port);\n            config.setLocalIpAddress(\"127.0.0.1\");\n            config.setLocalPort(localPort);\n            config.setMethod(method);\n            config.setPassword(password);\n            config.setProxyType(type);\n            Util.saveFile(Constant.CONF_FILE, config.saveToJson());\n\n            isValidated = true;\n        } while (false);\n\n        if (!isValidated)\n            return;\n\n        // start start\n        try {\n            server = new NioLocalServer(config);\n            Thread t = new Thread(server);\n            t.setDaemon(true);\n            t.start();\n            String message = String.format(\"(Connected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.setTooltip(message);\n            gui.showNotification(message);\n        } catch (IOException | InvalidAlgorithmParameterException e) {\n            logger.warning(\"Unable to start server: \" + e.toString());\n        }\n        btnStop.setDisable(false);\n        btnStart.setDisable(true);\n    }\n\n    @FXML\n    private void handleStop() {\n        if (server != null) {\n            server.close();\n            String message = String.format(\"(Disconnected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.showNotification(message);\n            gui.setTooltip(\"Not Connected\");\n        }\n\n        btnStop.setDisable(true);\n        btnStart.setDisable(false);\n    }\n\n    @FXML\n    private void handleLog() {\n        logStage.show();\n    }\n\n    @FXML\n    private void handleClose() {\n        gui.hide();\n    }\n\n    public void setMainGui(MainGui gui) {\n        this.gui = gui;\n    }\n\n    public void closeServer() {\n        handleStop();\n    }\n\n    private boolean validationInput(String pattern, String text) {\n        return false;\n    }\n\n    private void showAlert(String title, String message, Alert.AlertType type) {\n        Alert a = new Alert(type);\n        a.setTitle(title);\n        a.setHeaderText(type.name());\n        a.setResizable(false);\n        a.setContentText(message);\n        a.showAndWait();\n    }\n}",
                                      "definition": "public class MainLayoutController",
                                      "byte_span": [
                                        795,
                                        6779
                                      ],
                                      "start_point": [
                                        28,
                                        0
                                      ],
                                      "end_point": [
                                        203,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "MainLayoutController",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    @FXML\n    private TextField txtServerIP;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "TextField",
                                            "name": "txtServerIP",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    @FXML\n    private TextField txtServerPort;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "TextField",
                                            "name": "txtServerPort",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    @FXML\n    private ComboBox cboCipher;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "ComboBox",
                                            "name": "cboCipher",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    @FXML\n    private TextField txtPassword;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "TextField",
                                            "name": "txtPassword",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    @FXML\n    private TextField txtLocalPort;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "TextField",
                                            "name": "txtLocalPort",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    @FXML\n    private ComboBox cboProxyType;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "ComboBox",
                                            "name": "cboProxyType",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    @FXML\n    private Button btnStart;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Button",
                                            "name": "btnStart",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    @FXML\n    private Button btnStop;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Button",
                                            "name": "btnStop",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    @FXML\n    private Button btnLog;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Button",
                                            "name": "btnLog",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    @FXML\n    private Button btnClose;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Button",
                                            "name": "btnClose",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private Logger logger = Logger.getLogger(MainLayoutController.class.getName());",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Logger",
                                            "name": "logger = Logger.getLogger(MainLayoutController.class.getName())",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private MainGui gui;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "MainGui",
                                            "name": "gui",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private IServer server;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "IServer",
                                            "name": "server",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private Stage logStage;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Stage",
                                            "name": "logStage",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private Config config;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Config",
                                            "name": "config",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            1452,
                                            3358
                                          ],
                                          "original_string": "    @FXML\n    private void initialize() {\n        // set cipher options\n        ObservableList<String> ciphers = FXCollections.observableArrayList();\n        ciphers.addAll(CryptFactory.getSupportedCiphers());\n        cboCipher.setItems(ciphers);\n\n        // set proxy options\n        ObservableList<IProxy.TYPE> proxyTypes = FXCollections.observableArrayList();\n        proxyTypes.addAll(ProxyFactory.getSupportedProxyTypes());\n        cboProxyType.setItems(proxyTypes);\n\n        // prepare configuration\n        config = new Config();\n        config.loadFromJson(Util.getFileContent(Constant.CONF_FILE));\n        txtServerIP.setText(config.getRemoteIpAddress());\n        txtServerPort.setText(String.valueOf(config.getRemotePort()));\n        txtLocalPort.setText(String.valueOf(config.getLocalPort()));\n        txtPassword.setText(config.getPassword());\n        cboCipher.setValue(config.getMethod());\n        cboProxyType.setValue(config.getProxyType());\n\n        // prepare log window\n        Stage stage = new Stage();\n        try {\n            FXMLLoader logLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/LogLayout.fxml\"));\n            logLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane logLayout = logLayoutLoader.load();\n            Scene logScene = new Scene(logLayout);\n            stage.setTitle(\"Log\");\n            stage.setScene(logScene);\n            stage.setResizable(false);\n            stage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n\n            LogLayoutController controller = logLayoutLoader.getController();\n            controller.setStage(stage);\n            logStage = stage;\n        } catch (IOException e) {\n            logger.warning(\"Unable to load ICON: \" + e.toString());\n        }\n\n        btnStop.setDisable(true);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "initialize",
                                          "body": "                              {\n        // set cipher options\n        ObservableList<String> ciphers = FXCollections.observableArrayList();\n        ciphers.addAll(CryptFactory.getSupportedCiphers());\n        cboCipher.setItems(ciphers);\n\n        // set proxy options\n        ObservableList<IProxy.TYPE> proxyTypes = FXCollections.observableArrayList();\n        proxyTypes.addAll(ProxyFactory.getSupportedProxyTypes());\n        cboProxyType.setItems(proxyTypes);\n\n        // prepare configuration\n        config = new Config();\n        config.loadFromJson(Util.getFileContent(Constant.CONF_FILE));\n        txtServerIP.setText(config.getRemoteIpAddress());\n        txtServerPort.setText(String.valueOf(config.getRemotePort()));\n        txtLocalPort.setText(String.valueOf(config.getLocalPort()));\n        txtPassword.setText(config.getPassword());\n        cboCipher.setValue(config.getMethod());\n        cboProxyType.setValue(config.getProxyType());\n\n        // prepare log window\n        Stage stage = new Stage();\n        try {\n            FXMLLoader logLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/LogLayout.fxml\"));\n            logLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane logLayout = logLayoutLoader.load();\n            Scene logScene = new Scene(logLayout);\n            stage.setTitle(\"Log\");\n            stage.setScene(logScene);\n            stage.setResizable(false);\n            stage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n\n            LogLayoutController controller = logLayoutLoader.getController();\n            controller.setStage(stage);\n            logStage = stage;\n        } catch (IOException e) {\n            logger.warning(\"Unable to load ICON: \" + e.toString());\n        }\n\n        btnStop.setDisable(true);\n    }",
                                          "identifiers": "ciphers FXCollections observableArrayList ciphers addAll CryptFactory getSupportedCiphers cboCipher setItems ciphers proxyTypes FXCollections observableArrayList proxyTypes addAll ProxyFactory getSupportedProxyTypes cboProxyType setItems proxyTypes config config loadFromJson Util getFileContent Constant CONF_FILE txtServerIP setText config getRemoteIpAddress txtServerPort setText String valueOf config getRemotePort txtLocalPort setText String valueOf config getLocalPort txtPassword setText config getPassword cboCipher setValue config getMethod cboProxyType setValue config getProxyType stage logLayoutLoader getResource logLayoutLoader setResources ResourceBundle getBundle Constant LOCALE logLayout logLayoutLoader load logScene logLayout stage setTitle stage setScene logScene stage setResizable stage getIcons add getResource toString controller logLayoutLoader getController controller setStage stage logStage stage e logger warning e toString btnStop setDisable",
                                          "signature": "    @FXML\n    private void initialize()",
                                          "signature_woname": "    @FXML\n    private void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3364,
                                            5721
                                          ],
                                          "original_string": "    @FXML\n    private void handleStart() {\n        boolean isValidated = false;\n        do {\n            if (!txtServerIP.getText().matches(\"[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid IP address\", Alert.AlertType.ERROR);\n                break;\n            }\n            String ip = txtServerIP.getText();\n            if (!txtServerPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int port = Integer.parseInt(txtServerPort.getText());\n\n            String method = (String) cboCipher.getValue();\n            if (txtPassword.getText().length() == 0) {\n                showAlert(Constant.PROG_NAME, \"Please specified password\", Alert.AlertType.ERROR);\n                break;\n            }\n            String password = txtPassword.getText();\n            IProxy.TYPE type = (IProxy.TYPE) cboProxyType.getValue();\n            if (!txtLocalPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int localPort = Integer.parseInt(txtLocalPort.getText());\n\n            // create config\n            config.setRemoteIpAddress(ip);\n            config.setRemotePort(port);\n            config.setLocalIpAddress(\"127.0.0.1\");\n            config.setLocalPort(localPort);\n            config.setMethod(method);\n            config.setPassword(password);\n            config.setProxyType(type);\n            Util.saveFile(Constant.CONF_FILE, config.saveToJson());\n\n            isValidated = true;\n        } while (false);\n\n        if (!isValidated)\n            return;\n\n        // start start\n        try {\n            server = new NioLocalServer(config);\n            Thread t = new Thread(server);\n            t.setDaemon(true);\n            t.start();\n            String message = String.format(\"(Connected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.setTooltip(message);\n            gui.showNotification(message);\n        } catch (IOException | InvalidAlgorithmParameterException e) {\n            logger.warning(\"Unable to start server: \" + e.toString());\n        }\n        btnStop.setDisable(false);\n        btnStart.setDisable(true);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "handleStart",
                                          "body": "                               {\n        boolean isValidated = false;\n        do {\n            if (!txtServerIP.getText().matches(\"[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}.[0-9]{1,4}\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid IP address\", Alert.AlertType.ERROR);\n                break;\n            }\n            String ip = txtServerIP.getText();\n            if (!txtServerPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int port = Integer.parseInt(txtServerPort.getText());\n\n            String method = (String) cboCipher.getValue();\n            if (txtPassword.getText().length() == 0) {\n                showAlert(Constant.PROG_NAME, \"Please specified password\", Alert.AlertType.ERROR);\n                break;\n            }\n            String password = txtPassword.getText();\n            IProxy.TYPE type = (IProxy.TYPE) cboProxyType.getValue();\n            if (!txtLocalPort.getText().matches(\"[0-9]+\")) {\n                showAlert(Constant.PROG_NAME, \"Invalid Port\", Alert.AlertType.ERROR);\n                break;\n            }\n            int localPort = Integer.parseInt(txtLocalPort.getText());\n\n            // create config\n            config.setRemoteIpAddress(ip);\n            config.setRemotePort(port);\n            config.setLocalIpAddress(\"127.0.0.1\");\n            config.setLocalPort(localPort);\n            config.setMethod(method);\n            config.setPassword(password);\n            config.setProxyType(type);\n            Util.saveFile(Constant.CONF_FILE, config.saveToJson());\n\n            isValidated = true;\n        } while (false);\n\n        if (!isValidated)\n            return;\n\n        // start start\n        try {\n            server = new NioLocalServer(config);\n            Thread t = new Thread(server);\n            t.setDaemon(true);\n            t.start();\n            String message = String.format(\"(Connected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.setTooltip(message);\n            gui.showNotification(message);\n        } catch (IOException | InvalidAlgorithmParameterException e) {\n            logger.warning(\"Unable to start server: \" + e.toString());\n        }\n        btnStop.setDisable(false);\n        btnStart.setDisable(true);\n    }",
                                          "identifiers": "isValidated txtServerIP getText matches showAlert Constant PROG_NAME Alert AlertType ERROR ip txtServerIP getText txtServerPort getText matches showAlert Constant PROG_NAME Alert AlertType ERROR port Integer parseInt txtServerPort getText method cboCipher getValue txtPassword getText length showAlert Constant PROG_NAME Alert AlertType ERROR password txtPassword getText type cboProxyType getValue txtLocalPort getText matches showAlert Constant PROG_NAME Alert AlertType ERROR localPort Integer parseInt txtLocalPort getText config setRemoteIpAddress ip config setRemotePort port config setLocalIpAddress config setLocalPort localPort config setMethod method config setPassword password config setProxyType type Util saveFile Constant CONF_FILE config saveToJson isValidated isValidated server config t server t setDaemon t start message String format config getRemoteIpAddress config getRemotePort gui setTooltip message gui showNotification message e logger warning e toString btnStop setDisable btnStart setDisable",
                                          "signature": "    @FXML\n    private void handleStart()",
                                          "signature_woname": "    @FXML\n    private void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            5727,
                                            6125
                                          ],
                                          "original_string": "    @FXML\n    private void handleStop() {\n        if (server != null) {\n            server.close();\n            String message = String.format(\"(Disconnected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.showNotification(message);\n            gui.setTooltip(\"Not Connected\");\n        }\n\n        btnStop.setDisable(true);\n        btnStart.setDisable(false);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "handleStop",
                                          "body": "                              {\n        if (server != null) {\n            server.close();\n            String message = String.format(\"(Disconnected) Server %s:%d\", config.getRemoteIpAddress(), config.getRemotePort());\n            gui.showNotification(message);\n            gui.setTooltip(\"Not Connected\");\n        }\n\n        btnStop.setDisable(true);\n        btnStart.setDisable(false);\n    }",
                                          "identifiers": "server server close message String format config getRemoteIpAddress config getRemotePort gui showNotification message gui setTooltip btnStop setDisable btnStart setDisable",
                                          "signature": "    @FXML\n    private void handleStop()",
                                          "signature_woname": "    @FXML\n    private void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            6131,
                                            6198
                                          ],
                                          "original_string": "    @FXML\n    private void handleLog() {\n        logStage.show();\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "handleLog",
                                          "body": "                             {\n        logStage.show();\n    }",
                                          "identifiers": "logStage show",
                                          "signature": "    @FXML\n    private void handleLog()",
                                          "signature_woname": "    @FXML\n    private void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            6204,
                                            6268
                                          ],
                                          "original_string": "    @FXML\n    private void handleClose() {\n        gui.hide();\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "handleClose",
                                          "body": "                               {\n        gui.hide();\n    }",
                                          "identifiers": "gui hide",
                                          "signature": "    @FXML\n    private void handleClose()",
                                          "signature_woname": "    @FXML\n    private void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            6274,
                                            6341
                                          ],
                                          "original_string": "    public void setMainGui(MainGui gui) {\n        this.gui = gui;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setMainGui",
                                          "body": "                                        {\n        this.gui = gui;\n    }",
                                          "identifiers": "gui gui",
                                          "signature": "    public void setMainGui(MainGui gui)",
                                          "signature_woname": "    public void (MainGui gui)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            6347,
                                            6402
                                          ],
                                          "original_string": "    public void closeServer() {\n        handleStop();\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "closeServer",
                                          "body": "                              {\n        handleStop();\n    }",
                                          "identifiers": "handleStop",
                                          "signature": "    public void closeServer()",
                                          "signature_woname": "    public void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            6408,
                                            6498
                                          ],
                                          "original_string": "    private boolean validationInput(String pattern, String text) {\n        return false;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "boolean",
                                            "classes": []
                                          },
                                          "name": "validationInput",
                                          "body": "                                                                 {\n        return false;\n    }",
                                          "identifiers": "",
                                          "signature": "    private boolean validationInput(String pattern, String text)",
                                          "signature_woname": "    private boolean (String pattern, String text)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            6504,
                                            6777
                                          ],
                                          "original_string": "    private void showAlert(String title, String message, Alert.AlertType type) {\n        Alert a = new Alert(type);\n        a.setTitle(title);\n        a.setHeaderText(type.name());\n        a.setResizable(false);\n        a.setContentText(message);\n        a.showAndWait();\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "showAlert",
                                          "body": "                                                                               {\n        Alert a = new Alert(type);\n        a.setTitle(title);\n        a.setHeaderText(type.name());\n        a.setResizable(false);\n        a.setContentText(message);\n        a.showAndWait();\n    }",
                                          "identifiers": "a type a setTitle title a setHeaderText type name a setResizable a setContentText message a showAndWait",
                                          "signature": "    private void showAlert(String title, String message, Alert.AlertType type)",
                                          "signature_woname": "    private void (String title, String message, Alert.AlertType type)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": [
                                  {
                                    "original_string": "public class Constant {\n    public static final String PROG_NAME = \"shadowsocks-java\";\n    public static final String VERSION = \"0.2\";\n    public static final int BUFFER_SIZE = 16384;\n    public static final String CONF_FILE = \"config.json\";\n    public static final Locale LOCALE = Locale.getDefault();\n}",
                                    "definition": "public class Constant",
                                    "byte_span": [
                                      45,
                                      349
                                    ],
                                    "start_point": [
                                      4,
                                      0
                                    ],
                                    "end_point": [
                                      10,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Constant",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    public static final String PROG_NAME = \"shadowsocks-java\";",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "PROG_NAME = \"shadowsocks-java\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final String VERSION = \"0.2\";",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "VERSION = \"0.2\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final int BUFFER_SIZE = 16384;",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "BUFFER_SIZE = 16384",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final String CONF_FILE = \"config.json\";",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "CONF_FILE = \"config.json\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final Locale LOCALE = Locale.getDefault();",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "Locale",
                                          "name": "LOCALE = Locale.getDefault()",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": []
                                  },
                                  {
                                    "original_string": "public class MainGui extends Application {\n    private static Logger logger = Logger.getLogger(MainGui.class.getName());\n    private Stage primaryStage;\n    private Scene rootScene;\n    private MainLayoutController controller;\n    private TrayIcon trayIcon;\n\n    @Override\n    public void start(Stage primaryStage) throws Exception {\n\n        Platform.setImplicitExit(false);\n        this.primaryStage = primaryStage;\n        this.primaryStage.setTitle(\"Server Configuration\");\n\n        try {\n            // Load the root layout from the fxml file\n            FXMLLoader mainLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/MainLayout.fxml\"));\n            mainLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane rootLayout = mainLayoutLoader.load();\n\n            rootScene = new Scene(rootLayout);\n            primaryStage.setScene(rootScene);\n            primaryStage.setResizable(false);\n\n            controller = mainLayoutLoader.getController();\n            controller.setMainGui(this);\n\n            addToTray();\n\n            primaryStage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n            primaryStage.show();\n        } catch (IOException e) {\n            // Exception gets thrown if the fxml file could not be loaded\n            e.printStackTrace();\n        }\n    }\n\n\n    private void addToTray() {\n        // ensure awt is initialized\n        java.awt.Toolkit.getDefaultToolkit();\n\n        // make sure system tray is supported\n        if (!java.awt.SystemTray.isSupported()) {\n            logger.warning(\"No system tray support!\");\n        }\n\n        final java.awt.SystemTray tray = java.awt.SystemTray.getSystemTray();\n        try {\n\n            java.awt.Image image = ImageIO.read(MainGui.class.getResource(\"/resources/image/icon.png\"));\n            trayIcon = new TrayIcon(image);\n            trayIcon.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            primaryStage.show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem openItem = new java.awt.MenuItem(\"Configuration\");\n            openItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem exitItem = new java.awt.MenuItem(\"Exit\");\n            exitItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    controller.closeServer();\n                    Platform.exit();\n                    tray.remove(trayIcon);\n                }\n            });\n\n            PopupMenu popup = new PopupMenu();\n            popup.add(openItem);\n            popup.addSeparator();\n            popup.add(exitItem);\n            trayIcon.setPopupMenu(popup);\n            trayIcon.setToolTip(\"Not Connected\");\n            tray.add(trayIcon);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (AWTException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void show() {\n        primaryStage.show();\n    }\n\n    public void hide() {\n        primaryStage.hide();\n    }\n\n    public void setTooltip(String message) {\n        if (trayIcon != null) {\n            trayIcon.setToolTip(message);\n        }\n    }\n\n    public void showNotification(String message) {\n        trayIcon.displayMessage(\n                \"shadowsocks-java\",\n                message,\n                java.awt.TrayIcon.MessageType.INFO\n        );\n    }\n}",
                                    "definition": "public class MainGui extends Application",
                                    "byte_span": [
                                      538,
                                      4662
                                    ],
                                    "start_point": [
                                      20,
                                      0
                                    ],
                                    "end_point": [
                                      142,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "MainGui",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    private static Logger logger = Logger.getLogger(MainGui.class.getName());",
                                          "docstring": "",
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "Logger",
                                          "name": "logger = Logger.getLogger(MainGui.class.getName())",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private Stage primaryStage;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "Stage",
                                          "name": "primaryStage",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private Scene rootScene;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "Scene",
                                          "name": "rootScene",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private MainLayoutController controller;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "MainLayoutController",
                                          "name": "controller",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private TrayIcon trayIcon;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "TrayIcon",
                                          "name": "trayIcon",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          801,
                                          1963
                                        ],
                                        "original_string": "    @Override\n    public void start(Stage primaryStage) throws Exception {\n\n        Platform.setImplicitExit(false);\n        this.primaryStage = primaryStage;\n        this.primaryStage.setTitle(\"Server Configuration\");\n\n        try {\n            // Load the root layout from the fxml file\n            FXMLLoader mainLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/MainLayout.fxml\"));\n            mainLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane rootLayout = mainLayoutLoader.load();\n\n            rootScene = new Scene(rootLayout);\n            primaryStage.setScene(rootScene);\n            primaryStage.setResizable(false);\n\n            controller = mainLayoutLoader.getController();\n            controller.setMainGui(this);\n\n            addToTray();\n\n            primaryStage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n            primaryStage.show();\n        } catch (IOException e) {\n            // Exception gets thrown if the fxml file could not be loaded\n            e.printStackTrace();\n        }\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    public",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "start",
                                        "body": "                                                           {\n\n        Platform.setImplicitExit(false);\n        this.primaryStage = primaryStage;\n        this.primaryStage.setTitle(\"Server Configuration\");\n\n        try {\n            // Load the root layout from the fxml file\n            FXMLLoader mainLayoutLoader = new FXMLLoader(MainGui.class.getResource(\"/resources/ui/MainLayout.fxml\"));\n            mainLayoutLoader.setResources(ResourceBundle.getBundle(\"resources.bundle.ui\", Constant.LOCALE, new UTF8Control()));\n            Pane rootLayout = mainLayoutLoader.load();\n\n            rootScene = new Scene(rootLayout);\n            primaryStage.setScene(rootScene);\n            primaryStage.setResizable(false);\n\n            controller = mainLayoutLoader.getController();\n            controller.setMainGui(this);\n\n            addToTray();\n\n            primaryStage.getIcons().add(new Image(MainGui.class.getResource(\"/resources/image/icon.png\").toString()));\n            primaryStage.show();\n        } catch (IOException e) {\n            // Exception gets thrown if the fxml file could not be loaded\n            e.printStackTrace();\n        }\n    }",
                                        "identifiers": "Platform setImplicitExit primaryStage primaryStage primaryStage setTitle mainLayoutLoader getResource mainLayoutLoader setResources ResourceBundle getBundle Constant LOCALE rootLayout mainLayoutLoader load rootScene rootLayout primaryStage setScene rootScene primaryStage setResizable controller mainLayoutLoader getController controller setMainGui addToTray primaryStage getIcons add getResource toString primaryStage show e e printStackTrace",
                                        "signature": "    @Override\n    public void start(Stage primaryStage)",
                                        "signature_woname": "    @Override\n    public void (Stage primaryStage)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          1970,
                                          4188
                                        ],
                                        "original_string": "    private void addToTray() {\n        // ensure awt is initialized\n        java.awt.Toolkit.getDefaultToolkit();\n\n        // make sure system tray is supported\n        if (!java.awt.SystemTray.isSupported()) {\n            logger.warning(\"No system tray support!\");\n        }\n\n        final java.awt.SystemTray tray = java.awt.SystemTray.getSystemTray();\n        try {\n\n            java.awt.Image image = ImageIO.read(MainGui.class.getResource(\"/resources/image/icon.png\"));\n            trayIcon = new TrayIcon(image);\n            trayIcon.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            primaryStage.show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem openItem = new java.awt.MenuItem(\"Configuration\");\n            openItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem exitItem = new java.awt.MenuItem(\"Exit\");\n            exitItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    controller.closeServer();\n                    Platform.exit();\n                    tray.remove(trayIcon);\n                }\n            });\n\n            PopupMenu popup = new PopupMenu();\n            popup.add(openItem);\n            popup.addSeparator();\n            popup.add(exitItem);\n            trayIcon.setPopupMenu(popup);\n            trayIcon.setToolTip(\"Not Connected\");\n            tray.add(trayIcon);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (AWTException e) {\n            e.printStackTrace();\n        }\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "addToTray",
                                        "body": "                             {\n        // ensure awt is initialized\n        java.awt.Toolkit.getDefaultToolkit();\n\n        // make sure system tray is supported\n        if (!java.awt.SystemTray.isSupported()) {\n            logger.warning(\"No system tray support!\");\n        }\n\n        final java.awt.SystemTray tray = java.awt.SystemTray.getSystemTray();\n        try {\n\n            java.awt.Image image = ImageIO.read(MainGui.class.getResource(\"/resources/image/icon.png\"));\n            trayIcon = new TrayIcon(image);\n            trayIcon.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            primaryStage.show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem openItem = new java.awt.MenuItem(\"Configuration\");\n            openItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    Platform.runLater(new Runnable() {\n                        @Override\n                        public void run() {\n                            show();\n                        }\n                    });\n                }\n            });\n\n            java.awt.MenuItem exitItem = new java.awt.MenuItem(\"Exit\");\n            exitItem.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    controller.closeServer();\n                    Platform.exit();\n                    tray.remove(trayIcon);\n                }\n            });\n\n            PopupMenu popup = new PopupMenu();\n            popup.add(openItem);\n            popup.addSeparator();\n            popup.add(exitItem);\n            trayIcon.setPopupMenu(popup);\n            trayIcon.setToolTip(\"Not Connected\");\n            tray.add(trayIcon);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (AWTException e) {\n            e.printStackTrace();\n        }\n    }",
                                        "identifiers": "java awt Toolkit getDefaultToolkit java awt SystemTray isSupported logger warning tray java awt SystemTray getSystemTray image ImageIO read getResource trayIcon image trayIcon addActionListener Override actionPerformed e Platform runLater Override run primaryStage show openItem openItem addActionListener Override actionPerformed e Platform runLater Override run show exitItem exitItem addActionListener Override actionPerformed e controller closeServer Platform exit tray remove trayIcon popup popup add openItem popup addSeparator popup add exitItem trayIcon setPopupMenu popup trayIcon setToolTip tray add trayIcon e e printStackTrace e e printStackTrace",
                                        "signature": "    private void addToTray()",
                                        "signature_woname": "    private void ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4194,
                                          4249
                                        ],
                                        "original_string": "    public void show() {\n        primaryStage.show();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "show",
                                        "body": "                       {\n        primaryStage.show();\n    }",
                                        "identifiers": "primaryStage show",
                                        "signature": "    public void show()",
                                        "signature_woname": "    public void ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4255,
                                          4310
                                        ],
                                        "original_string": "    public void hide() {\n        primaryStage.hide();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "hide",
                                        "body": "                       {\n        primaryStage.hide();\n    }",
                                        "identifiers": "primaryStage hide",
                                        "signature": "    public void hide()",
                                        "signature_woname": "    public void ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4316,
                                          4446
                                        ],
                                        "original_string": "    public void setTooltip(String message) {\n        if (trayIcon != null) {\n            trayIcon.setToolTip(message);\n        }\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setTooltip",
                                        "body": "                                           {\n        if (trayIcon != null) {\n            trayIcon.setToolTip(message);\n        }\n    }",
                                        "identifiers": "trayIcon trayIcon setToolTip message",
                                        "signature": "    public void setTooltip(String message)",
                                        "signature_woname": "    public void (String message)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4452,
                                          4660
                                        ],
                                        "original_string": "    public void showNotification(String message) {\n        trayIcon.displayMessage(\n                \"shadowsocks-java\",\n                message,\n                java.awt.TrayIcon.MessageType.INFO\n        );\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "showNotification",
                                        "body": "                                                 {\n        trayIcon.displayMessage(\n                \"shadowsocks-java\",\n                message,\n                java.awt.TrayIcon.MessageType.INFO\n        );\n    }",
                                        "identifiers": "trayIcon displayMessage message java awt TrayIcon MessageType INFO",
                                        "signature": "    public void showNotification(String message)",
                                        "signature_woname": "    public void (String message)"
                                      }
                                    ]
                                  },
                                  {
                                    "original_string": "public class Config {\n    private String _ipAddr;\n    private int _port;\n    private String _localIpAddr;\n    private int _localPort;\n    private String _method;\n    private String _password;\n    private String _logLevel;\n    private IProxy.TYPE _proxyType;\n\n    public Config() {\n        loadFromJson(\"\");\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }\n\n    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }\n\n    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }\n\n    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }\n\n    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }\n\n    public void setRemotePort(int value) {\n        _port = value;\n    }\n\n    public int getRemotePort() {\n        return _port;\n    }\n\n    public void setLocalPort(int value) {\n        _localPort = value;\n    }\n\n    public int getLocalPort() {\n        return _localPort;\n    }\n\n    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }\n\n    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }\n    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }\n\n    public void setMethod(String value) {\n        _method = value;\n    }\n\n    public String getMethod() {\n        return _method;\n    }\n\n    public void setPassword(String value) {\n        _password = value;\n    }\n\n    public String getPassword() {\n        return _password;\n    }\n\n    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }\n\n    public String getLogLevel() {\n        return _logLevel;\n    }\n\n    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }\n\n    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }\n}",
                                    "definition": "public class Config",
                                    "byte_span": [
                                      1735,
                                      5565
                                    ],
                                    "start_point": [
                                      41,
                                      0
                                    ],
                                    "end_point": [
                                      175,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Config",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    private String _ipAddr;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_ipAddr",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private int _port;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "_port",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _localIpAddr;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_localIpAddr",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private int _localPort;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "_localPort",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _method;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_method",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _password;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_password",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _logLevel;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_logLevel",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private IProxy.TYPE _proxyType;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "IProxy.TYPE",
                                          "name": "_proxyType",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          1998,
                                          2047
                                        ],
                                        "original_string": "    public Config() {\n        loadFromJson(\"\");\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "Config",
                                        "body": "                    {\n        loadFromJson(\"\");\n    }",
                                        "identifiers": "loadFromJson",
                                        "signature": "    public Config()",
                                        "signature_woname": "    public ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2053,
                                          2393
                                        ],
                                        "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "Config",
                                        "body": "                                                                                                              {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                        "identifiers": "_ipAddr ipAddr _port port _localIpAddr localIpAddr _localPort localPort _method method _password password _proxyType IProxy TYPE AUTO",
                                        "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password)",
                                        "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2399,
                                          2627
                                        ],
                                        "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "Config",
                                        "body": "                                                                                                                                {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                        "identifiers": "ipAddr port localIpAddr localPort method password _proxyType type",
                                        "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)",
                                        "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2633,
                                          2710
                                        ],
                                        "original_string": "    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setRemoteIpAddress",
                                        "body": "                                                 {\n        _ipAddr = value;\n    }",
                                        "identifiers": "_ipAddr value",
                                        "signature": "    public void setRemoteIpAddress(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2716,
                                          2782
                                        ],
                                        "original_string": "    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getRemoteIpAddress",
                                        "body": "                                       {\n        return _ipAddr;\n    }",
                                        "identifiers": "_ipAddr",
                                        "signature": "    public String getRemoteIpAddress()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2788,
                                          2869
                                        ],
                                        "original_string": "    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setLocalIpAddress",
                                        "body": "                                                {\n        _localIpAddr = value;\n    }",
                                        "identifiers": "_localIpAddr value",
                                        "signature": "    public void setLocalIpAddress(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2875,
                                          2945
                                        ],
                                        "original_string": "    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getLocalIpAddress",
                                        "body": "                                      {\n        return _localIpAddr;\n    }",
                                        "identifiers": "_localIpAddr",
                                        "signature": "    public String getLocalIpAddress()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2951,
                                          3018
                                        ],
                                        "original_string": "    public void setRemotePort(int value) {\n        _port = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setRemotePort",
                                        "body": "                                         {\n        _port = value;\n    }",
                                        "identifiers": "_port value",
                                        "signature": "    public void setRemotePort(int value)",
                                        "signature_woname": "    public void (int value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3024,
                                          3080
                                        ],
                                        "original_string": "    public int getRemotePort() {\n        return _port;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getRemotePort",
                                        "body": "                               {\n        return _port;\n    }",
                                        "identifiers": "_port",
                                        "signature": "    public int getRemotePort()",
                                        "signature_woname": "    public int ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3086,
                                          3157
                                        ],
                                        "original_string": "    public void setLocalPort(int value) {\n        _localPort = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setLocalPort",
                                        "body": "                                        {\n        _localPort = value;\n    }",
                                        "identifiers": "_localPort value",
                                        "signature": "    public void setLocalPort(int value)",
                                        "signature_woname": "    public void (int value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3163,
                                          3223
                                        ],
                                        "original_string": "    public int getLocalPort() {\n        return _localPort;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getLocalPort",
                                        "body": "                              {\n        return _localPort;\n    }",
                                        "identifiers": "_localPort",
                                        "signature": "    public int getLocalPort()",
                                        "signature_woname": "    public int ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3229,
                                          3599
                                        ],
                                        "original_string": "    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setProxyType",
                                        "body": "                                           {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                        "identifiers": "_proxyType IProxy TYPE AUTO value toLowerCase equals IProxy TYPE HTTP toString toLowerCase _proxyType IProxy TYPE HTTP value toLowerCase equals IProxy TYPE SOCKS5 toString toLowerCase _proxyType IProxy TYPE SOCKS5",
                                        "signature": "    public void setProxyType(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3605,
                                          3684
                                        ],
                                        "original_string": "    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setProxyType",
                                        "body": "                                                {\n        _proxyType = value;\n    }",
                                        "identifiers": "_proxyType value",
                                        "signature": "    public void setProxyType(IProxy.TYPE value)",
                                        "signature_woname": "    public void (IProxy.TYPE value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3689,
                                          3757
                                        ],
                                        "original_string": "    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "IProxy.TYPE",
                                          "classes": []
                                        },
                                        "name": "getProxyType",
                                        "body": "                                      {\n        return _proxyType;\n    }",
                                        "identifiers": "_proxyType",
                                        "signature": "    public IProxy.TYPE getProxyType()",
                                        "signature_woname": "    public IProxy.TYPE ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3763,
                                          3831
                                        ],
                                        "original_string": "    public void setMethod(String value) {\n        _method = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setMethod",
                                        "body": "                                        {\n        _method = value;\n    }",
                                        "identifiers": "_method value",
                                        "signature": "    public void setMethod(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3837,
                                          3894
                                        ],
                                        "original_string": "    public String getMethod() {\n        return _method;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getMethod",
                                        "body": "                              {\n        return _method;\n    }",
                                        "identifiers": "_method",
                                        "signature": "    public String getMethod()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3900,
                                          3972
                                        ],
                                        "original_string": "    public void setPassword(String value) {\n        _password = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setPassword",
                                        "body": "                                          {\n        _password = value;\n    }",
                                        "identifiers": "_password value",
                                        "signature": "    public void setPassword(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3978,
                                          4039
                                        ],
                                        "original_string": "    public String getPassword() {\n        return _password;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getPassword",
                                        "body": "                                {\n        return _password;\n    }",
                                        "identifiers": "_password",
                                        "signature": "    public String getPassword()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4045,
                                          4150
                                        ],
                                        "original_string": "    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setLogLevel",
                                        "body": "                                          {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                        "identifiers": "_logLevel value Log init getLogLevel",
                                        "signature": "    public void setLogLevel(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4156,
                                          4217
                                        ],
                                        "original_string": "    public String getLogLevel() {\n        return _logLevel;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getLogLevel",
                                        "body": "                                {\n        return _logLevel;\n    }",
                                        "identifiers": "_logLevel",
                                        "signature": "    public String getLogLevel()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4223,
                                          5070
                                        ],
                                        "original_string": "    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "loadFromJson",
                                        "body": "                                             {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                        "identifiers": "jsonStr length jsonStr jObj JSONValue parse jsonStr _ipAddr jObj getOrDefault _port jObj getOrDefault intValue _localIpAddr jObj getOrDefault _localPort jObj getOrDefault intValue _method jObj getOrDefault AesCrypt CIPHER_AES_256_CFB _password jObj getOrDefault _logLevel jObj getOrDefault setProxyType jObj getOrDefault IProxy TYPE SOCKS5 toString toLowerCase setLogLevel _logLevel",
                                        "signature": "    public void loadFromJson(String jsonStr)",
                                        "signature_woname": "    public void (String jsonStr)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          5076,
                                          5563
                                        ],
                                        "original_string": "    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "saveToJson",
                                        "body": "                               {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                        "identifiers": "jObj jObj put _ipAddr jObj put _port jObj put _localIpAddr jObj put _localPort jObj put _method jObj put _password jObj put _proxyType toString toLowerCase jObj put _logLevel Util prettyPrintJson jObj",
                                        "signature": "    public String saveToJson()",
                                        "signature_woname": "    public String ()"
                                      }
                                    ]
                                  },
                                  {
                                    "original_string": "public class UTF8Control extends ResourceBundle.Control {\n    public ResourceBundle newBundle\n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)\n            throws IllegalAccessException, InstantiationException, IOException\n    {\n        // below is the original implementation\n        String bundleName = toBundleName(baseName, locale);\n        String resourceName = toResourceName(bundleName, \"properties\");\n        ResourceBundle bundle = null;\n        InputStream stream = null;\n        if (reload) {\n            URL url = loader.getResource(resourceName);\n            if (url != null) {\n                URLConnection connection = url.openConnection();\n                if (connection != null) {\n                    connection.setUseCaches(false);\n                    stream = connection.getInputStream();\n                }\n            }\n        } else {\n            stream = loader.getResourceAsStream(resourceName);\n        }\n\n        if (stream != null) {\n            try {\n                // load string use UTF-8 encoding\n                bundle = new PropertyResourceBundle(new InputStreamReader(stream, \"UTF-8\"));\n            } finally {\n                stream.close();\n            }\n        }\n        return bundle;\n    }\n}",
                                    "definition": "public class UTF8Control extends ResourceBundle.Control",
                                    "byte_span": [
                                      266,
                                      1544
                                    ],
                                    "start_point": [
                                      11,
                                      0
                                    ],
                                    "end_point": [
                                      44,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "UTF8Control",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          328,
                                          1542
                                        ],
                                        "original_string": "    public ResourceBundle newBundle\n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)\n            throws IllegalAccessException, InstantiationException, IOException\n    {\n        // below is the original implementation\n        String bundleName = toBundleName(baseName, locale);\n        String resourceName = toResourceName(bundleName, \"properties\");\n        ResourceBundle bundle = null;\n        InputStream stream = null;\n        if (reload) {\n            URL url = loader.getResource(resourceName);\n            if (url != null) {\n                URLConnection connection = url.openConnection();\n                if (connection != null) {\n                    connection.setUseCaches(false);\n                    stream = connection.getInputStream();\n                }\n            }\n        } else {\n            stream = loader.getResourceAsStream(resourceName);\n        }\n\n        if (stream != null) {\n            try {\n                // load string use UTF-8 encoding\n                bundle = new PropertyResourceBundle(new InputStreamReader(stream, \"UTF-8\"));\n            } finally {\n                stream.close();\n            }\n        }\n        return bundle;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "ResourceBundle",
                                          "classes": []
                                        },
                                        "name": "newBundle",
                                        "body": "    {\n        // below is the original implementation\n        String bundleName = toBundleName(baseName, locale);\n        String resourceName = toResourceName(bundleName, \"properties\");\n        ResourceBundle bundle = null;\n        InputStream stream = null;\n        if (reload) {\n            URL url = loader.getResource(resourceName);\n            if (url != null) {\n                URLConnection connection = url.openConnection();\n                if (connection != null) {\n                    connection.setUseCaches(false);\n                    stream = connection.getInputStream();\n                }\n            }\n        } else {\n            stream = loader.getResourceAsStream(resourceName);\n        }\n\n        if (stream != null) {\n            try {\n                // load string use UTF-8 encoding\n                bundle = new PropertyResourceBundle(new InputStreamReader(stream, \"UTF-8\"));\n            } finally {\n                stream.close();\n            }\n        }\n        return bundle;\n    }",
                                        "identifiers": "bundleName toBundleName baseName locale resourceName toResourceName bundleName bundle stream reload url loader getResource resourceName url connection url openConnection connection connection setUseCaches stream connection getInputStream stream loader getResourceAsStream resourceName stream bundle stream stream close bundle",
                                        "signature": "    public ResourceBundle newBundle\n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)",
                                        "signature_woname": "    public ResourceBundle \n            (String baseName, Locale locale, String format, ClassLoader loader, boolean reload)"
                                      }
                                    ]
                                  },
                                  {
                                    "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                    "definition": "public class Util",
                                    "byte_span": [
                                      1779,
                                      7484
                                    ],
                                    "start_point": [
                                      45,
                                      0
                                    ],
                                    "end_point": [
                                      219,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Util",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          1803,
                                          2018
                                        ],
                                        "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "dumpBytes",
                                        "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                        "identifiers": "sb a length b a sb append String format b sb toString",
                                        "signature": "    public static String dumpBytes(byte[] a)",
                                        "signature_woname": "    public static String (byte[] a)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2024,
                                          2180
                                        ],
                                        "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "byte[]",
                                          "classes": []
                                        },
                                        "name": "randomBytes",
                                        "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                        "identifiers": "bytes size nextBytes bytes bytes",
                                        "signature": "    public static byte[] randomBytes(int size)",
                                        "signature_woname": "    public static byte[] (int size)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2186,
                                          2412
                                        ],
                                        "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getErrorMessage",
                                        "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                        "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                        "signature": "    public static String getErrorMessage(Throwable e)",
                                        "signature_woname": "    public static String (Throwable e)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2418,
                                          4165
                                        ],
                                        "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "prettyPrintJson",
                                        "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                        "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                        "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                        "signature_woname": "    public static String (JSONObject jObj)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4171,
                                          5829
                                        ],
                                        "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getRequestedHostInfo",
                                        "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                        "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                        "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                        "signature_woname": "    public static String (byte[] data)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          5835,
                                          6128
                                        ],
                                        "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "bytesToString",
                                        "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                        "identifiers": "str str data start length e e printStackTrace str",
                                        "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                        "signature_woname": "    public static String (byte[] data, int start, int length)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6134,
                                          6648
                                        ],
                                        "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "byte[]",
                                          "classes": []
                                        },
                                        "name": "composeSSHeader",
                                        "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                        "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                        "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                        "signature_woname": "    public static byte[] (String host, int port)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6654,
                                          6969
                                        ],
                                        "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "saveFile",
                                        "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                        "identifiers": "writer writer fn writer println content writer close e",
                                        "signature": "    public static boolean saveFile(String fn, String content)",
                                        "signature_woname": "    public static boolean (String fn, String content)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6975,
                                          7262
                                        ],
                                        "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getFileContent",
                                        "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                        "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                        "signature": "    public static String getFileContent(String fn)",
                                        "signature_woname": "    public static String (String fn)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7268,
                                          7357
                                        ],
                                        "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "short",
                                          "classes": []
                                        },
                                        "name": "byteToUnsignedByte",
                                        "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                        "identifiers": "b",
                                        "signature": "    private static short byteToUnsignedByte(byte b)",
                                        "signature_woname": "    private static short (byte b)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7363,
                                          7482
                                        ],
                                        "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getPort",
                                        "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                        "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                        "signature": "    private static int getPort(byte b, byte b1)",
                                        "signature_woname": "    private static int (byte b, byte b1)"
                                      }
                                    ]
                                  },
                                  {
                                    "original_string": "public class NioLocalServer extends SocketHandlerBase {\n    private Logger logger = Logger.getLogger(NioLocalServer.class.getName());\n\n    private ServerSocketChannel _serverChannel;\n    private RemoteSocketHandler _remoteSocketHandler;\n    private ExecutorService _executor;\n\n    public NioLocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        super(config);\n        _executor = Executors.newCachedThreadPool();\n\n        // init remote socket handler\n        _remoteSocketHandler = new RemoteSocketHandler(_config);\n        _executor.execute(_remoteSocketHandler);\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(\"Cipher: \" + config.getMethod());\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }\n\n    @Override\n    protected Selector initSelector() throws IOException {\n        Selector socketSelector = SelectorProvider.provider().openSelector();\n        _serverChannel = ServerSocketChannel.open();\n        _serverChannel.configureBlocking(false);\n        InetSocketAddress isa = new InetSocketAddress(_config.getLocalIpAddress(), _config.getLocalPort());\n        _serverChannel.socket().bind(isa);\n        _serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n\n        return socketSelector;\n    }\n\n    @Override\n    protected boolean processPendingRequest(ChangeRequest request) {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                SelectionKey key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"NioLocalServer::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n        return true;\n    }\n\n    @Override\n    protected void processSelect(SelectionKey key) {\n        // Handle event\n        try {\n            if (key.isAcceptable()) {\n                accept(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        }\n        catch (IOException e) {\n            cleanUp((SocketChannel)key.channel());\n        }\n    }\n\n    private void accept(SelectionKey key) throws IOException {\n        // local socket established\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(_selector, SelectionKey.OP_READ);\n\n        // prepare local socket write queue\n        createWriteBuffer(socketChannel);\n\n        // create pipe between local and remote socket\n        PipeWorker pipe = _remoteSocketHandler.createPipe(this, socketChannel, _config.getRemoteIpAddress(), _config.getRemotePort());\n        _pipes.put(socketChannel, pipe);\n        _executor.execute(pipe);\n    }\n\n    private void read(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        int readCount;\n        PipeWorker pipe = _pipes.get(socketChannel);\n        byte[] data;\n\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        _readBuffer.clear();\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        data = _readBuffer.array();\n        pipe.processData(data, readCount, true);\n    }\n\n    private void write(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // Write data\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"LocalSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }\n\n    @Override\n    protected void cleanUp(SocketChannel socketChannel) {\n        //logger.warning(\"LocalSocket closed: \" + socketChannel);\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"LocalSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"LocalSocket closed (NULL): \" + socketChannel);\n        }\n\n    }\n\n    @Override\n    public void close() {\n        super.close();\n        _executor.shutdownNow();\n\n        try {\n            _serverChannel.close();\n            _remoteSocketHandler.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n        logger.info(\"Server closed.\");\n    }\n}",
                                    "definition": "public class NioLocalServer extends SocketHandlerBase",
                                    "byte_span": [
                                      2202,
                                      7856
                                    ],
                                    "start_point": [
                                      55,
                                      0
                                    ],
                                    "end_point": [
                                      225,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "NioLocalServer",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    private Logger logger = Logger.getLogger(NioLocalServer.class.getName());",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "Logger",
                                          "name": "logger = Logger.getLogger(NioLocalServer.class.getName())",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private ServerSocketChannel _serverChannel;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "ServerSocketChannel",
                                          "name": "_serverChannel",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private RemoteSocketHandler _remoteSocketHandler;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "RemoteSocketHandler",
                                          "name": "_remoteSocketHandler",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private ExecutorService _executor;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "ExecutorService",
                                          "name": "_executor",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2483,
                                          3060
                                        ],
                                        "original_string": "    public NioLocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        super(config);\n        _executor = Executors.newCachedThreadPool();\n\n        // init remote socket handler\n        _remoteSocketHandler = new RemoteSocketHandler(_config);\n        _executor.execute(_remoteSocketHandler);\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(\"Cipher: \" + config.getMethod());\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "NioLocalServer",
                                        "body": "                                                                                                {\n        super(config);\n        _executor = Executors.newCachedThreadPool();\n\n        // init remote socket handler\n        _remoteSocketHandler = new RemoteSocketHandler(_config);\n        _executor.execute(_remoteSocketHandler);\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(\"Cipher: \" + config.getMethod());\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }",
                                        "identifiers": "config _executor Executors newCachedThreadPool _remoteSocketHandler _config _executor execute _remoteSocketHandler logger info Constant VERSION logger info config getMethod logger info config getProxyType config getLocalPort",
                                        "signature": "    public NioLocalServer(Config config)",
                                        "signature_woname": "    public (Config config)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3066,
                                          3576
                                        ],
                                        "original_string": "    @Override\n    protected Selector initSelector() throws IOException {\n        Selector socketSelector = SelectorProvider.provider().openSelector();\n        _serverChannel = ServerSocketChannel.open();\n        _serverChannel.configureBlocking(false);\n        InetSocketAddress isa = new InetSocketAddress(_config.getLocalIpAddress(), _config.getLocalPort());\n        _serverChannel.socket().bind(isa);\n        _serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n\n        return socketSelector;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    protected",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "protected"
                                          ],
                                          "comments": [],
                                          "return_type": "Selector",
                                          "classes": []
                                        },
                                        "name": "initSelector",
                                        "body": "                                                         {\n        Selector socketSelector = SelectorProvider.provider().openSelector();\n        _serverChannel = ServerSocketChannel.open();\n        _serverChannel.configureBlocking(false);\n        InetSocketAddress isa = new InetSocketAddress(_config.getLocalIpAddress(), _config.getLocalPort());\n        _serverChannel.socket().bind(isa);\n        _serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n\n        return socketSelector;\n    }",
                                        "identifiers": "socketSelector SelectorProvider provider openSelector _serverChannel ServerSocketChannel open _serverChannel configureBlocking isa _config getLocalIpAddress _config getLocalPort _serverChannel socket bind isa _serverChannel register socketSelector SelectionKey OP_ACCEPT socketSelector",
                                        "signature": "    @Override\n    protected Selector initSelector()",
                                        "signature_woname": "    @Override\n    protected Selector ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3582,
                                          4235
                                        ],
                                        "original_string": "    @Override\n    protected boolean processPendingRequest(ChangeRequest request) {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                SelectionKey key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"NioLocalServer::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n        return true;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    protected",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "protected"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "processPendingRequest",
                                        "body": "                                                                   {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                SelectionKey key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"NioLocalServer::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n        return true;\n    }",
                                        "identifiers": "request type ChangeRequest CHANGE_SOCKET_OP key request socket keyFor _selector key key isValid key interestOps request op logger warning key request socket ChangeRequest CLOSE_CHANNEL cleanUp request socket",
                                        "signature": "    @Override\n    protected boolean processPendingRequest(ChangeRequest request)",
                                        "signature_woname": "    @Override\n    protected boolean (ChangeRequest request)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4241,
                                          4672
                                        ],
                                        "original_string": "    @Override\n    protected void processSelect(SelectionKey key) {\n        // Handle event\n        try {\n            if (key.isAcceptable()) {\n                accept(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        }\n        catch (IOException e) {\n            cleanUp((SocketChannel)key.channel());\n        }\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    protected",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "protected"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "processSelect",
                                        "body": "                                                   {\n        // Handle event\n        try {\n            if (key.isAcceptable()) {\n                accept(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        }\n        catch (IOException e) {\n            cleanUp((SocketChannel)key.channel());\n        }\n    }",
                                        "identifiers": "key isAcceptable accept key key isReadable read key key isWritable write key e cleanUp key channel",
                                        "signature": "    @Override\n    protected void processSelect(SelectionKey key)",
                                        "signature_woname": "    @Override\n    protected void (SelectionKey key)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4678,
                                          5398
                                        ],
                                        "original_string": "    private void accept(SelectionKey key) throws IOException {\n        // local socket established\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(_selector, SelectionKey.OP_READ);\n\n        // prepare local socket write queue\n        createWriteBuffer(socketChannel);\n\n        // create pipe between local and remote socket\n        PipeWorker pipe = _remoteSocketHandler.createPipe(this, socketChannel, _config.getRemoteIpAddress(), _config.getRemotePort());\n        _pipes.put(socketChannel, pipe);\n        _executor.execute(pipe);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "accept",
                                        "body": "                                                             {\n        // local socket established\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(_selector, SelectionKey.OP_READ);\n\n        // prepare local socket write queue\n        createWriteBuffer(socketChannel);\n\n        // create pipe between local and remote socket\n        PipeWorker pipe = _remoteSocketHandler.createPipe(this, socketChannel, _config.getRemoteIpAddress(), _config.getRemotePort());\n        _pipes.put(socketChannel, pipe);\n        _executor.execute(pipe);\n    }",
                                        "identifiers": "serverSocketChannel key channel socketChannel serverSocketChannel accept socketChannel configureBlocking socketChannel register _selector SelectionKey OP_READ createWriteBuffer socketChannel pipe _remoteSocketHandler createPipe socketChannel _config getRemoteIpAddress _config getRemotePort _pipes put socketChannel pipe _executor execute pipe",
                                        "signature": "    private void accept(SelectionKey key)",
                                        "signature_woname": "    private void (SelectionKey key)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          5404,
                                          6145
                                        ],
                                        "original_string": "    private void read(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        int readCount;\n        PipeWorker pipe = _pipes.get(socketChannel);\n        byte[] data;\n\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        _readBuffer.clear();\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        data = _readBuffer.array();\n        pipe.processData(data, readCount, true);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "read",
                                        "body": "                                                           {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        int readCount;\n        PipeWorker pipe = _pipes.get(socketChannel);\n        byte[] data;\n\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        _readBuffer.clear();\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        data = _readBuffer.array();\n        pipe.processData(data, readCount, true);\n    }",
                                        "identifiers": "socketChannel key channel readCount pipe _pipes get socketChannel data pipe cleanUp socketChannel _readBuffer clear readCount socketChannel read _readBuffer e cleanUp socketChannel readCount cleanUp socketChannel data _readBuffer array pipe processData data readCount",
                                        "signature": "    private void read(SelectionKey key)",
                                        "signature_woname": "    private void (SelectionKey key)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6151,
                                          7014
                                        ],
                                        "original_string": "    private void write(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // Write data\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"LocalSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "write",
                                        "body": "                                                            {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // Write data\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"LocalSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }",
                                        "identifiers": "socketChannel key channel queue _pendingData get socketChannel queue queue queue isEmpty buf queue get socketChannel write buf buf remaining queue remove queue isEmpty key interestOps SelectionKey OP_READ logger warning socketChannel",
                                        "signature": "    private void write(SelectionKey key)",
                                        "signature_woname": "    private void (SelectionKey key)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7020,
                                          7522
                                        ],
                                        "original_string": "    @Override\n    protected void cleanUp(SocketChannel socketChannel) {\n        //logger.warning(\"LocalSocket closed: \" + socketChannel);\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"LocalSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"LocalSocket closed (NULL): \" + socketChannel);\n        }\n\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    protected",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "protected"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "cleanUp",
                                        "body": "                                                        {\n        //logger.warning(\"LocalSocket closed: \" + socketChannel);\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"LocalSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"LocalSocket closed (NULL): \" + socketChannel);\n        }\n\n    }",
                                        "identifiers": "cleanUp socketChannel pipe _pipes get socketChannel pipe pipe close _pipes remove socketChannel logger fine pipe socketInfo logger fine socketChannel",
                                        "signature": "    @Override\n    protected void cleanUp(SocketChannel socketChannel)",
                                        "signature_woname": "    @Override\n    protected void (SocketChannel socketChannel)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7528,
                                          7854
                                        ],
                                        "original_string": "    @Override\n    public void close() {\n        super.close();\n        _executor.shutdownNow();\n\n        try {\n            _serverChannel.close();\n            _remoteSocketHandler.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n        logger.info(\"Server closed.\");\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    public",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "close",
                                        "body": "                        {\n        super.close();\n        _executor.shutdownNow();\n\n        try {\n            _serverChannel.close();\n            _remoteSocketHandler.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n        logger.info(\"Server closed.\");\n    }",
                                        "identifiers": "close _executor shutdownNow _serverChannel close _remoteSocketHandler close e logger warning Util getErrorMessage e logger info",
                                        "signature": "    @Override\n    public void close()",
                                        "signature_woname": "    @Override\n    public void ()"
                                      }
                                    ]
                                  },
                                  {
                                    "original_string": "public class ProxyFactory {\n    public static final Map<IProxy.TYPE, String> proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }};\n    private static Logger logger = Logger.getLogger(ProxyFactory.class.getName());\n\n    public static boolean isProxyTypeExisted(String name) {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }\n\n    public static IProxy get(IProxy.TYPE type) {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<IProxy.TYPE> getSupportedProxyTypes() {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                    "definition": "public class ProxyFactory",
                                    "byte_span": [
                                      1660,
                                      2707
                                    ],
                                    "start_point": [
                                      40,
                                      0
                                    ],
                                    "end_point": [
                                      70,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "ProxyFactory",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    public static final Map<IProxy.TYPE, String> proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }};",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "Map<IProxy.TYPE, String>",
                                          "name": "proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }}",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private static Logger logger = Logger.getLogger(ProxyFactory.class.getName());",
                                          "docstring": "",
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "Logger",
                                          "name": "logger = Logger.getLogger(ProxyFactory.class.getName())",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2059,
                                          2218
                                        ],
                                        "original_string": "    public static boolean isProxyTypeExisted(String name) {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "isProxyTypeExisted",
                                        "body": "                                                          {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }",
                                        "identifiers": "type IProxy TYPE valueOf name proxies get type",
                                        "signature": "    public static boolean isProxyTypeExisted(String name)",
                                        "signature_woname": "    public static boolean (String name)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2224,
                                          2509
                                        ],
                                        "original_string": "    public static IProxy get(IProxy.TYPE type) {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "IProxy",
                                          "classes": []
                                        },
                                        "name": "get",
                                        "body": "                                               {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                        "identifiers": "obj Reflection get proxies get type obj e logger info com stfl misc Util getErrorMessage e",
                                        "signature": "    public static IProxy get(IProxy.TYPE type)",
                                        "signature_woname": "    public static IProxy (IProxy.TYPE type)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2515,
                                          2705
                                        ],
                                        "original_string": "    public static List<IProxy.TYPE> getSupportedProxyTypes() {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "List<IProxy.TYPE>",
                                          "classes": []
                                        },
                                        "name": "getSupportedProxyTypes",
                                        "body": "                                                             {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                        "identifiers": "sortedKeys proxies keySet Collections sort sortedKeys sortedKeys",
                                        "signature": "    public static List<IProxy.TYPE> getSupportedProxyTypes()",
                                        "signature_woname": "    public static List<IProxy.TYPE> ()"
                                      }
                                    ]
                                  },
                                  {
                                    "original_string": "public class CryptFactory {\n    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};\n    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());\n\n    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }\n\n    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                    "definition": "public class CryptFactory",
                                    "byte_span": [
                                      1649,
                                      2693
                                    ],
                                    "start_point": [
                                      40,
                                      0
                                    ],
                                    "end_point": [
                                      71,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "CryptFactory",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};",
                                          "docstring": "",
                                          "modifiers": "private static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "Map<String, String>",
                                          "name": "crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }}",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());",
                                          "docstring": "",
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "Logger",
                                          "name": "logger = Logger.getLogger(CryptFactory.class.getName())",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2057,
                                          2158
                                        ],
                                        "original_string": "    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "isCipherExisted",
                                        "body": "                                                       {\n        return (crypts.get(name) != null);\n    }",
                                        "identifiers": "crypts get name",
                                        "signature": "    public static boolean isCipherExisted(String name)",
                                        "signature_woname": "    public static boolean (String name)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2164,
                                          2504
                                        ],
                                        "original_string": "    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "ICrypt",
                                          "classes": []
                                        },
                                        "name": "get",
                                        "body": "                                                           {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                        "identifiers": "obj Reflection get crypts get name name password obj e logger info com stfl misc Util getErrorMessage e",
                                        "signature": "    public static ICrypt get(String name, String password)",
                                        "signature_woname": "    public static ICrypt (String name, String password)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2510,
                                          2691
                                        ],
                                        "original_string": "    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "List<String>",
                                          "classes": []
                                        },
                                        "name": "getSupportedCiphers",
                                        "body": "                                                     {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                        "identifiers": "sortedKeys crypts keySet Collections sort sortedKeys sortedKeys",
                                        "signature": "    public static List<String> getSupportedCiphers()",
                                        "signature_woname": "    public static List<String> ()"
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "name": "LogLayoutController.java",
                                "content": "package com.stfl.ui;\n\nimport com.stfl.misc.Log;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Button;\nimport javafx.scene.control.TextArea;\nimport javafx.stage.Stage;\n\npublic class LogLayoutController {\n    @FXML\n    public TextArea txtLog;\n    @FXML\n    private Button btnClose;\n    @FXML\n    private Button btnClear;\n\n    private Stage stage;\n\n    @FXML\n    private void initialize() {\n        TextAreaLogHandler handler = new TextAreaLogHandler();\n        handler.setTextArea(txtLog);\n        Log.addHandler(handler);\n    }\n\n    @FXML\n    private void handleClear() {\n        txtLog.clear();\n    }\n\n    @FXML\n    private void handleClose() {\n        stage.hide();\n    }\n\n    public void setStage(Stage stage) {\n        this.stage = stage;\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.ui;",
                                    "import com.stfl.misc.Log;",
                                    "import javafx.fxml.FXML;",
                                    "import javafx.scene.control.Button;",
                                    "import javafx.scene.control.TextArea;",
                                    "import javafx.stage.Stage;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class LogLayoutController {\n    @FXML\n    public TextArea txtLog;\n    @FXML\n    private Button btnClose;\n    @FXML\n    private Button btnClear;\n\n    private Stage stage;\n\n    @FXML\n    private void initialize() {\n        TextAreaLogHandler handler = new TextAreaLogHandler();\n        handler.setTextArea(txtLog);\n        Log.addHandler(handler);\n    }\n\n    @FXML\n    private void handleClear() {\n        txtLog.clear();\n    }\n\n    @FXML\n    private void handleClose() {\n        stage.hide();\n    }\n\n    public void setStage(Stage stage) {\n        this.stage = stage;\n    }\n}",
                                      "definition": "public class LogLayoutController",
                                      "byte_span": [
                                        175,
                                        756
                                      ],
                                      "start_point": [
                                        8,
                                        0
                                      ],
                                      "end_point": [
                                        38,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "LogLayoutController",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    @FXML\n    public TextArea txtLog;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    public",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "type": "TextArea",
                                            "name": "txtLog",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    @FXML\n    private Button btnClose;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Button",
                                            "name": "btnClose",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    @FXML\n    private Button btnClear;",
                                            "docstring": "",
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Button",
                                            "name": "btnClear",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private Stage stage;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Stage",
                                            "name": "stage",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            357,
                                            533
                                          ],
                                          "original_string": "    @FXML\n    private void initialize() {\n        TextAreaLogHandler handler = new TextAreaLogHandler();\n        handler.setTextArea(txtLog);\n        Log.addHandler(handler);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "initialize",
                                          "body": "                              {\n        TextAreaLogHandler handler = new TextAreaLogHandler();\n        handler.setTextArea(txtLog);\n        Log.addHandler(handler);\n    }",
                                          "identifiers": "handler handler setTextArea txtLog Log addHandler handler",
                                          "signature": "    @FXML\n    private void initialize()",
                                          "signature_woname": "    @FXML\n    private void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            539,
                                            607
                                          ],
                                          "original_string": "    @FXML\n    private void handleClear() {\n        txtLog.clear();\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "handleClear",
                                          "body": "                               {\n        txtLog.clear();\n    }",
                                          "identifiers": "txtLog clear",
                                          "signature": "    @FXML\n    private void handleClear()",
                                          "signature_woname": "    @FXML\n    private void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            613,
                                            679
                                          ],
                                          "original_string": "    @FXML\n    private void handleClose() {\n        stage.hide();\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@FXML\n    private",
                                            "marker_annotations": [
                                              "@FXML"
                                            ],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "handleClose",
                                          "body": "                               {\n        stage.hide();\n    }",
                                          "identifiers": "stage hide",
                                          "signature": "    @FXML\n    private void handleClose()",
                                          "signature_woname": "    @FXML\n    private void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            685,
                                            754
                                          ],
                                          "original_string": "    public void setStage(Stage stage) {\n        this.stage = stage;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setStage",
                                          "body": "                                      {\n        this.stage = stage;\n    }",
                                          "identifiers": "stage stage",
                                          "signature": "    public void setStage(Stage stage)",
                                          "signature_woname": "    public void (Stage stage)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": [
                                  {
                                    "original_string": "public class Log {\n    private static boolean handlerInit = false;\n\n    public static void init() {\n        init(Level.INFO);\n    }\n\n    public static void init(Level level) {\n        Logger rootLogger = getRootLogger();\n        if (handlerInit) {\n            rootLogger.setLevel(level);\n            for(Handler handler : rootLogger.getHandlers()) {\n                handler.setLevel(level);\n            }\n            return;\n        }\n\n        // disable message localization\n        Locale.setDefault(Locale.ENGLISH);\n        // config log output format\n        Properties props = System.getProperties();\n        props.setProperty(\"java.util.logging.SimpleFormatter.format\", \"%1$tY-%1$tb-%1$td %1$tT [%4$s] %5$s%n\");\n        // setup root logger\n        //Logger rootLogger = getRootLogger();\n        rootLogger.setUseParentHandlers(false);\n        for(Handler handler : rootLogger.getHandlers()) {\n            rootLogger.removeHandler(handler);\n        }\n        // set log level and format\n        rootLogger.setLevel(level);\n        ConsoleHandler handler = new ConsoleHandler();\n        handler.setLevel(level);\n        rootLogger.addHandler(handler);\n        handlerInit = true;\n    }\n\n    public static void init(String level) {\n        Level l = Level.parse(level);\n        init(l);\n    }\n\n    public static void addHandler(Handler handler) {\n        Logger rootLogger = getRootLogger();\n        Level logLevel = Level.INFO;\n        for (Handler h : rootLogger.getHandlers()) {\n            logLevel = h.getLevel();\n        }\n\n        handler.setLevel(logLevel);\n        rootLogger.addHandler(handler);\n    }\n\n    private static Logger getRootLogger() {\n        return Logger.getLogger(\"com.stfl\");\n    }\n}",
                                    "definition": "public class Log",
                                    "byte_span": [
                                      1666,
                                      3379
                                    ],
                                    "start_point": [
                                      40,
                                      0
                                    ],
                                    "end_point": [
                                      95,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Log",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    private static boolean handlerInit = false;",
                                          "docstring": "",
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "boolean",
                                          "name": "handlerInit = false",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          1738,
                                          1797
                                        ],
                                        "original_string": "    public static void init() {\n        init(Level.INFO);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "init",
                                        "body": "                              {\n        init(Level.INFO);\n    }",
                                        "identifiers": "init Level INFO",
                                        "signature": "    public static void init()",
                                        "signature_woname": "    public static void ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          1803,
                                          2856
                                        ],
                                        "original_string": "    public static void init(Level level) {\n        Logger rootLogger = getRootLogger();\n        if (handlerInit) {\n            rootLogger.setLevel(level);\n            for(Handler handler : rootLogger.getHandlers()) {\n                handler.setLevel(level);\n            }\n            return;\n        }\n\n        // disable message localization\n        Locale.setDefault(Locale.ENGLISH);\n        // config log output format\n        Properties props = System.getProperties();\n        props.setProperty(\"java.util.logging.SimpleFormatter.format\", \"%1$tY-%1$tb-%1$td %1$tT [%4$s] %5$s%n\");\n        // setup root logger\n        //Logger rootLogger = getRootLogger();\n        rootLogger.setUseParentHandlers(false);\n        for(Handler handler : rootLogger.getHandlers()) {\n            rootLogger.removeHandler(handler);\n        }\n        // set log level and format\n        rootLogger.setLevel(level);\n        ConsoleHandler handler = new ConsoleHandler();\n        handler.setLevel(level);\n        rootLogger.addHandler(handler);\n        handlerInit = true;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "init",
                                        "body": "                                         {\n        Logger rootLogger = getRootLogger();\n        if (handlerInit) {\n            rootLogger.setLevel(level);\n            for(Handler handler : rootLogger.getHandlers()) {\n                handler.setLevel(level);\n            }\n            return;\n        }\n\n        // disable message localization\n        Locale.setDefault(Locale.ENGLISH);\n        // config log output format\n        Properties props = System.getProperties();\n        props.setProperty(\"java.util.logging.SimpleFormatter.format\", \"%1$tY-%1$tb-%1$td %1$tT [%4$s] %5$s%n\");\n        // setup root logger\n        //Logger rootLogger = getRootLogger();\n        rootLogger.setUseParentHandlers(false);\n        for(Handler handler : rootLogger.getHandlers()) {\n            rootLogger.removeHandler(handler);\n        }\n        // set log level and format\n        rootLogger.setLevel(level);\n        ConsoleHandler handler = new ConsoleHandler();\n        handler.setLevel(level);\n        rootLogger.addHandler(handler);\n        handlerInit = true;\n    }",
                                        "identifiers": "rootLogger getRootLogger handlerInit rootLogger setLevel level handler rootLogger getHandlers handler setLevel level Locale setDefault Locale ENGLISH props System getProperties props setProperty rootLogger setUseParentHandlers handler rootLogger getHandlers rootLogger removeHandler handler rootLogger setLevel level handler handler setLevel level rootLogger addHandler handler handlerInit",
                                        "signature": "    public static void init(Level level)",
                                        "signature_woname": "    public static void (Level level)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2862,
                                          2962
                                        ],
                                        "original_string": "    public static void init(String level) {\n        Level l = Level.parse(level);\n        init(l);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "init",
                                        "body": "                                          {\n        Level l = Level.parse(level);\n        init(l);\n    }",
                                        "identifiers": "l Level parse level init l",
                                        "signature": "    public static void init(String level)",
                                        "signature_woname": "    public static void (String level)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2968,
                                          3281
                                        ],
                                        "original_string": "    public static void addHandler(Handler handler) {\n        Logger rootLogger = getRootLogger();\n        Level logLevel = Level.INFO;\n        for (Handler h : rootLogger.getHandlers()) {\n            logLevel = h.getLevel();\n        }\n\n        handler.setLevel(logLevel);\n        rootLogger.addHandler(handler);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "addHandler",
                                        "body": "                                                   {\n        Logger rootLogger = getRootLogger();\n        Level logLevel = Level.INFO;\n        for (Handler h : rootLogger.getHandlers()) {\n            logLevel = h.getLevel();\n        }\n\n        handler.setLevel(logLevel);\n        rootLogger.addHandler(handler);\n    }",
                                        "identifiers": "rootLogger getRootLogger logLevel Level INFO h rootLogger getHandlers logLevel h getLevel handler setLevel logLevel rootLogger addHandler handler",
                                        "signature": "    public static void addHandler(Handler handler)",
                                        "signature_woname": "    public static void (Handler handler)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3287,
                                          3377
                                        ],
                                        "original_string": "    private static Logger getRootLogger() {\n        return Logger.getLogger(\"com.stfl\");\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "Logger",
                                          "classes": []
                                        },
                                        "name": "getRootLogger",
                                        "body": "                                          {\n        return Logger.getLogger(\"com.stfl\");\n    }",
                                        "identifiers": "Logger getLogger",
                                        "signature": "    private static Logger getRootLogger()",
                                        "signature_woname": "    private static Logger ()"
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "name": "TextAreaLogHandler.java",
                                "content": "package com.stfl.ui;\n\nimport javafx.application.Platform;\nimport javafx.scene.control.TextArea;\n\nimport java.util.logging.LogRecord;\nimport java.util.logging.StreamHandler;\n\npublic class TextAreaLogHandler extends StreamHandler {\n    TextArea textArea = null;\n\n    public void setTextArea(TextArea textArea) {\n        this.textArea = textArea;\n    }\n\n    @Override\n    public void publish(LogRecord record) {\n        final LogRecord lg = record;\n        super.publish(record);\n        flush();\n\n        if (textArea != null) {\n            Platform.runLater(new Runnable() {\n                @Override\n                public void run() {\n                    // limited log size to 64k\n                    if (textArea.getText().length() > 65535) {\n                        textArea.clear();\n                    }\n                    textArea.appendText(getFormatter().format(lg));\n                }\n            });\n        }\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.ui;",
                                    "import javafx.application.Platform;",
                                    "import javafx.scene.control.TextArea;",
                                    "import java.util.logging.LogRecord;",
                                    "import java.util.logging.StreamHandler;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class TextAreaLogHandler extends StreamHandler {\n    TextArea textArea = null;\n\n    public void setTextArea(TextArea textArea) {\n        this.textArea = textArea;\n    }\n\n    @Override\n    public void publish(LogRecord record) {\n        final LogRecord lg = record;\n        super.publish(record);\n        flush();\n\n        if (textArea != null) {\n            Platform.runLater(new Runnable() {\n                @Override\n                public void run() {\n                    // limited log size to 64k\n                    if (textArea.getText().length() > 65535) {\n                        textArea.clear();\n                    }\n                    textArea.appendText(getFormatter().format(lg));\n                }\n            });\n        }\n    }\n}",
                                      "definition": "public class TextAreaLogHandler extends StreamHandler",
                                      "byte_span": [
                                        174,
                                        929
                                      ],
                                      "start_point": [
                                        8,
                                        0
                                      ],
                                      "end_point": [
                                        34,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "TextAreaLogHandler",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    TextArea textArea = null;",
                                            "docstring": "",
                                            "modifiers": "",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [],
                                            "comments": [],
                                            "type": "TextArea",
                                            "name": "textArea = null",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            265,
                                            349
                                          ],
                                          "original_string": "    public void setTextArea(TextArea textArea) {\n        this.textArea = textArea;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "setTextArea",
                                          "body": "                                               {\n        this.textArea = textArea;\n    }",
                                          "identifiers": "textArea textArea",
                                          "signature": "    public void setTextArea(TextArea textArea)",
                                          "signature_woname": "    public void (TextArea textArea)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            355,
                                            927
                                          ],
                                          "original_string": "    @Override\n    public void publish(LogRecord record) {\n        final LogRecord lg = record;\n        super.publish(record);\n        flush();\n\n        if (textArea != null) {\n            Platform.runLater(new Runnable() {\n                @Override\n                public void run() {\n                    // limited log size to 64k\n                    if (textArea.getText().length() > 65535) {\n                        textArea.clear();\n                    }\n                    textArea.appendText(getFormatter().format(lg));\n                }\n            });\n        }\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "publish",
                                          "body": "                                          {\n        final LogRecord lg = record;\n        super.publish(record);\n        flush();\n\n        if (textArea != null) {\n            Platform.runLater(new Runnable() {\n                @Override\n                public void run() {\n                    // limited log size to 64k\n                    if (textArea.getText().length() > 65535) {\n                        textArea.clear();\n                    }\n                    textArea.appendText(getFormatter().format(lg));\n                }\n            });\n        }\n    }",
                                          "identifiers": "lg record publish record flush textArea Platform runLater Override run textArea getText length textArea clear textArea appendText getFormatter format lg",
                                          "signature": "    @Override\n    public void publish(LogRecord record)",
                                          "signature_woname": "    @Override\n    public void (LogRecord record)"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": []
                              }
                            ],
                            "subdirs": []
                          },
                          {
                            "dir": "network",
                            "files": [
                              {
                                "name": "LocalServer.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.logging.Logger;\n\nimport com.stfl.Constant;\nimport com.stfl.misc.Config;\nimport com.stfl.misc.Util;\nimport com.stfl.network.io.PipeSocket;\nimport com.stfl.ss.CryptFactory;\n\n/**\n * Blocking local server for shadowsocks\n */\npublic class LocalServer implements IServer {\n    private Logger logger = Logger.getLogger(LocalServer.class.getName());\n    private Config _config;\n    private ServerSocket _serverSocket;\n    private Executor _executor;\n    private List<PipeSocket> _pipes;\n\n    public LocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        if (!CryptFactory.isCipherExisted(config.getMethod())) {\n            throw new InvalidAlgorithmParameterException(config.getMethod());\n        }\n        _config = config;\n        _serverSocket = new ServerSocket(config.getLocalPort(), 128);\n        _executor = Executors.newCachedThreadPool();\n        _pipes = new ArrayList<>();\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Socket localSocket = _serverSocket.accept();\n                PipeSocket pipe = new PipeSocket(_executor, localSocket, _config);\n                _pipes.add(pipe);\n                _executor.execute(pipe);\n            } catch (IOException e) {\n                logger.warning(Util.getErrorMessage(e));\n            }\n        }\n    }\n\n    public void close() {\n        try {\n            for (PipeSocket p : _pipes) {\n                p.close();\n            }\n            _pipes.clear();\n            _serverSocket.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n    }\n\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.network;",
                                    "import java.io.IOException;",
                                    "import java.net.ServerSocket;",
                                    "import java.net.Socket;",
                                    "import java.security.InvalidAlgorithmParameterException;",
                                    "import java.util.ArrayList;",
                                    "import java.util.List;",
                                    "import java.util.concurrent.Executor;",
                                    "import java.util.concurrent.Executors;",
                                    "import java.util.logging.Logger;",
                                    "import com.stfl.Constant;",
                                    "import com.stfl.misc.Config;",
                                    "import com.stfl.misc.Util;",
                                    "import com.stfl.network.io.PipeSocket;",
                                    "import com.stfl.ss.CryptFactory;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class LocalServer implements IServer {\n    private Logger logger = Logger.getLogger(LocalServer.class.getName());\n    private Config _config;\n    private ServerSocket _serverSocket;\n    private Executor _executor;\n    private List<PipeSocket> _pipes;\n\n    public LocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        if (!CryptFactory.isCipherExisted(config.getMethod())) {\n            throw new InvalidAlgorithmParameterException(config.getMethod());\n        }\n        _config = config;\n        _serverSocket = new ServerSocket(config.getLocalPort(), 128);\n        _executor = Executors.newCachedThreadPool();\n        _pipes = new ArrayList<>();\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Socket localSocket = _serverSocket.accept();\n                PipeSocket pipe = new PipeSocket(_executor, localSocket, _config);\n                _pipes.add(pipe);\n                _executor.execute(pipe);\n            } catch (IOException e) {\n                logger.warning(Util.getErrorMessage(e));\n            }\n        }\n    }\n\n    public void close() {\n        try {\n            for (PipeSocket p : _pipes) {\n                p.close();\n            }\n            _pipes.clear();\n            _serverSocket.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n    }\n\n}",
                                      "definition": "public class LocalServer implements IServer",
                                      "byte_span": [
                                        2047,
                                        3656
                                      ],
                                      "start_point": [
                                        52,
                                        0
                                      ],
                                      "end_point": [
                                        99,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "LocalServer",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    private Logger logger = Logger.getLogger(LocalServer.class.getName());",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Logger",
                                            "name": "logger = Logger.getLogger(LocalServer.class.getName())",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private Config _config;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Config",
                                            "name": "_config",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private ServerSocket _serverSocket;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "ServerSocket",
                                            "name": "_serverSocket",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private Executor _executor;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Executor",
                                            "name": "_executor",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private List<PipeSocket> _pipes;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "List<PipeSocket>",
                                            "name": "_pipes",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2310,
                                            2939
                                          ],
                                          "original_string": "    public LocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        if (!CryptFactory.isCipherExisted(config.getMethod())) {\n            throw new InvalidAlgorithmParameterException(config.getMethod());\n        }\n        _config = config;\n        _serverSocket = new ServerSocket(config.getLocalPort(), 128);\n        _executor = Executors.newCachedThreadPool();\n        _pipes = new ArrayList<>();\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "LocalServer",
                                          "body": "                                                                                             {\n        if (!CryptFactory.isCipherExisted(config.getMethod())) {\n            throw new InvalidAlgorithmParameterException(config.getMethod());\n        }\n        _config = config;\n        _serverSocket = new ServerSocket(config.getLocalPort(), 128);\n        _executor = Executors.newCachedThreadPool();\n        _pipes = new ArrayList<>();\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }",
                                          "identifiers": "CryptFactory isCipherExisted config getMethod config getMethod _config config _serverSocket config getLocalPort _executor Executors newCachedThreadPool _pipes logger info Constant VERSION logger info config getProxyType config getLocalPort",
                                          "signature": "    public LocalServer(Config config)",
                                          "signature_woname": "    public (Config config)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2945,
                                            3363
                                          ],
                                          "original_string": "    @Override\n    public void run() {\n        while (true) {\n            try {\n                Socket localSocket = _serverSocket.accept();\n                PipeSocket pipe = new PipeSocket(_executor, localSocket, _config);\n                _pipes.add(pipe);\n                _executor.execute(pipe);\n            } catch (IOException e) {\n                logger.warning(Util.getErrorMessage(e));\n            }\n        }\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "run",
                                          "body": "                      {\n        while (true) {\n            try {\n                Socket localSocket = _serverSocket.accept();\n                PipeSocket pipe = new PipeSocket(_executor, localSocket, _config);\n                _pipes.add(pipe);\n                _executor.execute(pipe);\n            } catch (IOException e) {\n                logger.warning(Util.getErrorMessage(e));\n            }\n        }\n    }",
                                          "identifiers": "localSocket _serverSocket accept pipe _executor localSocket _config _pipes add pipe _executor execute pipe e logger warning Util getErrorMessage e",
                                          "signature": "    @Override\n    public void run()",
                                          "signature_woname": "    @Override\n    public void ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3369,
                                            3653
                                          ],
                                          "original_string": "    public void close() {\n        try {\n            for (PipeSocket p : _pipes) {\n                p.close();\n            }\n            _pipes.clear();\n            _serverSocket.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "close",
                                          "body": "                        {\n        try {\n            for (PipeSocket p : _pipes) {\n                p.close();\n            }\n            _pipes.clear();\n            _serverSocket.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n    }",
                                          "identifiers": "p _pipes p close _pipes clear _serverSocket close e logger warning Util getErrorMessage e",
                                          "signature": "    public void close()",
                                          "signature_woname": "    public void ()"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": [
                                  {
                                    "original_string": "public class Constant {\n    public static final String PROG_NAME = \"shadowsocks-java\";\n    public static final String VERSION = \"0.2\";\n    public static final int BUFFER_SIZE = 16384;\n    public static final String CONF_FILE = \"config.json\";\n    public static final Locale LOCALE = Locale.getDefault();\n}",
                                    "definition": "public class Constant",
                                    "byte_span": [
                                      45,
                                      349
                                    ],
                                    "start_point": [
                                      4,
                                      0
                                    ],
                                    "end_point": [
                                      10,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Constant",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    public static final String PROG_NAME = \"shadowsocks-java\";",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "PROG_NAME = \"shadowsocks-java\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final String VERSION = \"0.2\";",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "VERSION = \"0.2\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final int BUFFER_SIZE = 16384;",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "BUFFER_SIZE = 16384",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final String CONF_FILE = \"config.json\";",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "CONF_FILE = \"config.json\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final Locale LOCALE = Locale.getDefault();",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "Locale",
                                          "name": "LOCALE = Locale.getDefault()",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": []
                                  },
                                  {
                                    "original_string": "public class Config {\n    private String _ipAddr;\n    private int _port;\n    private String _localIpAddr;\n    private int _localPort;\n    private String _method;\n    private String _password;\n    private String _logLevel;\n    private IProxy.TYPE _proxyType;\n\n    public Config() {\n        loadFromJson(\"\");\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }\n\n    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }\n\n    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }\n\n    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }\n\n    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }\n\n    public void setRemotePort(int value) {\n        _port = value;\n    }\n\n    public int getRemotePort() {\n        return _port;\n    }\n\n    public void setLocalPort(int value) {\n        _localPort = value;\n    }\n\n    public int getLocalPort() {\n        return _localPort;\n    }\n\n    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }\n\n    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }\n    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }\n\n    public void setMethod(String value) {\n        _method = value;\n    }\n\n    public String getMethod() {\n        return _method;\n    }\n\n    public void setPassword(String value) {\n        _password = value;\n    }\n\n    public String getPassword() {\n        return _password;\n    }\n\n    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }\n\n    public String getLogLevel() {\n        return _logLevel;\n    }\n\n    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }\n\n    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }\n}",
                                    "definition": "public class Config",
                                    "byte_span": [
                                      1735,
                                      5565
                                    ],
                                    "start_point": [
                                      41,
                                      0
                                    ],
                                    "end_point": [
                                      175,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Config",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    private String _ipAddr;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_ipAddr",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private int _port;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "_port",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _localIpAddr;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_localIpAddr",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private int _localPort;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "_localPort",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _method;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_method",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _password;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_password",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _logLevel;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_logLevel",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private IProxy.TYPE _proxyType;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "IProxy.TYPE",
                                          "name": "_proxyType",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          1998,
                                          2047
                                        ],
                                        "original_string": "    public Config() {\n        loadFromJson(\"\");\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "Config",
                                        "body": "                    {\n        loadFromJson(\"\");\n    }",
                                        "identifiers": "loadFromJson",
                                        "signature": "    public Config()",
                                        "signature_woname": "    public ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2053,
                                          2393
                                        ],
                                        "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "Config",
                                        "body": "                                                                                                              {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                        "identifiers": "_ipAddr ipAddr _port port _localIpAddr localIpAddr _localPort localPort _method method _password password _proxyType IProxy TYPE AUTO",
                                        "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password)",
                                        "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2399,
                                          2627
                                        ],
                                        "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "Config",
                                        "body": "                                                                                                                                {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                        "identifiers": "ipAddr port localIpAddr localPort method password _proxyType type",
                                        "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)",
                                        "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2633,
                                          2710
                                        ],
                                        "original_string": "    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setRemoteIpAddress",
                                        "body": "                                                 {\n        _ipAddr = value;\n    }",
                                        "identifiers": "_ipAddr value",
                                        "signature": "    public void setRemoteIpAddress(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2716,
                                          2782
                                        ],
                                        "original_string": "    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getRemoteIpAddress",
                                        "body": "                                       {\n        return _ipAddr;\n    }",
                                        "identifiers": "_ipAddr",
                                        "signature": "    public String getRemoteIpAddress()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2788,
                                          2869
                                        ],
                                        "original_string": "    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setLocalIpAddress",
                                        "body": "                                                {\n        _localIpAddr = value;\n    }",
                                        "identifiers": "_localIpAddr value",
                                        "signature": "    public void setLocalIpAddress(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2875,
                                          2945
                                        ],
                                        "original_string": "    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getLocalIpAddress",
                                        "body": "                                      {\n        return _localIpAddr;\n    }",
                                        "identifiers": "_localIpAddr",
                                        "signature": "    public String getLocalIpAddress()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2951,
                                          3018
                                        ],
                                        "original_string": "    public void setRemotePort(int value) {\n        _port = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setRemotePort",
                                        "body": "                                         {\n        _port = value;\n    }",
                                        "identifiers": "_port value",
                                        "signature": "    public void setRemotePort(int value)",
                                        "signature_woname": "    public void (int value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3024,
                                          3080
                                        ],
                                        "original_string": "    public int getRemotePort() {\n        return _port;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getRemotePort",
                                        "body": "                               {\n        return _port;\n    }",
                                        "identifiers": "_port",
                                        "signature": "    public int getRemotePort()",
                                        "signature_woname": "    public int ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3086,
                                          3157
                                        ],
                                        "original_string": "    public void setLocalPort(int value) {\n        _localPort = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setLocalPort",
                                        "body": "                                        {\n        _localPort = value;\n    }",
                                        "identifiers": "_localPort value",
                                        "signature": "    public void setLocalPort(int value)",
                                        "signature_woname": "    public void (int value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3163,
                                          3223
                                        ],
                                        "original_string": "    public int getLocalPort() {\n        return _localPort;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getLocalPort",
                                        "body": "                              {\n        return _localPort;\n    }",
                                        "identifiers": "_localPort",
                                        "signature": "    public int getLocalPort()",
                                        "signature_woname": "    public int ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3229,
                                          3599
                                        ],
                                        "original_string": "    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setProxyType",
                                        "body": "                                           {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                        "identifiers": "_proxyType IProxy TYPE AUTO value toLowerCase equals IProxy TYPE HTTP toString toLowerCase _proxyType IProxy TYPE HTTP value toLowerCase equals IProxy TYPE SOCKS5 toString toLowerCase _proxyType IProxy TYPE SOCKS5",
                                        "signature": "    public void setProxyType(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3605,
                                          3684
                                        ],
                                        "original_string": "    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setProxyType",
                                        "body": "                                                {\n        _proxyType = value;\n    }",
                                        "identifiers": "_proxyType value",
                                        "signature": "    public void setProxyType(IProxy.TYPE value)",
                                        "signature_woname": "    public void (IProxy.TYPE value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3689,
                                          3757
                                        ],
                                        "original_string": "    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "IProxy.TYPE",
                                          "classes": []
                                        },
                                        "name": "getProxyType",
                                        "body": "                                      {\n        return _proxyType;\n    }",
                                        "identifiers": "_proxyType",
                                        "signature": "    public IProxy.TYPE getProxyType()",
                                        "signature_woname": "    public IProxy.TYPE ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3763,
                                          3831
                                        ],
                                        "original_string": "    public void setMethod(String value) {\n        _method = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setMethod",
                                        "body": "                                        {\n        _method = value;\n    }",
                                        "identifiers": "_method value",
                                        "signature": "    public void setMethod(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3837,
                                          3894
                                        ],
                                        "original_string": "    public String getMethod() {\n        return _method;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getMethod",
                                        "body": "                              {\n        return _method;\n    }",
                                        "identifiers": "_method",
                                        "signature": "    public String getMethod()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3900,
                                          3972
                                        ],
                                        "original_string": "    public void setPassword(String value) {\n        _password = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setPassword",
                                        "body": "                                          {\n        _password = value;\n    }",
                                        "identifiers": "_password value",
                                        "signature": "    public void setPassword(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3978,
                                          4039
                                        ],
                                        "original_string": "    public String getPassword() {\n        return _password;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getPassword",
                                        "body": "                                {\n        return _password;\n    }",
                                        "identifiers": "_password",
                                        "signature": "    public String getPassword()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4045,
                                          4150
                                        ],
                                        "original_string": "    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setLogLevel",
                                        "body": "                                          {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                        "identifiers": "_logLevel value Log init getLogLevel",
                                        "signature": "    public void setLogLevel(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4156,
                                          4217
                                        ],
                                        "original_string": "    public String getLogLevel() {\n        return _logLevel;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getLogLevel",
                                        "body": "                                {\n        return _logLevel;\n    }",
                                        "identifiers": "_logLevel",
                                        "signature": "    public String getLogLevel()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4223,
                                          5070
                                        ],
                                        "original_string": "    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "loadFromJson",
                                        "body": "                                             {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                        "identifiers": "jsonStr length jsonStr jObj JSONValue parse jsonStr _ipAddr jObj getOrDefault _port jObj getOrDefault intValue _localIpAddr jObj getOrDefault _localPort jObj getOrDefault intValue _method jObj getOrDefault AesCrypt CIPHER_AES_256_CFB _password jObj getOrDefault _logLevel jObj getOrDefault setProxyType jObj getOrDefault IProxy TYPE SOCKS5 toString toLowerCase setLogLevel _logLevel",
                                        "signature": "    public void loadFromJson(String jsonStr)",
                                        "signature_woname": "    public void (String jsonStr)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          5076,
                                          5563
                                        ],
                                        "original_string": "    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "saveToJson",
                                        "body": "                               {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                        "identifiers": "jObj jObj put _ipAddr jObj put _port jObj put _localIpAddr jObj put _localPort jObj put _method jObj put _password jObj put _proxyType toString toLowerCase jObj put _logLevel Util prettyPrintJson jObj",
                                        "signature": "    public String saveToJson()",
                                        "signature_woname": "    public String ()"
                                      }
                                    ]
                                  },
                                  {
                                    "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                    "definition": "public class Util",
                                    "byte_span": [
                                      1779,
                                      7484
                                    ],
                                    "start_point": [
                                      45,
                                      0
                                    ],
                                    "end_point": [
                                      219,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Util",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          1803,
                                          2018
                                        ],
                                        "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "dumpBytes",
                                        "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                        "identifiers": "sb a length b a sb append String format b sb toString",
                                        "signature": "    public static String dumpBytes(byte[] a)",
                                        "signature_woname": "    public static String (byte[] a)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2024,
                                          2180
                                        ],
                                        "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "byte[]",
                                          "classes": []
                                        },
                                        "name": "randomBytes",
                                        "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                        "identifiers": "bytes size nextBytes bytes bytes",
                                        "signature": "    public static byte[] randomBytes(int size)",
                                        "signature_woname": "    public static byte[] (int size)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2186,
                                          2412
                                        ],
                                        "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getErrorMessage",
                                        "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                        "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                        "signature": "    public static String getErrorMessage(Throwable e)",
                                        "signature_woname": "    public static String (Throwable e)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2418,
                                          4165
                                        ],
                                        "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "prettyPrintJson",
                                        "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                        "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                        "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                        "signature_woname": "    public static String (JSONObject jObj)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4171,
                                          5829
                                        ],
                                        "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getRequestedHostInfo",
                                        "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                        "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                        "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                        "signature_woname": "    public static String (byte[] data)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          5835,
                                          6128
                                        ],
                                        "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "bytesToString",
                                        "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                        "identifiers": "str str data start length e e printStackTrace str",
                                        "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                        "signature_woname": "    public static String (byte[] data, int start, int length)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6134,
                                          6648
                                        ],
                                        "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "byte[]",
                                          "classes": []
                                        },
                                        "name": "composeSSHeader",
                                        "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                        "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                        "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                        "signature_woname": "    public static byte[] (String host, int port)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6654,
                                          6969
                                        ],
                                        "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "saveFile",
                                        "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                        "identifiers": "writer writer fn writer println content writer close e",
                                        "signature": "    public static boolean saveFile(String fn, String content)",
                                        "signature_woname": "    public static boolean (String fn, String content)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6975,
                                          7262
                                        ],
                                        "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getFileContent",
                                        "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                        "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                        "signature": "    public static String getFileContent(String fn)",
                                        "signature_woname": "    public static String (String fn)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7268,
                                          7357
                                        ],
                                        "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "short",
                                          "classes": []
                                        },
                                        "name": "byteToUnsignedByte",
                                        "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                        "identifiers": "b",
                                        "signature": "    private static short byteToUnsignedByte(byte b)",
                                        "signature_woname": "    private static short (byte b)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7363,
                                          7482
                                        ],
                                        "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getPort",
                                        "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                        "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                        "signature": "    private static int getPort(byte b, byte b1)",
                                        "signature_woname": "    private static int (byte b, byte b1)"
                                      }
                                    ]
                                  },
                                  {
                                    "original_string": "public class PipeSocket implements Runnable {\n    private Logger logger = Logger.getLogger(PipeSocket.class.getName());\n\n    private final int TIMEOUT = 10000; // 10s\n    private ByteArrayOutputStream _remoteOutStream;\n    private ByteArrayOutputStream _localOutStream;\n    private Socket _remote;\n    private Socket _local;\n    private IProxy _proxy;\n    private ICrypt _crypt;\n    private boolean _isClosed;\n    private Executor _executor;\n    private Config _config;\n\n    public PipeSocket(Executor executor, Socket socket, Config config) throws IOException {\n        _executor = executor;\n        _local = socket;\n        _local.setSoTimeout(TIMEOUT);\n        _config = config;\n        _crypt = CryptFactory.get(_config.getMethod(), _config.getPassword());\n        _proxy = ProxyFactory.get(_config.getProxyType());\n        _remoteOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n        _localOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n    }\n\n    @Override\n    public void run() {\n        try {\n            _remote = initRemote(_config);\n            _remote.setSoTimeout(TIMEOUT);\n        } catch (IOException e) {\n            close();\n            logger.warning(Util.getErrorMessage(e));\n            return;\n        }\n\n        _executor.execute(getLocalWorker());\n        _executor.execute(getRemoteWorker());\n    }\n\n    private Socket initRemote(Config config) throws IOException {\n        return new Socket(config.getRemoteIpAddress(), config.getRemotePort());\n    }\n\n    private Runnable getLocalWorker() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                byte[] dataBuffer = new byte[Constant.BUFFER_SIZE];\n                byte[] buffer;\n                int readCount;\n                List<byte[]> sendData = null;\n\n                // prepare local stream\n                try {\n                    stream = new BufferedInputStream(_local.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from local socket\n                while (true) {\n                    try {\n                         // read data\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Local socket closed (Read)!\");\n                        }\n\n                        // initialize proxy\n                        if (!_proxy.isReady()) {\n                            byte[] temp;\n                            buffer = new byte[readCount];\n\n                            // dup dataBuffer to use in later\n                            System.arraycopy(dataBuffer, 0, buffer, 0, readCount);\n\n                            temp = _proxy.getResponse(buffer);\n                            if ((temp != null) && (!_sendLocal(temp, temp.length))) {\n                                throw new IOException(\"Local socket closed (proxy-Write)!\");\n                            }\n                            // packet for remote socket\n                            sendData = _proxy.getRemoteResponse(buffer);\n                            if (sendData == null) {\n                                continue;\n                            }\n                            logger.info(\"Connected to: \" + Util.getRequestedHostInfo(sendData.get(0)));\n                        }\n                        else {\n                            sendData.clear();\n                            sendData.add(dataBuffer);\n                        }\n\n                        for (byte[] bytes : sendData) {\n                            // send data to remote socket\n                            if (!sendRemote(bytes, bytes.length)) {\n                                throw new IOException(\"Remote socket closed (Write)!\");\n                            }\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n                }\n                close();\n                logger.fine(String.format(\"localWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }\n\n    private Runnable getRemoteWorker() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                int readCount;\n                byte[] dataBuffer = new byte[4096];\n\n                // prepare remote stream\n                try {\n                    //stream = _remote.getInputStream();\n                    stream = new BufferedInputStream (_remote.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from remote socket\n                while (true) {\n                    try {\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Remote socket closed (Read)!\");\n                        }\n\n                        // send data to local socket\n                        if (!sendLocal(dataBuffer, readCount)) {\n                            throw new IOException(\"Local socket closed (Write)!\");\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n\n                }\n                close();\n                logger.fine(String.format(\"remoteWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }\n\n    public void close() {\n        if (_isClosed) {\n            return;\n        }\n        _isClosed = true;\n\n        try {\n            _local.shutdownInput();\n            _local.shutdownOutput();\n            _local.close();\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close local socket (I/O exception)!\");\n        }\n        try {\n            if (_remote != null) {\n                _remote.shutdownInput();\n                _remote.shutdownOutput();\n                _remote.close();\n            }\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close remote socket (I/O exception)!\");\n        }\n    }\n\n    private boolean sendRemote(byte[] data, int length) {\n        _crypt.encrypt(data, length, _remoteOutStream);\n        byte[] sendData = _remoteOutStream.toByteArray();\n\n        return _sendRemote(sendData, sendData.length);\n    }\n\n    private boolean _sendRemote(byte[] data, int length) {\n        try {\n            if (length > 0) {\n                OutputStream outStream = _remote.getOutputStream();\n                outStream.write(data, 0, length);\n            }\n            else {\n                logger.info(\"Nothing to sendRemote!\\n\");\n            }\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n\n        return true;\n    }\n\n    private boolean sendLocal(byte[] data, int length) {\n        _crypt.decrypt(data, length, _localOutStream);\n        byte[] sendData = _localOutStream.toByteArray();\n\n        return _sendLocal(sendData, sendData.length);\n    }\n\n    private boolean _sendLocal(byte[] data, int length) {\n        try {\n            OutputStream outStream = _local.getOutputStream();\n            outStream.write(data, 0, length);\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n        return true;\n    }\n}",
                                    "definition": "public class PipeSocket implements Runnable",
                                    "byte_span": [
                                      2033,
                                      9941
                                    ],
                                    "start_point": [
                                      51,
                                      0
                                    ],
                                    "end_point": [
                                      273,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "PipeSocket",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    private Logger logger = Logger.getLogger(PipeSocket.class.getName());",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "Logger",
                                          "name": "logger = Logger.getLogger(PipeSocket.class.getName())",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private final int TIMEOUT = 10000;",
                                          "docstring": "",
                                          "modifiers": "private final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "TIMEOUT = 10000",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private ByteArrayOutputStream _remoteOutStream;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "ByteArrayOutputStream",
                                          "name": "_remoteOutStream",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private ByteArrayOutputStream _localOutStream;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "ByteArrayOutputStream",
                                          "name": "_localOutStream",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private Socket _remote;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "Socket",
                                          "name": "_remote",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private Socket _local;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "Socket",
                                          "name": "_local",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private IProxy _proxy;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "IProxy",
                                          "name": "_proxy",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private ICrypt _crypt;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "ICrypt",
                                          "name": "_crypt",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private boolean _isClosed;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "boolean",
                                          "name": "_isClosed",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private Executor _executor;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "Executor",
                                          "name": "_executor",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private Config _config;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "Config",
                                          "name": "_config",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2508,
                                          3009
                                        ],
                                        "original_string": "    public PipeSocket(Executor executor, Socket socket, Config config) throws IOException {\n        _executor = executor;\n        _local = socket;\n        _local.setSoTimeout(TIMEOUT);\n        _config = config;\n        _crypt = CryptFactory.get(_config.getMethod(), _config.getPassword());\n        _proxy = ProxyFactory.get(_config.getProxyType());\n        _remoteOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n        _localOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "PipeSocket",
                                        "body": "                                                                                          {\n        _executor = executor;\n        _local = socket;\n        _local.setSoTimeout(TIMEOUT);\n        _config = config;\n        _crypt = CryptFactory.get(_config.getMethod(), _config.getPassword());\n        _proxy = ProxyFactory.get(_config.getProxyType());\n        _remoteOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n        _localOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n    }",
                                        "identifiers": "_executor executor _local socket _local setSoTimeout TIMEOUT _config config _crypt CryptFactory get _config getMethod _config getPassword _proxy ProxyFactory get _config getProxyType _remoteOutStream Constant BUFFER_SIZE _localOutStream Constant BUFFER_SIZE",
                                        "signature": "    public PipeSocket(Executor executor, Socket socket, Config config)",
                                        "signature_woname": "    public (Executor executor, Socket socket, Config config)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3015,
                                          3384
                                        ],
                                        "original_string": "    @Override\n    public void run() {\n        try {\n            _remote = initRemote(_config);\n            _remote.setSoTimeout(TIMEOUT);\n        } catch (IOException e) {\n            close();\n            logger.warning(Util.getErrorMessage(e));\n            return;\n        }\n\n        _executor.execute(getLocalWorker());\n        _executor.execute(getRemoteWorker());\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "@Override\n    public",
                                          "marker_annotations": [
                                            "@Override"
                                          ],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "run",
                                        "body": "                      {\n        try {\n            _remote = initRemote(_config);\n            _remote.setSoTimeout(TIMEOUT);\n        } catch (IOException e) {\n            close();\n            logger.warning(Util.getErrorMessage(e));\n            return;\n        }\n\n        _executor.execute(getLocalWorker());\n        _executor.execute(getRemoteWorker());\n    }",
                                        "identifiers": "_remote initRemote _config _remote setSoTimeout TIMEOUT e close logger warning Util getErrorMessage e _executor execute getLocalWorker _executor execute getRemoteWorker",
                                        "signature": "    @Override\n    public void run()",
                                        "signature_woname": "    @Override\n    public void ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3390,
                                          3537
                                        ],
                                        "original_string": "    private Socket initRemote(Config config) throws IOException {\n        return new Socket(config.getRemoteIpAddress(), config.getRemotePort());\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "return_type": "Socket",
                                          "classes": []
                                        },
                                        "name": "initRemote",
                                        "body": "                                                                {\n        return new Socket(config.getRemoteIpAddress(), config.getRemotePort());\n    }",
                                        "identifiers": "config getRemoteIpAddress config getRemotePort",
                                        "signature": "    private Socket initRemote(Config config)",
                                        "signature_woname": "    private Socket (Config config)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3543,
                                          6428
                                        ],
                                        "original_string": "    private Runnable getLocalWorker() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                byte[] dataBuffer = new byte[Constant.BUFFER_SIZE];\n                byte[] buffer;\n                int readCount;\n                List<byte[]> sendData = null;\n\n                // prepare local stream\n                try {\n                    stream = new BufferedInputStream(_local.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from local socket\n                while (true) {\n                    try {\n                         // read data\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Local socket closed (Read)!\");\n                        }\n\n                        // initialize proxy\n                        if (!_proxy.isReady()) {\n                            byte[] temp;\n                            buffer = new byte[readCount];\n\n                            // dup dataBuffer to use in later\n                            System.arraycopy(dataBuffer, 0, buffer, 0, readCount);\n\n                            temp = _proxy.getResponse(buffer);\n                            if ((temp != null) && (!_sendLocal(temp, temp.length))) {\n                                throw new IOException(\"Local socket closed (proxy-Write)!\");\n                            }\n                            // packet for remote socket\n                            sendData = _proxy.getRemoteResponse(buffer);\n                            if (sendData == null) {\n                                continue;\n                            }\n                            logger.info(\"Connected to: \" + Util.getRequestedHostInfo(sendData.get(0)));\n                        }\n                        else {\n                            sendData.clear();\n                            sendData.add(dataBuffer);\n                        }\n\n                        for (byte[] bytes : sendData) {\n                            // send data to remote socket\n                            if (!sendRemote(bytes, bytes.length)) {\n                                throw new IOException(\"Remote socket closed (Write)!\");\n                            }\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n                }\n                close();\n                logger.fine(String.format(\"localWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "return_type": "Runnable",
                                          "classes": []
                                        },
                                        "name": "getLocalWorker",
                                        "body": "                                      {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                byte[] dataBuffer = new byte[Constant.BUFFER_SIZE];\n                byte[] buffer;\n                int readCount;\n                List<byte[]> sendData = null;\n\n                // prepare local stream\n                try {\n                    stream = new BufferedInputStream(_local.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from local socket\n                while (true) {\n                    try {\n                         // read data\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Local socket closed (Read)!\");\n                        }\n\n                        // initialize proxy\n                        if (!_proxy.isReady()) {\n                            byte[] temp;\n                            buffer = new byte[readCount];\n\n                            // dup dataBuffer to use in later\n                            System.arraycopy(dataBuffer, 0, buffer, 0, readCount);\n\n                            temp = _proxy.getResponse(buffer);\n                            if ((temp != null) && (!_sendLocal(temp, temp.length))) {\n                                throw new IOException(\"Local socket closed (proxy-Write)!\");\n                            }\n                            // packet for remote socket\n                            sendData = _proxy.getRemoteResponse(buffer);\n                            if (sendData == null) {\n                                continue;\n                            }\n                            logger.info(\"Connected to: \" + Util.getRequestedHostInfo(sendData.get(0)));\n                        }\n                        else {\n                            sendData.clear();\n                            sendData.add(dataBuffer);\n                        }\n\n                        for (byte[] bytes : sendData) {\n                            // send data to remote socket\n                            if (!sendRemote(bytes, bytes.length)) {\n                                throw new IOException(\"Remote socket closed (Write)!\");\n                            }\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n                }\n                close();\n                logger.fine(String.format(\"localWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }",
                                        "identifiers": "Override run stream dataBuffer Constant BUFFER_SIZE buffer readCount sendData stream _local getInputStream e logger info e toString readCount stream read dataBuffer readCount _proxy isReady temp buffer readCount System arraycopy dataBuffer buffer readCount temp _proxy getResponse buffer temp _sendLocal temp temp length sendData _proxy getRemoteResponse buffer sendData logger info Util getRequestedHostInfo sendData get sendData clear sendData add dataBuffer bytes sendData sendRemote bytes bytes length e e logger fine e toString close logger fine String format _local _remote",
                                        "signature": "    private Runnable getLocalWorker()",
                                        "signature_woname": "    private Runnable ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6434,
                                          8002
                                        ],
                                        "original_string": "    private Runnable getRemoteWorker() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                int readCount;\n                byte[] dataBuffer = new byte[4096];\n\n                // prepare remote stream\n                try {\n                    //stream = _remote.getInputStream();\n                    stream = new BufferedInputStream (_remote.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from remote socket\n                while (true) {\n                    try {\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Remote socket closed (Read)!\");\n                        }\n\n                        // send data to local socket\n                        if (!sendLocal(dataBuffer, readCount)) {\n                            throw new IOException(\"Local socket closed (Write)!\");\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n\n                }\n                close();\n                logger.fine(String.format(\"remoteWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "return_type": "Runnable",
                                          "classes": []
                                        },
                                        "name": "getRemoteWorker",
                                        "body": "                                       {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                int readCount;\n                byte[] dataBuffer = new byte[4096];\n\n                // prepare remote stream\n                try {\n                    //stream = _remote.getInputStream();\n                    stream = new BufferedInputStream (_remote.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from remote socket\n                while (true) {\n                    try {\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Remote socket closed (Read)!\");\n                        }\n\n                        // send data to local socket\n                        if (!sendLocal(dataBuffer, readCount)) {\n                            throw new IOException(\"Local socket closed (Write)!\");\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n\n                }\n                close();\n                logger.fine(String.format(\"remoteWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }",
                                        "identifiers": "Override run stream readCount dataBuffer stream _remote getInputStream e logger info e toString readCount stream read dataBuffer readCount sendLocal dataBuffer readCount e e logger fine e toString close logger fine String format _local _remote",
                                        "signature": "    private Runnable getRemoteWorker()",
                                        "signature_woname": "    private Runnable ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          8008,
                                          8670
                                        ],
                                        "original_string": "    public void close() {\n        if (_isClosed) {\n            return;\n        }\n        _isClosed = true;\n\n        try {\n            _local.shutdownInput();\n            _local.shutdownOutput();\n            _local.close();\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close local socket (I/O exception)!\");\n        }\n        try {\n            if (_remote != null) {\n                _remote.shutdownInput();\n                _remote.shutdownOutput();\n                _remote.close();\n            }\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close remote socket (I/O exception)!\");\n        }\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "close",
                                        "body": "                        {\n        if (_isClosed) {\n            return;\n        }\n        _isClosed = true;\n\n        try {\n            _local.shutdownInput();\n            _local.shutdownOutput();\n            _local.close();\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close local socket (I/O exception)!\");\n        }\n        try {\n            if (_remote != null) {\n                _remote.shutdownInput();\n                _remote.shutdownOutput();\n                _remote.close();\n            }\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close remote socket (I/O exception)!\");\n        }\n    }",
                                        "identifiers": "_isClosed _isClosed _local shutdownInput _local shutdownOutput _local close e logger fine _remote _remote shutdownInput _remote shutdownOutput _remote close e logger fine",
                                        "signature": "    public void close()",
                                        "signature_woname": "    public void ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          8676,
                                          8905
                                        ],
                                        "original_string": "    private boolean sendRemote(byte[] data, int length) {\n        _crypt.encrypt(data, length, _remoteOutStream);\n        byte[] sendData = _remoteOutStream.toByteArray();\n\n        return _sendRemote(sendData, sendData.length);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "sendRemote",
                                        "body": "                                                        {\n        _crypt.encrypt(data, length, _remoteOutStream);\n        byte[] sendData = _remoteOutStream.toByteArray();\n\n        return _sendRemote(sendData, sendData.length);\n    }",
                                        "identifiers": "_crypt encrypt data length _remoteOutStream sendData _remoteOutStream toByteArray _sendRemote sendData sendData length",
                                        "signature": "    private boolean sendRemote(byte[] data, int length)",
                                        "signature_woname": "    private boolean (byte[] data, int length)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          8911,
                                          9379
                                        ],
                                        "original_string": "    private boolean _sendRemote(byte[] data, int length) {\n        try {\n            if (length > 0) {\n                OutputStream outStream = _remote.getOutputStream();\n                outStream.write(data, 0, length);\n            }\n            else {\n                logger.info(\"Nothing to sendRemote!\\n\");\n            }\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n\n        return true;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "_sendRemote",
                                        "body": "                                                         {\n        try {\n            if (length > 0) {\n                OutputStream outStream = _remote.getOutputStream();\n                outStream.write(data, 0, length);\n            }\n            else {\n                logger.info(\"Nothing to sendRemote!\\n\");\n            }\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n\n        return true;\n    }",
                                        "identifiers": "length outStream _remote getOutputStream outStream write data length logger info e logger info Util getErrorMessage e",
                                        "signature": "    private boolean _sendRemote(byte[] data, int length)",
                                        "signature_woname": "    private boolean (byte[] data, int length)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          9385,
                                          9610
                                        ],
                                        "original_string": "    private boolean sendLocal(byte[] data, int length) {\n        _crypt.decrypt(data, length, _localOutStream);\n        byte[] sendData = _localOutStream.toByteArray();\n\n        return _sendLocal(sendData, sendData.length);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "sendLocal",
                                        "body": "                                                       {\n        _crypt.decrypt(data, length, _localOutStream);\n        byte[] sendData = _localOutStream.toByteArray();\n\n        return _sendLocal(sendData, sendData.length);\n    }",
                                        "identifiers": "_crypt decrypt data length _localOutStream sendData _localOutStream toByteArray _sendLocal sendData sendData length",
                                        "signature": "    private boolean sendLocal(byte[] data, int length)",
                                        "signature_woname": "    private boolean (byte[] data, int length)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          9616,
                                          9939
                                        ],
                                        "original_string": "    private boolean _sendLocal(byte[] data, int length) {\n        try {\n            OutputStream outStream = _local.getOutputStream();\n            outStream.write(data, 0, length);\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n        return true;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "_sendLocal",
                                        "body": "                                                        {\n        try {\n            OutputStream outStream = _local.getOutputStream();\n            outStream.write(data, 0, length);\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n        return true;\n    }",
                                        "identifiers": "outStream _local getOutputStream outStream write data length e logger info Util getErrorMessage e",
                                        "signature": "    private boolean _sendLocal(byte[] data, int length)",
                                        "signature_woname": "    private boolean (byte[] data, int length)"
                                      }
                                    ]
                                  },
                                  {
                                    "original_string": "public class CryptFactory {\n    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};\n    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());\n\n    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }\n\n    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                    "definition": "public class CryptFactory",
                                    "byte_span": [
                                      1649,
                                      2693
                                    ],
                                    "start_point": [
                                      40,
                                      0
                                    ],
                                    "end_point": [
                                      71,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "CryptFactory",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};",
                                          "docstring": "",
                                          "modifiers": "private static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "Map<String, String>",
                                          "name": "crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }}",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());",
                                          "docstring": "",
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "type": "Logger",
                                          "name": "logger = Logger.getLogger(CryptFactory.class.getName())",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2057,
                                          2158
                                        ],
                                        "original_string": "    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "isCipherExisted",
                                        "body": "                                                       {\n        return (crypts.get(name) != null);\n    }",
                                        "identifiers": "crypts get name",
                                        "signature": "    public static boolean isCipherExisted(String name)",
                                        "signature_woname": "    public static boolean (String name)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2164,
                                          2504
                                        ],
                                        "original_string": "    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "ICrypt",
                                          "classes": []
                                        },
                                        "name": "get",
                                        "body": "                                                           {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                        "identifiers": "obj Reflection get crypts get name name password obj e logger info com stfl misc Util getErrorMessage e",
                                        "signature": "    public static ICrypt get(String name, String password)",
                                        "signature_woname": "    public static ICrypt (String name, String password)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2510,
                                          2691
                                        ],
                                        "original_string": "    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "List<String>",
                                          "classes": []
                                        },
                                        "name": "getSupportedCiphers",
                                        "body": "                                                     {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                        "identifiers": "sortedKeys crypts keySet Collections sort sortedKeys sortedKeys",
                                        "signature": "    public static List<String> getSupportedCiphers()",
                                        "signature_woname": "    public static List<String> ()"
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "name": "IServer.java",
                                "content": "package com.stfl.network;\n\npublic interface IServer extends Runnable {\n    void close();\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.network;"
                                  ],
                                  "methods": [],
                                  "classes": []
                                },
                                "imports": []
                              },
                              {
                                "name": "NioLocalServer.java",
                                "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network;\n\nimport com.stfl.Constant;\nimport com.stfl.misc.Config;\nimport com.stfl.misc.Util;\nimport com.stfl.network.nio.*;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.util.*;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.logging.Logger;\n\n/**\n * Non-blocking local server for shadowsocks\n */\npublic class NioLocalServer extends SocketHandlerBase {\n    private Logger logger = Logger.getLogger(NioLocalServer.class.getName());\n\n    private ServerSocketChannel _serverChannel;\n    private RemoteSocketHandler _remoteSocketHandler;\n    private ExecutorService _executor;\n\n    public NioLocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        super(config);\n        _executor = Executors.newCachedThreadPool();\n\n        // init remote socket handler\n        _remoteSocketHandler = new RemoteSocketHandler(_config);\n        _executor.execute(_remoteSocketHandler);\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(\"Cipher: \" + config.getMethod());\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }\n\n    @Override\n    protected Selector initSelector() throws IOException {\n        Selector socketSelector = SelectorProvider.provider().openSelector();\n        _serverChannel = ServerSocketChannel.open();\n        _serverChannel.configureBlocking(false);\n        InetSocketAddress isa = new InetSocketAddress(_config.getLocalIpAddress(), _config.getLocalPort());\n        _serverChannel.socket().bind(isa);\n        _serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n\n        return socketSelector;\n    }\n\n    @Override\n    protected boolean processPendingRequest(ChangeRequest request) {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                SelectionKey key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"NioLocalServer::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n        return true;\n    }\n\n    @Override\n    protected void processSelect(SelectionKey key) {\n        // Handle event\n        try {\n            if (key.isAcceptable()) {\n                accept(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        }\n        catch (IOException e) {\n            cleanUp((SocketChannel)key.channel());\n        }\n    }\n\n    private void accept(SelectionKey key) throws IOException {\n        // local socket established\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(_selector, SelectionKey.OP_READ);\n\n        // prepare local socket write queue\n        createWriteBuffer(socketChannel);\n\n        // create pipe between local and remote socket\n        PipeWorker pipe = _remoteSocketHandler.createPipe(this, socketChannel, _config.getRemoteIpAddress(), _config.getRemotePort());\n        _pipes.put(socketChannel, pipe);\n        _executor.execute(pipe);\n    }\n\n    private void read(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        int readCount;\n        PipeWorker pipe = _pipes.get(socketChannel);\n        byte[] data;\n\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        _readBuffer.clear();\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        data = _readBuffer.array();\n        pipe.processData(data, readCount, true);\n    }\n\n    private void write(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // Write data\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"LocalSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }\n\n    @Override\n    protected void cleanUp(SocketChannel socketChannel) {\n        //logger.warning(\"LocalSocket closed: \" + socketChannel);\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"LocalSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"LocalSocket closed (NULL): \" + socketChannel);\n        }\n\n    }\n\n    @Override\n    public void close() {\n        super.close();\n        _executor.shutdownNow();\n\n        try {\n            _serverChannel.close();\n            _remoteSocketHandler.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n        logger.info(\"Server closed.\");\n    }\n}\n",
                                "schema": {
                                  "file_docstring": "",
                                  "contexts": [
                                    "package com.stfl.network;",
                                    "import com.stfl.Constant;",
                                    "import com.stfl.misc.Config;",
                                    "import com.stfl.misc.Util;",
                                    "import com.stfl.network.nio.*;",
                                    "import java.io.IOException;",
                                    "import java.net.InetSocketAddress;",
                                    "import java.nio.ByteBuffer;",
                                    "import java.nio.channels.SelectionKey;",
                                    "import java.nio.channels.Selector;",
                                    "import java.nio.channels.ServerSocketChannel;",
                                    "import java.nio.channels.SocketChannel;",
                                    "import java.nio.channels.spi.SelectorProvider;",
                                    "import java.security.InvalidAlgorithmParameterException;",
                                    "import java.util.*;",
                                    "import java.util.concurrent.ExecutorService;",
                                    "import java.util.concurrent.Executors;",
                                    "import java.util.logging.Logger;"
                                  ],
                                  "methods": [],
                                  "classes": [
                                    {
                                      "original_string": "public class NioLocalServer extends SocketHandlerBase {\n    private Logger logger = Logger.getLogger(NioLocalServer.class.getName());\n\n    private ServerSocketChannel _serverChannel;\n    private RemoteSocketHandler _remoteSocketHandler;\n    private ExecutorService _executor;\n\n    public NioLocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        super(config);\n        _executor = Executors.newCachedThreadPool();\n\n        // init remote socket handler\n        _remoteSocketHandler = new RemoteSocketHandler(_config);\n        _executor.execute(_remoteSocketHandler);\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(\"Cipher: \" + config.getMethod());\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }\n\n    @Override\n    protected Selector initSelector() throws IOException {\n        Selector socketSelector = SelectorProvider.provider().openSelector();\n        _serverChannel = ServerSocketChannel.open();\n        _serverChannel.configureBlocking(false);\n        InetSocketAddress isa = new InetSocketAddress(_config.getLocalIpAddress(), _config.getLocalPort());\n        _serverChannel.socket().bind(isa);\n        _serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n\n        return socketSelector;\n    }\n\n    @Override\n    protected boolean processPendingRequest(ChangeRequest request) {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                SelectionKey key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"NioLocalServer::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n        return true;\n    }\n\n    @Override\n    protected void processSelect(SelectionKey key) {\n        // Handle event\n        try {\n            if (key.isAcceptable()) {\n                accept(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        }\n        catch (IOException e) {\n            cleanUp((SocketChannel)key.channel());\n        }\n    }\n\n    private void accept(SelectionKey key) throws IOException {\n        // local socket established\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(_selector, SelectionKey.OP_READ);\n\n        // prepare local socket write queue\n        createWriteBuffer(socketChannel);\n\n        // create pipe between local and remote socket\n        PipeWorker pipe = _remoteSocketHandler.createPipe(this, socketChannel, _config.getRemoteIpAddress(), _config.getRemotePort());\n        _pipes.put(socketChannel, pipe);\n        _executor.execute(pipe);\n    }\n\n    private void read(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        int readCount;\n        PipeWorker pipe = _pipes.get(socketChannel);\n        byte[] data;\n\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        _readBuffer.clear();\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        data = _readBuffer.array();\n        pipe.processData(data, readCount, true);\n    }\n\n    private void write(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // Write data\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"LocalSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }\n\n    @Override\n    protected void cleanUp(SocketChannel socketChannel) {\n        //logger.warning(\"LocalSocket closed: \" + socketChannel);\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"LocalSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"LocalSocket closed (NULL): \" + socketChannel);\n        }\n\n    }\n\n    @Override\n    public void close() {\n        super.close();\n        _executor.shutdownNow();\n\n        try {\n            _serverChannel.close();\n            _remoteSocketHandler.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n        logger.info(\"Server closed.\");\n    }\n}",
                                      "definition": "public class NioLocalServer extends SocketHandlerBase",
                                      "byte_span": [
                                        2202,
                                        7856
                                      ],
                                      "start_point": [
                                        55,
                                        0
                                      ],
                                      "end_point": [
                                        225,
                                        1
                                      ],
                                      "class_docstring": "",
                                      "name": "NioLocalServer",
                                      "attributes": {
                                        "modifiers": "public",
                                        "marker_annotations": [],
                                        "non_marker_annotations": [
                                          "public"
                                        ],
                                        "comments": [],
                                        "fields": [
                                          {
                                            "attribute_expression": "    private Logger logger = Logger.getLogger(NioLocalServer.class.getName());",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "Logger",
                                            "name": "logger = Logger.getLogger(NioLocalServer.class.getName())",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private ServerSocketChannel _serverChannel;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "ServerSocketChannel",
                                            "name": "_serverChannel",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private RemoteSocketHandler _remoteSocketHandler;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "RemoteSocketHandler",
                                            "name": "_remoteSocketHandler",
                                            "syntax_pass": true
                                          },
                                          {
                                            "attribute_expression": "    private ExecutorService _executor;",
                                            "docstring": "",
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "type": "ExecutorService",
                                            "name": "_executor",
                                            "syntax_pass": true
                                          }
                                        ],
                                        "classes": []
                                      },
                                      "syntax_pass": true,
                                      "methods": [
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            2483,
                                            3060
                                          ],
                                          "original_string": "    public NioLocalServer(Config config) throws IOException, InvalidAlgorithmParameterException {\n        super(config);\n        _executor = Executors.newCachedThreadPool();\n\n        // init remote socket handler\n        _remoteSocketHandler = new RemoteSocketHandler(_config);\n        _executor.execute(_remoteSocketHandler);\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(\"Cipher: \" + config.getMethod());\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "",
                                            "classes": []
                                          },
                                          "name": "NioLocalServer",
                                          "body": "                                                                                                {\n        super(config);\n        _executor = Executors.newCachedThreadPool();\n\n        // init remote socket handler\n        _remoteSocketHandler = new RemoteSocketHandler(_config);\n        _executor.execute(_remoteSocketHandler);\n\n        // print server info\n        logger.info(\"Shadowsocks-Java v\" + Constant.VERSION);\n        logger.info(\"Cipher: \" + config.getMethod());\n        logger.info(config.getProxyType() + \" Proxy Server starts at port: \" + config.getLocalPort());\n    }",
                                          "identifiers": "config _executor Executors newCachedThreadPool _remoteSocketHandler _config _executor execute _remoteSocketHandler logger info Constant VERSION logger info config getMethod logger info config getProxyType config getLocalPort",
                                          "signature": "    public NioLocalServer(Config config)",
                                          "signature_woname": "    public (Config config)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3066,
                                            3576
                                          ],
                                          "original_string": "    @Override\n    protected Selector initSelector() throws IOException {\n        Selector socketSelector = SelectorProvider.provider().openSelector();\n        _serverChannel = ServerSocketChannel.open();\n        _serverChannel.configureBlocking(false);\n        InetSocketAddress isa = new InetSocketAddress(_config.getLocalIpAddress(), _config.getLocalPort());\n        _serverChannel.socket().bind(isa);\n        _serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n\n        return socketSelector;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "Selector",
                                            "classes": []
                                          },
                                          "name": "initSelector",
                                          "body": "                                                         {\n        Selector socketSelector = SelectorProvider.provider().openSelector();\n        _serverChannel = ServerSocketChannel.open();\n        _serverChannel.configureBlocking(false);\n        InetSocketAddress isa = new InetSocketAddress(_config.getLocalIpAddress(), _config.getLocalPort());\n        _serverChannel.socket().bind(isa);\n        _serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n\n        return socketSelector;\n    }",
                                          "identifiers": "socketSelector SelectorProvider provider openSelector _serverChannel ServerSocketChannel open _serverChannel configureBlocking isa _config getLocalIpAddress _config getLocalPort _serverChannel socket bind isa _serverChannel register socketSelector SelectionKey OP_ACCEPT socketSelector",
                                          "signature": "    @Override\n    protected Selector initSelector()",
                                          "signature_woname": "    @Override\n    protected Selector ()"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            3582,
                                            4235
                                          ],
                                          "original_string": "    @Override\n    protected boolean processPendingRequest(ChangeRequest request) {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                SelectionKey key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"NioLocalServer::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n        return true;\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "boolean",
                                            "classes": []
                                          },
                                          "name": "processPendingRequest",
                                          "body": "                                                                   {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                SelectionKey key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"NioLocalServer::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n        return true;\n    }",
                                          "identifiers": "request type ChangeRequest CHANGE_SOCKET_OP key request socket keyFor _selector key key isValid key interestOps request op logger warning key request socket ChangeRequest CLOSE_CHANNEL cleanUp request socket",
                                          "signature": "    @Override\n    protected boolean processPendingRequest(ChangeRequest request)",
                                          "signature_woname": "    @Override\n    protected boolean (ChangeRequest request)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4241,
                                            4672
                                          ],
                                          "original_string": "    @Override\n    protected void processSelect(SelectionKey key) {\n        // Handle event\n        try {\n            if (key.isAcceptable()) {\n                accept(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        }\n        catch (IOException e) {\n            cleanUp((SocketChannel)key.channel());\n        }\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "processSelect",
                                          "body": "                                                   {\n        // Handle event\n        try {\n            if (key.isAcceptable()) {\n                accept(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        }\n        catch (IOException e) {\n            cleanUp((SocketChannel)key.channel());\n        }\n    }",
                                          "identifiers": "key isAcceptable accept key key isReadable read key key isWritable write key e cleanUp key channel",
                                          "signature": "    @Override\n    protected void processSelect(SelectionKey key)",
                                          "signature_woname": "    @Override\n    protected void (SelectionKey key)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            4678,
                                            5398
                                          ],
                                          "original_string": "    private void accept(SelectionKey key) throws IOException {\n        // local socket established\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(_selector, SelectionKey.OP_READ);\n\n        // prepare local socket write queue\n        createWriteBuffer(socketChannel);\n\n        // create pipe between local and remote socket\n        PipeWorker pipe = _remoteSocketHandler.createPipe(this, socketChannel, _config.getRemoteIpAddress(), _config.getRemotePort());\n        _pipes.put(socketChannel, pipe);\n        _executor.execute(pipe);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "accept",
                                          "body": "                                                             {\n        // local socket established\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(_selector, SelectionKey.OP_READ);\n\n        // prepare local socket write queue\n        createWriteBuffer(socketChannel);\n\n        // create pipe between local and remote socket\n        PipeWorker pipe = _remoteSocketHandler.createPipe(this, socketChannel, _config.getRemoteIpAddress(), _config.getRemotePort());\n        _pipes.put(socketChannel, pipe);\n        _executor.execute(pipe);\n    }",
                                          "identifiers": "serverSocketChannel key channel socketChannel serverSocketChannel accept socketChannel configureBlocking socketChannel register _selector SelectionKey OP_READ createWriteBuffer socketChannel pipe _remoteSocketHandler createPipe socketChannel _config getRemoteIpAddress _config getRemotePort _pipes put socketChannel pipe _executor execute pipe",
                                          "signature": "    private void accept(SelectionKey key)",
                                          "signature_woname": "    private void (SelectionKey key)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            5404,
                                            6145
                                          ],
                                          "original_string": "    private void read(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        int readCount;\n        PipeWorker pipe = _pipes.get(socketChannel);\n        byte[] data;\n\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        _readBuffer.clear();\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        data = _readBuffer.array();\n        pipe.processData(data, readCount, true);\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "read",
                                          "body": "                                                           {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        int readCount;\n        PipeWorker pipe = _pipes.get(socketChannel);\n        byte[] data;\n\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        _readBuffer.clear();\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        data = _readBuffer.array();\n        pipe.processData(data, readCount, true);\n    }",
                                          "identifiers": "socketChannel key channel readCount pipe _pipes get socketChannel data pipe cleanUp socketChannel _readBuffer clear readCount socketChannel read _readBuffer e cleanUp socketChannel readCount cleanUp socketChannel data _readBuffer array pipe processData data readCount",
                                          "signature": "    private void read(SelectionKey key)",
                                          "signature_woname": "    private void (SelectionKey key)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            6151,
                                            7014
                                          ],
                                          "original_string": "    private void write(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // Write data\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"LocalSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "private",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "private"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "write",
                                          "body": "                                                            {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // Write data\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"LocalSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }",
                                          "identifiers": "socketChannel key channel queue _pendingData get socketChannel queue queue queue isEmpty buf queue get socketChannel write buf buf remaining queue remove queue isEmpty key interestOps SelectionKey OP_READ logger warning socketChannel",
                                          "signature": "    private void write(SelectionKey key)",
                                          "signature_woname": "    private void (SelectionKey key)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            7020,
                                            7522
                                          ],
                                          "original_string": "    @Override\n    protected void cleanUp(SocketChannel socketChannel) {\n        //logger.warning(\"LocalSocket closed: \" + socketChannel);\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"LocalSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"LocalSocket closed (NULL): \" + socketChannel);\n        }\n\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    protected",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "protected"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "cleanUp",
                                          "body": "                                                        {\n        //logger.warning(\"LocalSocket closed: \" + socketChannel);\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"LocalSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"LocalSocket closed (NULL): \" + socketChannel);\n        }\n\n    }",
                                          "identifiers": "cleanUp socketChannel pipe _pipes get socketChannel pipe pipe close _pipes remove socketChannel logger fine pipe socketInfo logger fine socketChannel",
                                          "signature": "    @Override\n    protected void cleanUp(SocketChannel socketChannel)",
                                          "signature_woname": "    @Override\n    protected void (SocketChannel socketChannel)"
                                        },
                                        {
                                          "syntax_pass": true,
                                          "byte_span": [
                                            7528,
                                            7854
                                          ],
                                          "original_string": "    @Override\n    public void close() {\n        super.close();\n        _executor.shutdownNow();\n\n        try {\n            _serverChannel.close();\n            _remoteSocketHandler.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n        logger.info(\"Server closed.\");\n    }",
                                          "docstring": "",
                                          "attributes": {
                                            "modifiers": "@Override\n    public",
                                            "marker_annotations": [
                                              "@Override"
                                            ],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "return_type": "void",
                                            "classes": []
                                          },
                                          "name": "close",
                                          "body": "                        {\n        super.close();\n        _executor.shutdownNow();\n\n        try {\n            _serverChannel.close();\n            _remoteSocketHandler.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n        logger.info(\"Server closed.\");\n    }",
                                          "identifiers": "close _executor shutdownNow _serverChannel close _remoteSocketHandler close e logger warning Util getErrorMessage e logger info",
                                          "signature": "    @Override\n    public void close()",
                                          "signature_woname": "    @Override\n    public void ()"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "imports": [
                                  {
                                    "original_string": "public class Constant {\n    public static final String PROG_NAME = \"shadowsocks-java\";\n    public static final String VERSION = \"0.2\";\n    public static final int BUFFER_SIZE = 16384;\n    public static final String CONF_FILE = \"config.json\";\n    public static final Locale LOCALE = Locale.getDefault();\n}",
                                    "definition": "public class Constant",
                                    "byte_span": [
                                      45,
                                      349
                                    ],
                                    "start_point": [
                                      4,
                                      0
                                    ],
                                    "end_point": [
                                      10,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Constant",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    public static final String PROG_NAME = \"shadowsocks-java\";",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "PROG_NAME = \"shadowsocks-java\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final String VERSION = \"0.2\";",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "VERSION = \"0.2\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final int BUFFER_SIZE = 16384;",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "BUFFER_SIZE = 16384",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final String CONF_FILE = \"config.json\";",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "CONF_FILE = \"config.json\"",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    public static final Locale LOCALE = Locale.getDefault();",
                                          "docstring": "",
                                          "modifiers": "public static final",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static",
                                            "final"
                                          ],
                                          "comments": [],
                                          "type": "Locale",
                                          "name": "LOCALE = Locale.getDefault()",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": []
                                  },
                                  {
                                    "original_string": "public class Config {\n    private String _ipAddr;\n    private int _port;\n    private String _localIpAddr;\n    private int _localPort;\n    private String _method;\n    private String _password;\n    private String _logLevel;\n    private IProxy.TYPE _proxyType;\n\n    public Config() {\n        loadFromJson(\"\");\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }\n\n    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }\n\n    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }\n\n    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }\n\n    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }\n\n    public void setRemotePort(int value) {\n        _port = value;\n    }\n\n    public int getRemotePort() {\n        return _port;\n    }\n\n    public void setLocalPort(int value) {\n        _localPort = value;\n    }\n\n    public int getLocalPort() {\n        return _localPort;\n    }\n\n    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }\n\n    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }\n    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }\n\n    public void setMethod(String value) {\n        _method = value;\n    }\n\n    public String getMethod() {\n        return _method;\n    }\n\n    public void setPassword(String value) {\n        _password = value;\n    }\n\n    public String getPassword() {\n        return _password;\n    }\n\n    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }\n\n    public String getLogLevel() {\n        return _logLevel;\n    }\n\n    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }\n\n    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }\n}",
                                    "definition": "public class Config",
                                    "byte_span": [
                                      1735,
                                      5565
                                    ],
                                    "start_point": [
                                      41,
                                      0
                                    ],
                                    "end_point": [
                                      175,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Config",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [
                                        {
                                          "attribute_expression": "    private String _ipAddr;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_ipAddr",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private int _port;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "_port",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _localIpAddr;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_localIpAddr",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private int _localPort;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "int",
                                          "name": "_localPort",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _method;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_method",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _password;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_password",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private String _logLevel;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "String",
                                          "name": "_logLevel",
                                          "syntax_pass": true
                                        },
                                        {
                                          "attribute_expression": "    private IProxy.TYPE _proxyType;",
                                          "docstring": "",
                                          "modifiers": "private",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private"
                                          ],
                                          "comments": [],
                                          "type": "IProxy.TYPE",
                                          "name": "_proxyType",
                                          "syntax_pass": true
                                        }
                                      ],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          1998,
                                          2047
                                        ],
                                        "original_string": "    public Config() {\n        loadFromJson(\"\");\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "Config",
                                        "body": "                    {\n        loadFromJson(\"\");\n    }",
                                        "identifiers": "loadFromJson",
                                        "signature": "    public Config()",
                                        "signature_woname": "    public ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2053,
                                          2393
                                        ],
                                        "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "Config",
                                        "body": "                                                                                                              {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                        "identifiers": "_ipAddr ipAddr _port port _localIpAddr localIpAddr _localPort localPort _method method _password password _proxyType IProxy TYPE AUTO",
                                        "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password)",
                                        "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2399,
                                          2627
                                        ],
                                        "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "",
                                          "classes": []
                                        },
                                        "name": "Config",
                                        "body": "                                                                                                                                {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                        "identifiers": "ipAddr port localIpAddr localPort method password _proxyType type",
                                        "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)",
                                        "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2633,
                                          2710
                                        ],
                                        "original_string": "    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setRemoteIpAddress",
                                        "body": "                                                 {\n        _ipAddr = value;\n    }",
                                        "identifiers": "_ipAddr value",
                                        "signature": "    public void setRemoteIpAddress(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2716,
                                          2782
                                        ],
                                        "original_string": "    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getRemoteIpAddress",
                                        "body": "                                       {\n        return _ipAddr;\n    }",
                                        "identifiers": "_ipAddr",
                                        "signature": "    public String getRemoteIpAddress()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2788,
                                          2869
                                        ],
                                        "original_string": "    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setLocalIpAddress",
                                        "body": "                                                {\n        _localIpAddr = value;\n    }",
                                        "identifiers": "_localIpAddr value",
                                        "signature": "    public void setLocalIpAddress(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2875,
                                          2945
                                        ],
                                        "original_string": "    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getLocalIpAddress",
                                        "body": "                                      {\n        return _localIpAddr;\n    }",
                                        "identifiers": "_localIpAddr",
                                        "signature": "    public String getLocalIpAddress()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2951,
                                          3018
                                        ],
                                        "original_string": "    public void setRemotePort(int value) {\n        _port = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setRemotePort",
                                        "body": "                                         {\n        _port = value;\n    }",
                                        "identifiers": "_port value",
                                        "signature": "    public void setRemotePort(int value)",
                                        "signature_woname": "    public void (int value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3024,
                                          3080
                                        ],
                                        "original_string": "    public int getRemotePort() {\n        return _port;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getRemotePort",
                                        "body": "                               {\n        return _port;\n    }",
                                        "identifiers": "_port",
                                        "signature": "    public int getRemotePort()",
                                        "signature_woname": "    public int ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3086,
                                          3157
                                        ],
                                        "original_string": "    public void setLocalPort(int value) {\n        _localPort = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setLocalPort",
                                        "body": "                                        {\n        _localPort = value;\n    }",
                                        "identifiers": "_localPort value",
                                        "signature": "    public void setLocalPort(int value)",
                                        "signature_woname": "    public void (int value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3163,
                                          3223
                                        ],
                                        "original_string": "    public int getLocalPort() {\n        return _localPort;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getLocalPort",
                                        "body": "                              {\n        return _localPort;\n    }",
                                        "identifiers": "_localPort",
                                        "signature": "    public int getLocalPort()",
                                        "signature_woname": "    public int ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3229,
                                          3599
                                        ],
                                        "original_string": "    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setProxyType",
                                        "body": "                                           {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                        "identifiers": "_proxyType IProxy TYPE AUTO value toLowerCase equals IProxy TYPE HTTP toString toLowerCase _proxyType IProxy TYPE HTTP value toLowerCase equals IProxy TYPE SOCKS5 toString toLowerCase _proxyType IProxy TYPE SOCKS5",
                                        "signature": "    public void setProxyType(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3605,
                                          3684
                                        ],
                                        "original_string": "    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setProxyType",
                                        "body": "                                                {\n        _proxyType = value;\n    }",
                                        "identifiers": "_proxyType value",
                                        "signature": "    public void setProxyType(IProxy.TYPE value)",
                                        "signature_woname": "    public void (IProxy.TYPE value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3689,
                                          3757
                                        ],
                                        "original_string": "    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "IProxy.TYPE",
                                          "classes": []
                                        },
                                        "name": "getProxyType",
                                        "body": "                                      {\n        return _proxyType;\n    }",
                                        "identifiers": "_proxyType",
                                        "signature": "    public IProxy.TYPE getProxyType()",
                                        "signature_woname": "    public IProxy.TYPE ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3763,
                                          3831
                                        ],
                                        "original_string": "    public void setMethod(String value) {\n        _method = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setMethod",
                                        "body": "                                        {\n        _method = value;\n    }",
                                        "identifiers": "_method value",
                                        "signature": "    public void setMethod(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3837,
                                          3894
                                        ],
                                        "original_string": "    public String getMethod() {\n        return _method;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getMethod",
                                        "body": "                              {\n        return _method;\n    }",
                                        "identifiers": "_method",
                                        "signature": "    public String getMethod()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3900,
                                          3972
                                        ],
                                        "original_string": "    public void setPassword(String value) {\n        _password = value;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setPassword",
                                        "body": "                                          {\n        _password = value;\n    }",
                                        "identifiers": "_password value",
                                        "signature": "    public void setPassword(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          3978,
                                          4039
                                        ],
                                        "original_string": "    public String getPassword() {\n        return _password;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getPassword",
                                        "body": "                                {\n        return _password;\n    }",
                                        "identifiers": "_password",
                                        "signature": "    public String getPassword()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4045,
                                          4150
                                        ],
                                        "original_string": "    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "setLogLevel",
                                        "body": "                                          {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                        "identifiers": "_logLevel value Log init getLogLevel",
                                        "signature": "    public void setLogLevel(String value)",
                                        "signature_woname": "    public void (String value)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4156,
                                          4217
                                        ],
                                        "original_string": "    public String getLogLevel() {\n        return _logLevel;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getLogLevel",
                                        "body": "                                {\n        return _logLevel;\n    }",
                                        "identifiers": "_logLevel",
                                        "signature": "    public String getLogLevel()",
                                        "signature_woname": "    public String ()"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4223,
                                          5070
                                        ],
                                        "original_string": "    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "void",
                                          "classes": []
                                        },
                                        "name": "loadFromJson",
                                        "body": "                                             {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                        "identifiers": "jsonStr length jsonStr jObj JSONValue parse jsonStr _ipAddr jObj getOrDefault _port jObj getOrDefault intValue _localIpAddr jObj getOrDefault _localPort jObj getOrDefault intValue _method jObj getOrDefault AesCrypt CIPHER_AES_256_CFB _password jObj getOrDefault _logLevel jObj getOrDefault setProxyType jObj getOrDefault IProxy TYPE SOCKS5 toString toLowerCase setLogLevel _logLevel",
                                        "signature": "    public void loadFromJson(String jsonStr)",
                                        "signature_woname": "    public void (String jsonStr)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          5076,
                                          5563
                                        ],
                                        "original_string": "    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "saveToJson",
                                        "body": "                               {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                        "identifiers": "jObj jObj put _ipAddr jObj put _port jObj put _localIpAddr jObj put _localPort jObj put _method jObj put _password jObj put _proxyType toString toLowerCase jObj put _logLevel Util prettyPrintJson jObj",
                                        "signature": "    public String saveToJson()",
                                        "signature_woname": "    public String ()"
                                      }
                                    ]
                                  },
                                  {
                                    "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                    "definition": "public class Util",
                                    "byte_span": [
                                      1779,
                                      7484
                                    ],
                                    "start_point": [
                                      45,
                                      0
                                    ],
                                    "end_point": [
                                      219,
                                      1
                                    ],
                                    "class_docstring": "",
                                    "name": "Util",
                                    "attributes": {
                                      "modifiers": "public",
                                      "marker_annotations": [],
                                      "non_marker_annotations": [
                                        "public"
                                      ],
                                      "comments": [],
                                      "fields": [],
                                      "classes": []
                                    },
                                    "syntax_pass": true,
                                    "methods": [
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          1803,
                                          2018
                                        ],
                                        "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "dumpBytes",
                                        "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                        "identifiers": "sb a length b a sb append String format b sb toString",
                                        "signature": "    public static String dumpBytes(byte[] a)",
                                        "signature_woname": "    public static String (byte[] a)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2024,
                                          2180
                                        ],
                                        "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "byte[]",
                                          "classes": []
                                        },
                                        "name": "randomBytes",
                                        "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                        "identifiers": "bytes size nextBytes bytes bytes",
                                        "signature": "    public static byte[] randomBytes(int size)",
                                        "signature_woname": "    public static byte[] (int size)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2186,
                                          2412
                                        ],
                                        "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getErrorMessage",
                                        "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                        "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                        "signature": "    public static String getErrorMessage(Throwable e)",
                                        "signature_woname": "    public static String (Throwable e)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          2418,
                                          4165
                                        ],
                                        "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "prettyPrintJson",
                                        "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                        "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                        "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                        "signature_woname": "    public static String (JSONObject jObj)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          4171,
                                          5829
                                        ],
                                        "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getRequestedHostInfo",
                                        "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                        "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                        "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                        "signature_woname": "    public static String (byte[] data)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          5835,
                                          6128
                                        ],
                                        "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "bytesToString",
                                        "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                        "identifiers": "str str data start length e e printStackTrace str",
                                        "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                        "signature_woname": "    public static String (byte[] data, int start, int length)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6134,
                                          6648
                                        ],
                                        "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "byte[]",
                                          "classes": []
                                        },
                                        "name": "composeSSHeader",
                                        "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                        "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                        "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                        "signature_woname": "    public static byte[] (String host, int port)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6654,
                                          6969
                                        ],
                                        "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "boolean",
                                          "classes": []
                                        },
                                        "name": "saveFile",
                                        "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                        "identifiers": "writer writer fn writer println content writer close e",
                                        "signature": "    public static boolean saveFile(String fn, String content)",
                                        "signature_woname": "    public static boolean (String fn, String content)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          6975,
                                          7262
                                        ],
                                        "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "public static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "String",
                                          "classes": []
                                        },
                                        "name": "getFileContent",
                                        "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                        "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                        "signature": "    public static String getFileContent(String fn)",
                                        "signature_woname": "    public static String (String fn)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7268,
                                          7357
                                        ],
                                        "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "short",
                                          "classes": []
                                        },
                                        "name": "byteToUnsignedByte",
                                        "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                        "identifiers": "b",
                                        "signature": "    private static short byteToUnsignedByte(byte b)",
                                        "signature_woname": "    private static short (byte b)"
                                      },
                                      {
                                        "syntax_pass": true,
                                        "byte_span": [
                                          7363,
                                          7482
                                        ],
                                        "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                        "docstring": "",
                                        "attributes": {
                                          "modifiers": "private static",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "private",
                                            "static"
                                          ],
                                          "comments": [],
                                          "return_type": "int",
                                          "classes": []
                                        },
                                        "name": "getPort",
                                        "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                        "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                        "signature": "    private static int getPort(byte b, byte b1)",
                                        "signature_woname": "    private static int (byte b, byte b1)"
                                      }
                                    ]
                                  }
                                ]
                              }
                            ],
                            "subdirs": [
                              {
                                "dir": "nio",
                                "files": [
                                  {
                                    "name": "PipeWorker.java",
                                    "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network.nio;\n\nimport com.stfl.misc.Config;\nimport com.stfl.misc.Util;\nimport com.stfl.Constant;\nimport com.stfl.network.proxy.IProxy;\nimport com.stfl.network.proxy.ProxyFactory;\nimport com.stfl.ss.CryptFactory;\nimport com.stfl.ss.ICrypt;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.logging.Logger;\n\n\npublic class PipeWorker implements Runnable {\n    private Logger logger = Logger.getLogger(PipeWorker.class.getName());\n    private SocketChannel _localChannel;\n    private SocketChannel _remoteChannel;\n    private ISocketHandler _localSocketHandler;\n    private ISocketHandler _remoteSocketHandler;\n    private IProxy _proxy;\n    private ICrypt _crypt;\n    public String socketInfo;\n    private ByteArrayOutputStream _outStream;\n    private BlockingQueue _processQueue;\n    private volatile boolean requestedClose;\n\n    public PipeWorker(ISocketHandler localHandler, SocketChannel localChannel, ISocketHandler remoteHandler, SocketChannel remoteChannel, Config config) {\n        _localChannel = localChannel;\n        _remoteChannel = remoteChannel;\n        _localSocketHandler = localHandler;\n        _remoteSocketHandler = remoteHandler;\n        _crypt = CryptFactory.get(config.getMethod(), config.getPassword());\n        _proxy = ProxyFactory.get(config.getProxyType());\n        _outStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n        _processQueue = new LinkedBlockingQueue();\n        requestedClose = false;\n        socketInfo = String.format(\"Local: %s, Remote: %s\", localChannel, remoteChannel);\n    }\n\n    public void close() {\n        requestedClose = true;\n        processData(null, 0, false);\n    }\n\n    public void forceClose() {\n        logger.fine(\"PipeWorker::forceClose \" + socketInfo);\n\n        // close socket now!\n        try {\n            if (_localChannel.isOpen()) {\n                _localChannel.close();\n            }\n            if (_remoteChannel.isOpen()) {\n                _remoteChannel.close();\n            }\n        } catch (IOException e) {\n            logger.fine(\"PipeWorker::forceClose> \" + e.toString());\n        }\n\n        // follow the standard close steps\n        close();\n    }\n\n    public void processData(byte[] data, int count, boolean isEncrypted) {\n        if (data != null) {\n            byte[] dataCopy = new byte[count];\n            System.arraycopy(data, 0, dataCopy, 0, count);\n            _processQueue.add(new PipeEvent(dataCopy, isEncrypted));\n        }\n        else {\n            _processQueue.add(new PipeEvent());\n        }\n    }\n\n    @Override\n    public void run() {\n        PipeEvent event;\n        ISocketHandler socketHandler;\n        SocketChannel channel;\n        List<byte[]> sendData = null;\n\n        while(true) {\n            // make sure all the requests in the queue are processed\n            if (_processQueue.isEmpty() && requestedClose) {\n                logger.fine(\"PipeWorker closed (\"+  _processQueue.size() + \"): \" + this.socketInfo);\n                if (_localChannel.isOpen()) {\n                    _localSocketHandler.send(new ChangeRequest(_localChannel, ChangeRequest.CLOSE_CHANNEL));\n                }\n                if (_remoteChannel.isOpen()) {\n                    _remoteSocketHandler.send(new ChangeRequest(_remoteChannel, ChangeRequest.CLOSE_CHANNEL));\n                }\n                break;\n            }\n\n            try {\n                event = (PipeEvent)_processQueue.take();\n\n                // if event data is null, it means this is a wake-up call\n                // to check if any other thread is requested to close sockets\n                if (event.data == null) {\n                    continue;\n                }\n\n                // process proxy packet if needed\n                if (!_proxy.isReady()) {\n                    // packet for local socket\n                    byte[] temp = _proxy.getResponse(event.data);\n                    if (temp != null) {\n                        _localSocketHandler.send(new ChangeRequest(_localChannel, ChangeRequest.CHANGE_SOCKET_OP,\n                                SelectionKey.OP_WRITE), temp);\n                    }\n                    // packet for remote socket (ss payload + request)\n                    sendData = _proxy.getRemoteResponse(event.data);\n                    if (sendData == null) {\n                        continue;\n                    }\n                    // index 0 is always ss payload\n                    logger.info(\"Connected to: \" + Util.getRequestedHostInfo(sendData.get(0)));\n                    //logger.info(\"Test: \" + Util.bytesToString(temp, 0, temp.length));\n                }\n                else {\n                    sendData.clear();\n                    sendData.add(event.data);\n                }\n\n                for (byte[] bytes : sendData) {\n                    // empty stream for new data\n                    _outStream.reset();\n\n                    if (event.isEncrypted) {\n                        _crypt.encrypt(bytes, _outStream);\n                        channel = _remoteChannel;\n                        socketHandler = _remoteSocketHandler;\n                    } else {\n                        _crypt.decrypt(bytes, _outStream);\n                        channel = _localChannel;\n                        socketHandler = _localSocketHandler;\n                    }\n\n                    // data is ready to send to socket\n                    ChangeRequest request = new ChangeRequest(channel, ChangeRequest.CHANGE_SOCKET_OP, SelectionKey.OP_WRITE);\n                    socketHandler.send(request, _outStream.toByteArray());\n                }\n            } catch (InterruptedException e) {\n                logger.fine(Util.getErrorMessage(e));\n                break;\n            }\n        }\n    }\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.nio;",
                                        "import com.stfl.misc.Config;",
                                        "import com.stfl.misc.Util;",
                                        "import com.stfl.Constant;",
                                        "import com.stfl.network.proxy.IProxy;",
                                        "import com.stfl.network.proxy.ProxyFactory;",
                                        "import com.stfl.ss.CryptFactory;",
                                        "import com.stfl.ss.ICrypt;",
                                        "import java.io.ByteArrayOutputStream;",
                                        "import java.io.IOException;",
                                        "import java.nio.channels.SelectionKey;",
                                        "import java.nio.channels.SocketChannel;",
                                        "import java.util.List;",
                                        "import java.util.concurrent.BlockingQueue;",
                                        "import java.util.concurrent.LinkedBlockingQueue;",
                                        "import java.util.logging.Logger;"
                                      ],
                                      "methods": [],
                                      "classes": [
                                        {
                                          "original_string": "public class PipeWorker implements Runnable {\n    private Logger logger = Logger.getLogger(PipeWorker.class.getName());\n    private SocketChannel _localChannel;\n    private SocketChannel _remoteChannel;\n    private ISocketHandler _localSocketHandler;\n    private ISocketHandler _remoteSocketHandler;\n    private IProxy _proxy;\n    private ICrypt _crypt;\n    public String socketInfo;\n    private ByteArrayOutputStream _outStream;\n    private BlockingQueue _processQueue;\n    private volatile boolean requestedClose;\n\n    public PipeWorker(ISocketHandler localHandler, SocketChannel localChannel, ISocketHandler remoteHandler, SocketChannel remoteChannel, Config config) {\n        _localChannel = localChannel;\n        _remoteChannel = remoteChannel;\n        _localSocketHandler = localHandler;\n        _remoteSocketHandler = remoteHandler;\n        _crypt = CryptFactory.get(config.getMethod(), config.getPassword());\n        _proxy = ProxyFactory.get(config.getProxyType());\n        _outStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n        _processQueue = new LinkedBlockingQueue();\n        requestedClose = false;\n        socketInfo = String.format(\"Local: %s, Remote: %s\", localChannel, remoteChannel);\n    }\n\n    public void close() {\n        requestedClose = true;\n        processData(null, 0, false);\n    }\n\n    public void forceClose() {\n        logger.fine(\"PipeWorker::forceClose \" + socketInfo);\n\n        // close socket now!\n        try {\n            if (_localChannel.isOpen()) {\n                _localChannel.close();\n            }\n            if (_remoteChannel.isOpen()) {\n                _remoteChannel.close();\n            }\n        } catch (IOException e) {\n            logger.fine(\"PipeWorker::forceClose> \" + e.toString());\n        }\n\n        // follow the standard close steps\n        close();\n    }\n\n    public void processData(byte[] data, int count, boolean isEncrypted) {\n        if (data != null) {\n            byte[] dataCopy = new byte[count];\n            System.arraycopy(data, 0, dataCopy, 0, count);\n            _processQueue.add(new PipeEvent(dataCopy, isEncrypted));\n        }\n        else {\n            _processQueue.add(new PipeEvent());\n        }\n    }\n\n    @Override\n    public void run() {\n        PipeEvent event;\n        ISocketHandler socketHandler;\n        SocketChannel channel;\n        List<byte[]> sendData = null;\n\n        while(true) {\n            // make sure all the requests in the queue are processed\n            if (_processQueue.isEmpty() && requestedClose) {\n                logger.fine(\"PipeWorker closed (\"+  _processQueue.size() + \"): \" + this.socketInfo);\n                if (_localChannel.isOpen()) {\n                    _localSocketHandler.send(new ChangeRequest(_localChannel, ChangeRequest.CLOSE_CHANNEL));\n                }\n                if (_remoteChannel.isOpen()) {\n                    _remoteSocketHandler.send(new ChangeRequest(_remoteChannel, ChangeRequest.CLOSE_CHANNEL));\n                }\n                break;\n            }\n\n            try {\n                event = (PipeEvent)_processQueue.take();\n\n                // if event data is null, it means this is a wake-up call\n                // to check if any other thread is requested to close sockets\n                if (event.data == null) {\n                    continue;\n                }\n\n                // process proxy packet if needed\n                if (!_proxy.isReady()) {\n                    // packet for local socket\n                    byte[] temp = _proxy.getResponse(event.data);\n                    if (temp != null) {\n                        _localSocketHandler.send(new ChangeRequest(_localChannel, ChangeRequest.CHANGE_SOCKET_OP,\n                                SelectionKey.OP_WRITE), temp);\n                    }\n                    // packet for remote socket (ss payload + request)\n                    sendData = _proxy.getRemoteResponse(event.data);\n                    if (sendData == null) {\n                        continue;\n                    }\n                    // index 0 is always ss payload\n                    logger.info(\"Connected to: \" + Util.getRequestedHostInfo(sendData.get(0)));\n                    //logger.info(\"Test: \" + Util.bytesToString(temp, 0, temp.length));\n                }\n                else {\n                    sendData.clear();\n                    sendData.add(event.data);\n                }\n\n                for (byte[] bytes : sendData) {\n                    // empty stream for new data\n                    _outStream.reset();\n\n                    if (event.isEncrypted) {\n                        _crypt.encrypt(bytes, _outStream);\n                        channel = _remoteChannel;\n                        socketHandler = _remoteSocketHandler;\n                    } else {\n                        _crypt.decrypt(bytes, _outStream);\n                        channel = _localChannel;\n                        socketHandler = _localSocketHandler;\n                    }\n\n                    // data is ready to send to socket\n                    ChangeRequest request = new ChangeRequest(channel, ChangeRequest.CHANGE_SOCKET_OP, SelectionKey.OP_WRITE);\n                    socketHandler.send(request, _outStream.toByteArray());\n                }\n            } catch (InterruptedException e) {\n                logger.fine(Util.getErrorMessage(e));\n                break;\n            }\n        }\n    }\n}",
                                          "definition": "public class PipeWorker implements Runnable",
                                          "byte_span": [
                                            2066,
                                            7466
                                          ],
                                          "start_point": [
                                            51,
                                            0
                                          ],
                                          "end_point": [
                                            187,
                                            1
                                          ],
                                          "class_docstring": "",
                                          "name": "PipeWorker",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "fields": [
                                              {
                                                "attribute_expression": "    private Logger logger = Logger.getLogger(PipeWorker.class.getName());",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Logger",
                                                "name": "logger = Logger.getLogger(PipeWorker.class.getName())",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private SocketChannel _localChannel;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "SocketChannel",
                                                "name": "_localChannel",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private SocketChannel _remoteChannel;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "SocketChannel",
                                                "name": "_remoteChannel",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private ISocketHandler _localSocketHandler;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "ISocketHandler",
                                                "name": "_localSocketHandler",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private ISocketHandler _remoteSocketHandler;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "ISocketHandler",
                                                "name": "_remoteSocketHandler",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private IProxy _proxy;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "IProxy",
                                                "name": "_proxy",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private ICrypt _crypt;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "ICrypt",
                                                "name": "_crypt",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    public String socketInfo;",
                                                "docstring": "",
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "type": "String",
                                                "name": "socketInfo",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private ByteArrayOutputStream _outStream;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "ByteArrayOutputStream",
                                                "name": "_outStream",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private BlockingQueue _processQueue;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "BlockingQueue",
                                                "name": "_processQueue",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private volatile boolean requestedClose;",
                                                "docstring": "",
                                                "modifiers": "private volatile",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private",
                                                  "volatile"
                                                ],
                                                "comments": [],
                                                "type": "boolean",
                                                "name": "requestedClose",
                                                "syntax_pass": true
                                              }
                                            ],
                                            "classes": []
                                          },
                                          "syntax_pass": true,
                                          "methods": [
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2587,
                                                3289
                                              ],
                                              "original_string": "    public PipeWorker(ISocketHandler localHandler, SocketChannel localChannel, ISocketHandler remoteHandler, SocketChannel remoteChannel, Config config) {\n        _localChannel = localChannel;\n        _remoteChannel = remoteChannel;\n        _localSocketHandler = localHandler;\n        _remoteSocketHandler = remoteHandler;\n        _crypt = CryptFactory.get(config.getMethod(), config.getPassword());\n        _proxy = ProxyFactory.get(config.getProxyType());\n        _outStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n        _processQueue = new LinkedBlockingQueue();\n        requestedClose = false;\n        socketInfo = String.format(\"Local: %s, Remote: %s\", localChannel, remoteChannel);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "",
                                                "classes": []
                                              },
                                              "name": "PipeWorker",
                                              "body": "                                                                                                                                                         {\n        _localChannel = localChannel;\n        _remoteChannel = remoteChannel;\n        _localSocketHandler = localHandler;\n        _remoteSocketHandler = remoteHandler;\n        _crypt = CryptFactory.get(config.getMethod(), config.getPassword());\n        _proxy = ProxyFactory.get(config.getProxyType());\n        _outStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n        _processQueue = new LinkedBlockingQueue();\n        requestedClose = false;\n        socketInfo = String.format(\"Local: %s, Remote: %s\", localChannel, remoteChannel);\n    }",
                                              "identifiers": "_localChannel localChannel _remoteChannel remoteChannel _localSocketHandler localHandler _remoteSocketHandler remoteHandler _crypt CryptFactory get config getMethod config getPassword _proxy ProxyFactory get config getProxyType _outStream Constant BUFFER_SIZE _processQueue requestedClose socketInfo String format localChannel remoteChannel",
                                              "signature": "    public PipeWorker(ISocketHandler localHandler, SocketChannel localChannel, ISocketHandler remoteHandler, SocketChannel remoteChannel, Config config)",
                                              "signature_woname": "    public (ISocketHandler localHandler, SocketChannel localChannel, ISocketHandler remoteHandler, SocketChannel remoteChannel, Config config)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                3295,
                                                3390
                                              ],
                                              "original_string": "    public void close() {\n        requestedClose = true;\n        processData(null, 0, false);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "close",
                                              "body": "                        {\n        requestedClose = true;\n        processData(null, 0, false);\n    }",
                                              "identifiers": "requestedClose processData",
                                              "signature": "    public void close()",
                                              "signature_woname": "    public void ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                3396,
                                                3898
                                              ],
                                              "original_string": "    public void forceClose() {\n        logger.fine(\"PipeWorker::forceClose \" + socketInfo);\n\n        // close socket now!\n        try {\n            if (_localChannel.isOpen()) {\n                _localChannel.close();\n            }\n            if (_remoteChannel.isOpen()) {\n                _remoteChannel.close();\n            }\n        } catch (IOException e) {\n            logger.fine(\"PipeWorker::forceClose> \" + e.toString());\n        }\n\n        // follow the standard close steps\n        close();\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "forceClose",
                                              "body": "                             {\n        logger.fine(\"PipeWorker::forceClose \" + socketInfo);\n\n        // close socket now!\n        try {\n            if (_localChannel.isOpen()) {\n                _localChannel.close();\n            }\n            if (_remoteChannel.isOpen()) {\n                _remoteChannel.close();\n            }\n        } catch (IOException e) {\n            logger.fine(\"PipeWorker::forceClose> \" + e.toString());\n        }\n\n        // follow the standard close steps\n        close();\n    }",
                                              "identifiers": "logger fine socketInfo _localChannel isOpen _localChannel close _remoteChannel isOpen _remoteChannel close e logger fine e toString close",
                                              "signature": "    public void forceClose()",
                                              "signature_woname": "    public void ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                3904,
                                                4266
                                              ],
                                              "original_string": "    public void processData(byte[] data, int count, boolean isEncrypted) {\n        if (data != null) {\n            byte[] dataCopy = new byte[count];\n            System.arraycopy(data, 0, dataCopy, 0, count);\n            _processQueue.add(new PipeEvent(dataCopy, isEncrypted));\n        }\n        else {\n            _processQueue.add(new PipeEvent());\n        }\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "processData",
                                              "body": "                                                                         {\n        if (data != null) {\n            byte[] dataCopy = new byte[count];\n            System.arraycopy(data, 0, dataCopy, 0, count);\n            _processQueue.add(new PipeEvent(dataCopy, isEncrypted));\n        }\n        else {\n            _processQueue.add(new PipeEvent());\n        }\n    }",
                                              "identifiers": "data dataCopy count System arraycopy data dataCopy count _processQueue add dataCopy isEncrypted _processQueue add",
                                              "signature": "    public void processData(byte[] data, int count, boolean isEncrypted)",
                                              "signature_woname": "    public void (byte[] data, int count, boolean isEncrypted)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                4272,
                                                7464
                                              ],
                                              "original_string": "    @Override\n    public void run() {\n        PipeEvent event;\n        ISocketHandler socketHandler;\n        SocketChannel channel;\n        List<byte[]> sendData = null;\n\n        while(true) {\n            // make sure all the requests in the queue are processed\n            if (_processQueue.isEmpty() && requestedClose) {\n                logger.fine(\"PipeWorker closed (\"+  _processQueue.size() + \"): \" + this.socketInfo);\n                if (_localChannel.isOpen()) {\n                    _localSocketHandler.send(new ChangeRequest(_localChannel, ChangeRequest.CLOSE_CHANNEL));\n                }\n                if (_remoteChannel.isOpen()) {\n                    _remoteSocketHandler.send(new ChangeRequest(_remoteChannel, ChangeRequest.CLOSE_CHANNEL));\n                }\n                break;\n            }\n\n            try {\n                event = (PipeEvent)_processQueue.take();\n\n                // if event data is null, it means this is a wake-up call\n                // to check if any other thread is requested to close sockets\n                if (event.data == null) {\n                    continue;\n                }\n\n                // process proxy packet if needed\n                if (!_proxy.isReady()) {\n                    // packet for local socket\n                    byte[] temp = _proxy.getResponse(event.data);\n                    if (temp != null) {\n                        _localSocketHandler.send(new ChangeRequest(_localChannel, ChangeRequest.CHANGE_SOCKET_OP,\n                                SelectionKey.OP_WRITE), temp);\n                    }\n                    // packet for remote socket (ss payload + request)\n                    sendData = _proxy.getRemoteResponse(event.data);\n                    if (sendData == null) {\n                        continue;\n                    }\n                    // index 0 is always ss payload\n                    logger.info(\"Connected to: \" + Util.getRequestedHostInfo(sendData.get(0)));\n                    //logger.info(\"Test: \" + Util.bytesToString(temp, 0, temp.length));\n                }\n                else {\n                    sendData.clear();\n                    sendData.add(event.data);\n                }\n\n                for (byte[] bytes : sendData) {\n                    // empty stream for new data\n                    _outStream.reset();\n\n                    if (event.isEncrypted) {\n                        _crypt.encrypt(bytes, _outStream);\n                        channel = _remoteChannel;\n                        socketHandler = _remoteSocketHandler;\n                    } else {\n                        _crypt.decrypt(bytes, _outStream);\n                        channel = _localChannel;\n                        socketHandler = _localSocketHandler;\n                    }\n\n                    // data is ready to send to socket\n                    ChangeRequest request = new ChangeRequest(channel, ChangeRequest.CHANGE_SOCKET_OP, SelectionKey.OP_WRITE);\n                    socketHandler.send(request, _outStream.toByteArray());\n                }\n            } catch (InterruptedException e) {\n                logger.fine(Util.getErrorMessage(e));\n                break;\n            }\n        }\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "run",
                                              "body": "                      {\n        PipeEvent event;\n        ISocketHandler socketHandler;\n        SocketChannel channel;\n        List<byte[]> sendData = null;\n\n        while(true) {\n            // make sure all the requests in the queue are processed\n            if (_processQueue.isEmpty() && requestedClose) {\n                logger.fine(\"PipeWorker closed (\"+  _processQueue.size() + \"): \" + this.socketInfo);\n                if (_localChannel.isOpen()) {\n                    _localSocketHandler.send(new ChangeRequest(_localChannel, ChangeRequest.CLOSE_CHANNEL));\n                }\n                if (_remoteChannel.isOpen()) {\n                    _remoteSocketHandler.send(new ChangeRequest(_remoteChannel, ChangeRequest.CLOSE_CHANNEL));\n                }\n                break;\n            }\n\n            try {\n                event = (PipeEvent)_processQueue.take();\n\n                // if event data is null, it means this is a wake-up call\n                // to check if any other thread is requested to close sockets\n                if (event.data == null) {\n                    continue;\n                }\n\n                // process proxy packet if needed\n                if (!_proxy.isReady()) {\n                    // packet for local socket\n                    byte[] temp = _proxy.getResponse(event.data);\n                    if (temp != null) {\n                        _localSocketHandler.send(new ChangeRequest(_localChannel, ChangeRequest.CHANGE_SOCKET_OP,\n                                SelectionKey.OP_WRITE), temp);\n                    }\n                    // packet for remote socket (ss payload + request)\n                    sendData = _proxy.getRemoteResponse(event.data);\n                    if (sendData == null) {\n                        continue;\n                    }\n                    // index 0 is always ss payload\n                    logger.info(\"Connected to: \" + Util.getRequestedHostInfo(sendData.get(0)));\n                    //logger.info(\"Test: \" + Util.bytesToString(temp, 0, temp.length));\n                }\n                else {\n                    sendData.clear();\n                    sendData.add(event.data);\n                }\n\n                for (byte[] bytes : sendData) {\n                    // empty stream for new data\n                    _outStream.reset();\n\n                    if (event.isEncrypted) {\n                        _crypt.encrypt(bytes, _outStream);\n                        channel = _remoteChannel;\n                        socketHandler = _remoteSocketHandler;\n                    } else {\n                        _crypt.decrypt(bytes, _outStream);\n                        channel = _localChannel;\n                        socketHandler = _localSocketHandler;\n                    }\n\n                    // data is ready to send to socket\n                    ChangeRequest request = new ChangeRequest(channel, ChangeRequest.CHANGE_SOCKET_OP, SelectionKey.OP_WRITE);\n                    socketHandler.send(request, _outStream.toByteArray());\n                }\n            } catch (InterruptedException e) {\n                logger.fine(Util.getErrorMessage(e));\n                break;\n            }\n        }\n    }",
                                              "identifiers": "event socketHandler channel sendData _processQueue isEmpty requestedClose logger fine _processQueue size socketInfo _localChannel isOpen _localSocketHandler send _localChannel ChangeRequest CLOSE_CHANNEL _remoteChannel isOpen _remoteSocketHandler send _remoteChannel ChangeRequest CLOSE_CHANNEL event _processQueue take event data _proxy isReady temp _proxy getResponse event data temp _localSocketHandler send _localChannel ChangeRequest CHANGE_SOCKET_OP SelectionKey OP_WRITE temp sendData _proxy getRemoteResponse event data sendData logger info Util getRequestedHostInfo sendData get sendData clear sendData add event data bytes sendData _outStream reset event isEncrypted _crypt encrypt bytes _outStream channel _remoteChannel socketHandler _remoteSocketHandler _crypt decrypt bytes _outStream channel _localChannel socketHandler _localSocketHandler request channel ChangeRequest CHANGE_SOCKET_OP SelectionKey OP_WRITE socketHandler send request _outStream toByteArray e logger fine Util getErrorMessage e",
                                              "signature": "    @Override\n    public void run()",
                                              "signature_woname": "    @Override\n    public void ()"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "imports": [
                                      {
                                        "original_string": "public class Config {\n    private String _ipAddr;\n    private int _port;\n    private String _localIpAddr;\n    private int _localPort;\n    private String _method;\n    private String _password;\n    private String _logLevel;\n    private IProxy.TYPE _proxyType;\n\n    public Config() {\n        loadFromJson(\"\");\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }\n\n    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }\n\n    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }\n\n    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }\n\n    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }\n\n    public void setRemotePort(int value) {\n        _port = value;\n    }\n\n    public int getRemotePort() {\n        return _port;\n    }\n\n    public void setLocalPort(int value) {\n        _localPort = value;\n    }\n\n    public int getLocalPort() {\n        return _localPort;\n    }\n\n    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }\n\n    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }\n    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }\n\n    public void setMethod(String value) {\n        _method = value;\n    }\n\n    public String getMethod() {\n        return _method;\n    }\n\n    public void setPassword(String value) {\n        _password = value;\n    }\n\n    public String getPassword() {\n        return _password;\n    }\n\n    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }\n\n    public String getLogLevel() {\n        return _logLevel;\n    }\n\n    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }\n\n    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }\n}",
                                        "definition": "public class Config",
                                        "byte_span": [
                                          1735,
                                          5565
                                        ],
                                        "start_point": [
                                          41,
                                          0
                                        ],
                                        "end_point": [
                                          175,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Config",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    private String _ipAddr;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_ipAddr",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private int _port;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "_port",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _localIpAddr;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_localIpAddr",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private int _localPort;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "_localPort",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _method;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_method",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _password;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_password",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _logLevel;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_logLevel",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private IProxy.TYPE _proxyType;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "IProxy.TYPE",
                                              "name": "_proxyType",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              1998,
                                              2047
                                            ],
                                            "original_string": "    public Config() {\n        loadFromJson(\"\");\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                    {\n        loadFromJson(\"\");\n    }",
                                            "identifiers": "loadFromJson",
                                            "signature": "    public Config()",
                                            "signature_woname": "    public ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2053,
                                              2393
                                            ],
                                            "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                                                                                                              {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                            "identifiers": "_ipAddr ipAddr _port port _localIpAddr localIpAddr _localPort localPort _method method _password password _proxyType IProxy TYPE AUTO",
                                            "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password)",
                                            "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2399,
                                              2627
                                            ],
                                            "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                                                                                                                                {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                            "identifiers": "ipAddr port localIpAddr localPort method password _proxyType type",
                                            "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)",
                                            "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2633,
                                              2710
                                            ],
                                            "original_string": "    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setRemoteIpAddress",
                                            "body": "                                                 {\n        _ipAddr = value;\n    }",
                                            "identifiers": "_ipAddr value",
                                            "signature": "    public void setRemoteIpAddress(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2716,
                                              2782
                                            ],
                                            "original_string": "    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getRemoteIpAddress",
                                            "body": "                                       {\n        return _ipAddr;\n    }",
                                            "identifiers": "_ipAddr",
                                            "signature": "    public String getRemoteIpAddress()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2788,
                                              2869
                                            ],
                                            "original_string": "    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLocalIpAddress",
                                            "body": "                                                {\n        _localIpAddr = value;\n    }",
                                            "identifiers": "_localIpAddr value",
                                            "signature": "    public void setLocalIpAddress(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2875,
                                              2945
                                            ],
                                            "original_string": "    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getLocalIpAddress",
                                            "body": "                                      {\n        return _localIpAddr;\n    }",
                                            "identifiers": "_localIpAddr",
                                            "signature": "    public String getLocalIpAddress()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2951,
                                              3018
                                            ],
                                            "original_string": "    public void setRemotePort(int value) {\n        _port = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setRemotePort",
                                            "body": "                                         {\n        _port = value;\n    }",
                                            "identifiers": "_port value",
                                            "signature": "    public void setRemotePort(int value)",
                                            "signature_woname": "    public void (int value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3024,
                                              3080
                                            ],
                                            "original_string": "    public int getRemotePort() {\n        return _port;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getRemotePort",
                                            "body": "                               {\n        return _port;\n    }",
                                            "identifiers": "_port",
                                            "signature": "    public int getRemotePort()",
                                            "signature_woname": "    public int ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3086,
                                              3157
                                            ],
                                            "original_string": "    public void setLocalPort(int value) {\n        _localPort = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLocalPort",
                                            "body": "                                        {\n        _localPort = value;\n    }",
                                            "identifiers": "_localPort value",
                                            "signature": "    public void setLocalPort(int value)",
                                            "signature_woname": "    public void (int value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3163,
                                              3223
                                            ],
                                            "original_string": "    public int getLocalPort() {\n        return _localPort;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getLocalPort",
                                            "body": "                              {\n        return _localPort;\n    }",
                                            "identifiers": "_localPort",
                                            "signature": "    public int getLocalPort()",
                                            "signature_woname": "    public int ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3229,
                                              3599
                                            ],
                                            "original_string": "    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setProxyType",
                                            "body": "                                           {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                            "identifiers": "_proxyType IProxy TYPE AUTO value toLowerCase equals IProxy TYPE HTTP toString toLowerCase _proxyType IProxy TYPE HTTP value toLowerCase equals IProxy TYPE SOCKS5 toString toLowerCase _proxyType IProxy TYPE SOCKS5",
                                            "signature": "    public void setProxyType(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3605,
                                              3684
                                            ],
                                            "original_string": "    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setProxyType",
                                            "body": "                                                {\n        _proxyType = value;\n    }",
                                            "identifiers": "_proxyType value",
                                            "signature": "    public void setProxyType(IProxy.TYPE value)",
                                            "signature_woname": "    public void (IProxy.TYPE value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3689,
                                              3757
                                            ],
                                            "original_string": "    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "IProxy.TYPE",
                                              "classes": []
                                            },
                                            "name": "getProxyType",
                                            "body": "                                      {\n        return _proxyType;\n    }",
                                            "identifiers": "_proxyType",
                                            "signature": "    public IProxy.TYPE getProxyType()",
                                            "signature_woname": "    public IProxy.TYPE ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3763,
                                              3831
                                            ],
                                            "original_string": "    public void setMethod(String value) {\n        _method = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setMethod",
                                            "body": "                                        {\n        _method = value;\n    }",
                                            "identifiers": "_method value",
                                            "signature": "    public void setMethod(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3837,
                                              3894
                                            ],
                                            "original_string": "    public String getMethod() {\n        return _method;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getMethod",
                                            "body": "                              {\n        return _method;\n    }",
                                            "identifiers": "_method",
                                            "signature": "    public String getMethod()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3900,
                                              3972
                                            ],
                                            "original_string": "    public void setPassword(String value) {\n        _password = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setPassword",
                                            "body": "                                          {\n        _password = value;\n    }",
                                            "identifiers": "_password value",
                                            "signature": "    public void setPassword(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3978,
                                              4039
                                            ],
                                            "original_string": "    public String getPassword() {\n        return _password;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getPassword",
                                            "body": "                                {\n        return _password;\n    }",
                                            "identifiers": "_password",
                                            "signature": "    public String getPassword()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4045,
                                              4150
                                            ],
                                            "original_string": "    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLogLevel",
                                            "body": "                                          {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                            "identifiers": "_logLevel value Log init getLogLevel",
                                            "signature": "    public void setLogLevel(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4156,
                                              4217
                                            ],
                                            "original_string": "    public String getLogLevel() {\n        return _logLevel;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getLogLevel",
                                            "body": "                                {\n        return _logLevel;\n    }",
                                            "identifiers": "_logLevel",
                                            "signature": "    public String getLogLevel()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4223,
                                              5070
                                            ],
                                            "original_string": "    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "loadFromJson",
                                            "body": "                                             {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                            "identifiers": "jsonStr length jsonStr jObj JSONValue parse jsonStr _ipAddr jObj getOrDefault _port jObj getOrDefault intValue _localIpAddr jObj getOrDefault _localPort jObj getOrDefault intValue _method jObj getOrDefault AesCrypt CIPHER_AES_256_CFB _password jObj getOrDefault _logLevel jObj getOrDefault setProxyType jObj getOrDefault IProxy TYPE SOCKS5 toString toLowerCase setLogLevel _logLevel",
                                            "signature": "    public void loadFromJson(String jsonStr)",
                                            "signature_woname": "    public void (String jsonStr)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              5076,
                                              5563
                                            ],
                                            "original_string": "    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "saveToJson",
                                            "body": "                               {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                            "identifiers": "jObj jObj put _ipAddr jObj put _port jObj put _localIpAddr jObj put _localPort jObj put _method jObj put _password jObj put _proxyType toString toLowerCase jObj put _logLevel Util prettyPrintJson jObj",
                                            "signature": "    public String saveToJson()",
                                            "signature_woname": "    public String ()"
                                          }
                                        ]
                                      },
                                      {
                                        "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                        "definition": "public class Util",
                                        "byte_span": [
                                          1779,
                                          7484
                                        ],
                                        "start_point": [
                                          45,
                                          0
                                        ],
                                        "end_point": [
                                          219,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Util",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              1803,
                                              2018
                                            ],
                                            "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "dumpBytes",
                                            "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                            "identifiers": "sb a length b a sb append String format b sb toString",
                                            "signature": "    public static String dumpBytes(byte[] a)",
                                            "signature_woname": "    public static String (byte[] a)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2024,
                                              2180
                                            ],
                                            "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "byte[]",
                                              "classes": []
                                            },
                                            "name": "randomBytes",
                                            "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                            "identifiers": "bytes size nextBytes bytes bytes",
                                            "signature": "    public static byte[] randomBytes(int size)",
                                            "signature_woname": "    public static byte[] (int size)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2186,
                                              2412
                                            ],
                                            "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getErrorMessage",
                                            "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                            "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                            "signature": "    public static String getErrorMessage(Throwable e)",
                                            "signature_woname": "    public static String (Throwable e)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2418,
                                              4165
                                            ],
                                            "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "prettyPrintJson",
                                            "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                            "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                            "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                            "signature_woname": "    public static String (JSONObject jObj)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4171,
                                              5829
                                            ],
                                            "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getRequestedHostInfo",
                                            "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                            "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                            "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                            "signature_woname": "    public static String (byte[] data)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              5835,
                                              6128
                                            ],
                                            "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "bytesToString",
                                            "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                            "identifiers": "str str data start length e e printStackTrace str",
                                            "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                            "signature_woname": "    public static String (byte[] data, int start, int length)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6134,
                                              6648
                                            ],
                                            "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "byte[]",
                                              "classes": []
                                            },
                                            "name": "composeSSHeader",
                                            "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                            "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                            "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                            "signature_woname": "    public static byte[] (String host, int port)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6654,
                                              6969
                                            ],
                                            "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "boolean",
                                              "classes": []
                                            },
                                            "name": "saveFile",
                                            "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                            "identifiers": "writer writer fn writer println content writer close e",
                                            "signature": "    public static boolean saveFile(String fn, String content)",
                                            "signature_woname": "    public static boolean (String fn, String content)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6975,
                                              7262
                                            ],
                                            "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getFileContent",
                                            "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                            "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                            "signature": "    public static String getFileContent(String fn)",
                                            "signature_woname": "    public static String (String fn)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              7268,
                                              7357
                                            ],
                                            "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "short",
                                              "classes": []
                                            },
                                            "name": "byteToUnsignedByte",
                                            "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                            "identifiers": "b",
                                            "signature": "    private static short byteToUnsignedByte(byte b)",
                                            "signature_woname": "    private static short (byte b)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              7363,
                                              7482
                                            ],
                                            "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getPort",
                                            "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                            "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                            "signature": "    private static int getPort(byte b, byte b1)",
                                            "signature_woname": "    private static int (byte b, byte b1)"
                                          }
                                        ]
                                      },
                                      {
                                        "original_string": "public class Constant {\n    public static final String PROG_NAME = \"shadowsocks-java\";\n    public static final String VERSION = \"0.2\";\n    public static final int BUFFER_SIZE = 16384;\n    public static final String CONF_FILE = \"config.json\";\n    public static final Locale LOCALE = Locale.getDefault();\n}",
                                        "definition": "public class Constant",
                                        "byte_span": [
                                          45,
                                          349
                                        ],
                                        "start_point": [
                                          4,
                                          0
                                        ],
                                        "end_point": [
                                          10,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Constant",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    public static final String PROG_NAME = \"shadowsocks-java\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "PROG_NAME = \"shadowsocks-java\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final String VERSION = \"0.2\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "VERSION = \"0.2\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final int BUFFER_SIZE = 16384;",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "BUFFER_SIZE = 16384",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final String CONF_FILE = \"config.json\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "CONF_FILE = \"config.json\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final Locale LOCALE = Locale.getDefault();",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "Locale",
                                              "name": "LOCALE = Locale.getDefault()",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": []
                                      },
                                      {
                                        "original_string": "public class ProxyFactory {\n    public static final Map<IProxy.TYPE, String> proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }};\n    private static Logger logger = Logger.getLogger(ProxyFactory.class.getName());\n\n    public static boolean isProxyTypeExisted(String name) {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }\n\n    public static IProxy get(IProxy.TYPE type) {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<IProxy.TYPE> getSupportedProxyTypes() {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                        "definition": "public class ProxyFactory",
                                        "byte_span": [
                                          1660,
                                          2707
                                        ],
                                        "start_point": [
                                          40,
                                          0
                                        ],
                                        "end_point": [
                                          70,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "ProxyFactory",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    public static final Map<IProxy.TYPE, String> proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }};",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "Map<IProxy.TYPE, String>",
                                              "name": "proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }}",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private static Logger logger = Logger.getLogger(ProxyFactory.class.getName());",
                                              "docstring": "",
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "type": "Logger",
                                              "name": "logger = Logger.getLogger(ProxyFactory.class.getName())",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2059,
                                              2218
                                            ],
                                            "original_string": "    public static boolean isProxyTypeExisted(String name) {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "boolean",
                                              "classes": []
                                            },
                                            "name": "isProxyTypeExisted",
                                            "body": "                                                          {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }",
                                            "identifiers": "type IProxy TYPE valueOf name proxies get type",
                                            "signature": "    public static boolean isProxyTypeExisted(String name)",
                                            "signature_woname": "    public static boolean (String name)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2224,
                                              2509
                                            ],
                                            "original_string": "    public static IProxy get(IProxy.TYPE type) {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "IProxy",
                                              "classes": []
                                            },
                                            "name": "get",
                                            "body": "                                               {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                            "identifiers": "obj Reflection get proxies get type obj e logger info com stfl misc Util getErrorMessage e",
                                            "signature": "    public static IProxy get(IProxy.TYPE type)",
                                            "signature_woname": "    public static IProxy (IProxy.TYPE type)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2515,
                                              2705
                                            ],
                                            "original_string": "    public static List<IProxy.TYPE> getSupportedProxyTypes() {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "List<IProxy.TYPE>",
                                              "classes": []
                                            },
                                            "name": "getSupportedProxyTypes",
                                            "body": "                                                             {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                            "identifiers": "sortedKeys proxies keySet Collections sort sortedKeys sortedKeys",
                                            "signature": "    public static List<IProxy.TYPE> getSupportedProxyTypes()",
                                            "signature_woname": "    public static List<IProxy.TYPE> ()"
                                          }
                                        ]
                                      },
                                      {
                                        "original_string": "public class CryptFactory {\n    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};\n    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());\n\n    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }\n\n    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                        "definition": "public class CryptFactory",
                                        "byte_span": [
                                          1649,
                                          2693
                                        ],
                                        "start_point": [
                                          40,
                                          0
                                        ],
                                        "end_point": [
                                          71,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "CryptFactory",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};",
                                              "docstring": "",
                                              "modifiers": "private static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "Map<String, String>",
                                              "name": "crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }}",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());",
                                              "docstring": "",
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "type": "Logger",
                                              "name": "logger = Logger.getLogger(CryptFactory.class.getName())",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2057,
                                              2158
                                            ],
                                            "original_string": "    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "boolean",
                                              "classes": []
                                            },
                                            "name": "isCipherExisted",
                                            "body": "                                                       {\n        return (crypts.get(name) != null);\n    }",
                                            "identifiers": "crypts get name",
                                            "signature": "    public static boolean isCipherExisted(String name)",
                                            "signature_woname": "    public static boolean (String name)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2164,
                                              2504
                                            ],
                                            "original_string": "    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "ICrypt",
                                              "classes": []
                                            },
                                            "name": "get",
                                            "body": "                                                           {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                            "identifiers": "obj Reflection get crypts get name name password obj e logger info com stfl misc Util getErrorMessage e",
                                            "signature": "    public static ICrypt get(String name, String password)",
                                            "signature_woname": "    public static ICrypt (String name, String password)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2510,
                                              2691
                                            ],
                                            "original_string": "    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "List<String>",
                                              "classes": []
                                            },
                                            "name": "getSupportedCiphers",
                                            "body": "                                                     {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                            "identifiers": "sortedKeys crypts keySet Collections sort sortedKeys sortedKeys",
                                            "signature": "    public static List<String> getSupportedCiphers()",
                                            "signature_woname": "    public static List<String> ()"
                                          }
                                        ]
                                      }
                                    ]
                                  },
                                  {
                                    "name": "ISocketHandler.java",
                                    "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network.nio;\n\n/**\n * Interface of socket handler\n */\npublic interface ISocketHandler {\n    void send(ChangeRequest request, byte[] data);\n    void send(ChangeRequest request);\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.nio;"
                                      ],
                                      "methods": [],
                                      "classes": []
                                    },
                                    "imports": []
                                  },
                                  {
                                    "name": "RemoteSocketHandler.java",
                                    "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network.nio;\n\nimport com.stfl.misc.Config;\nimport com.stfl.misc.Util;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.util.List;\nimport java.util.logging.Logger;\n\n/**\n * Handler for processing all IO event for remote sockets\n */\npublic class RemoteSocketHandler extends SocketHandlerBase {\n    private Logger logger = Logger.getLogger(RemoteSocketHandler.class.getName());\n\n    public RemoteSocketHandler(Config config) throws IOException, InvalidAlgorithmParameterException {\n        super(config);\n    }\n\n    @Override\n    protected Selector initSelector() throws IOException {\n        return SelectorProvider.provider().openSelector();\n    }\n\n    @Override\n    protected boolean processPendingRequest(ChangeRequest request) {\n        if ((request.type != ChangeRequest.REGISTER_CHANNEL) && request.socket.isConnectionPending()) {\n            return false;\n        }\n\n        SelectionKey key;\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"RemoteSocketHandler::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.REGISTER_CHANNEL:\n                try {\n                    request.socket.register(_selector, request.op);\n                } catch (ClosedChannelException e) {\n                    // socket get closed by remote\n                    logger.warning(e.toString());\n                    cleanUp(request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n\n        return true;\n    }\n\n    @Override\n    protected void processSelect(SelectionKey key) {\n        try {\n            if (key.isConnectable()) {\n                finishConnection(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        } catch (IOException e) {\n            cleanUp((SocketChannel) key.channel());\n        }\n    }\n\n    public PipeWorker createPipe(ISocketHandler localHandler, SocketChannel localChannel, String ipAddress, int port) throws IOException {\n        // prepare remote socket\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(new InetSocketAddress(ipAddress, port));\n\n        // create write buffer for specified socket\n        createWriteBuffer(socketChannel);\n\n        // create pipe worker for handling encrypt and decrypt\n        PipeWorker pipe = new PipeWorker(localHandler, localChannel, this, socketChannel, _config);\n\n        // setup pipe info\n        //pipe.setRemoteChannel(socketChannel);\n        _pipes.put(socketChannel, pipe);\n\n        synchronized(_pendingRequest) {\n            _pendingRequest.add(new ChangeRequest(socketChannel, ChangeRequest.REGISTER_CHANNEL, SelectionKey.OP_CONNECT));\n        }\n\n        return pipe;\n    }\n\n    private void read(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        // clear read buffer for new data\n        _readBuffer.clear();\n\n        // read data\n        int readCount;\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            // remote socket closed\n            cleanUp(socketChannel);\n\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        // Handle the response\n        pipe.processData(_readBuffer.array(), readCount, false);\n    }\n\n    private void write(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // write data to socket\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"RemoteSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }\n\n    private void finishConnection(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        try {\n            socketChannel.finishConnect();\n        } catch (IOException e) {\n            logger.warning(\"RemoteSocketHandler::finishConnection I/O exception: \" + e.toString());\n            cleanUp(socketChannel);\n            return;\n        }\n\n        key.interestOps(SelectionKey.OP_WRITE);\n    }\n\n    @Override\n    protected void cleanUp(SocketChannel socketChannel) {\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"RemoteSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"RemoteSocket closed (NULL): \" + socketChannel);\n        }\n    }\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.nio;",
                                        "import com.stfl.misc.Config;",
                                        "import com.stfl.misc.Util;",
                                        "import java.io.IOException;",
                                        "import java.net.InetSocketAddress;",
                                        "import java.nio.ByteBuffer;",
                                        "import java.nio.channels.ClosedChannelException;",
                                        "import java.nio.channels.SelectionKey;",
                                        "import java.nio.channels.Selector;",
                                        "import java.nio.channels.SocketChannel;",
                                        "import java.nio.channels.spi.SelectorProvider;",
                                        "import java.security.InvalidAlgorithmParameterException;",
                                        "import java.util.List;",
                                        "import java.util.logging.Logger;"
                                      ],
                                      "methods": [],
                                      "classes": [
                                        {
                                          "original_string": "public class RemoteSocketHandler extends SocketHandlerBase {\n    private Logger logger = Logger.getLogger(RemoteSocketHandler.class.getName());\n\n    public RemoteSocketHandler(Config config) throws IOException, InvalidAlgorithmParameterException {\n        super(config);\n    }\n\n    @Override\n    protected Selector initSelector() throws IOException {\n        return SelectorProvider.provider().openSelector();\n    }\n\n    @Override\n    protected boolean processPendingRequest(ChangeRequest request) {\n        if ((request.type != ChangeRequest.REGISTER_CHANNEL) && request.socket.isConnectionPending()) {\n            return false;\n        }\n\n        SelectionKey key;\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"RemoteSocketHandler::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.REGISTER_CHANNEL:\n                try {\n                    request.socket.register(_selector, request.op);\n                } catch (ClosedChannelException e) {\n                    // socket get closed by remote\n                    logger.warning(e.toString());\n                    cleanUp(request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n\n        return true;\n    }\n\n    @Override\n    protected void processSelect(SelectionKey key) {\n        try {\n            if (key.isConnectable()) {\n                finishConnection(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        } catch (IOException e) {\n            cleanUp((SocketChannel) key.channel());\n        }\n    }\n\n    public PipeWorker createPipe(ISocketHandler localHandler, SocketChannel localChannel, String ipAddress, int port) throws IOException {\n        // prepare remote socket\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(new InetSocketAddress(ipAddress, port));\n\n        // create write buffer for specified socket\n        createWriteBuffer(socketChannel);\n\n        // create pipe worker for handling encrypt and decrypt\n        PipeWorker pipe = new PipeWorker(localHandler, localChannel, this, socketChannel, _config);\n\n        // setup pipe info\n        //pipe.setRemoteChannel(socketChannel);\n        _pipes.put(socketChannel, pipe);\n\n        synchronized(_pendingRequest) {\n            _pendingRequest.add(new ChangeRequest(socketChannel, ChangeRequest.REGISTER_CHANNEL, SelectionKey.OP_CONNECT));\n        }\n\n        return pipe;\n    }\n\n    private void read(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        // clear read buffer for new data\n        _readBuffer.clear();\n\n        // read data\n        int readCount;\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            // remote socket closed\n            cleanUp(socketChannel);\n\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        // Handle the response\n        pipe.processData(_readBuffer.array(), readCount, false);\n    }\n\n    private void write(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // write data to socket\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"RemoteSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }\n\n    private void finishConnection(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        try {\n            socketChannel.finishConnect();\n        } catch (IOException e) {\n            logger.warning(\"RemoteSocketHandler::finishConnection I/O exception: \" + e.toString());\n            cleanUp(socketChannel);\n            return;\n        }\n\n        key.interestOps(SelectionKey.OP_WRITE);\n    }\n\n    @Override\n    protected void cleanUp(SocketChannel socketChannel) {\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"RemoteSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"RemoteSocket closed (NULL): \" + socketChannel);\n        }\n    }\n}",
                                          "definition": "public class RemoteSocketHandler extends SocketHandlerBase",
                                          "byte_span": [
                                            2084,
                                            7663
                                          ],
                                          "start_point": [
                                            51,
                                            0
                                          ],
                                          "end_point": [
                                            221,
                                            1
                                          ],
                                          "class_docstring": "",
                                          "name": "RemoteSocketHandler",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "fields": [
                                              {
                                                "attribute_expression": "    private Logger logger = Logger.getLogger(RemoteSocketHandler.class.getName());",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Logger",
                                                "name": "logger = Logger.getLogger(RemoteSocketHandler.class.getName())",
                                                "syntax_pass": true
                                              }
                                            ],
                                            "classes": []
                                          },
                                          "syntax_pass": true,
                                          "methods": [
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2233,
                                                2360
                                              ],
                                              "original_string": "    public RemoteSocketHandler(Config config) throws IOException, InvalidAlgorithmParameterException {\n        super(config);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "",
                                                "classes": []
                                              },
                                              "name": "RemoteSocketHandler",
                                              "body": "                                                                                                     {\n        super(config);\n    }",
                                              "identifiers": "config",
                                              "signature": "    public RemoteSocketHandler(Config config)",
                                              "signature_woname": "    public (Config config)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2366,
                                                2499
                                              ],
                                              "original_string": "    @Override\n    protected Selector initSelector() throws IOException {\n        return SelectorProvider.provider().openSelector();\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    protected",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "protected"
                                                ],
                                                "comments": [],
                                                "return_type": "Selector",
                                                "classes": []
                                              },
                                              "name": "initSelector",
                                              "body": "                                                         {\n        return SelectorProvider.provider().openSelector();\n    }",
                                              "identifiers": "SelectorProvider provider openSelector",
                                              "signature": "    @Override\n    protected Selector initSelector()",
                                              "signature_woname": "    @Override\n    protected Selector ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2505,
                                                3697
                                              ],
                                              "original_string": "    @Override\n    protected boolean processPendingRequest(ChangeRequest request) {\n        if ((request.type != ChangeRequest.REGISTER_CHANNEL) && request.socket.isConnectionPending()) {\n            return false;\n        }\n\n        SelectionKey key;\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"RemoteSocketHandler::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.REGISTER_CHANNEL:\n                try {\n                    request.socket.register(_selector, request.op);\n                } catch (ClosedChannelException e) {\n                    // socket get closed by remote\n                    logger.warning(e.toString());\n                    cleanUp(request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n\n        return true;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    protected",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "protected"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "processPendingRequest",
                                              "body": "                                                                   {\n        if ((request.type != ChangeRequest.REGISTER_CHANNEL) && request.socket.isConnectionPending()) {\n            return false;\n        }\n\n        SelectionKey key;\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                key = request.socket.keyFor(_selector);\n                if ((key != null) && key.isValid()) {\n                    key.interestOps(request.op);\n                } else {\n                    logger.warning(\"RemoteSocketHandler::processPendingRequest (drop): \" + key + request.socket);\n                }\n                break;\n            case ChangeRequest.REGISTER_CHANNEL:\n                try {\n                    request.socket.register(_selector, request.op);\n                } catch (ClosedChannelException e) {\n                    // socket get closed by remote\n                    logger.warning(e.toString());\n                    cleanUp(request.socket);\n                }\n                break;\n            case ChangeRequest.CLOSE_CHANNEL:\n                cleanUp(request.socket);\n                break;\n        }\n\n        return true;\n    }",
                                              "identifiers": "request type ChangeRequest REGISTER_CHANNEL request socket isConnectionPending key request type ChangeRequest CHANGE_SOCKET_OP key request socket keyFor _selector key key isValid key interestOps request op logger warning key request socket ChangeRequest REGISTER_CHANNEL request socket register _selector request op e logger warning e toString cleanUp request socket ChangeRequest CLOSE_CHANNEL cleanUp request socket",
                                              "signature": "    @Override\n    protected boolean processPendingRequest(ChangeRequest request)",
                                              "signature_woname": "    @Override\n    protected boolean (ChangeRequest request)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                3703,
                                                4114
                                              ],
                                              "original_string": "    @Override\n    protected void processSelect(SelectionKey key) {\n        try {\n            if (key.isConnectable()) {\n                finishConnection(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        } catch (IOException e) {\n            cleanUp((SocketChannel) key.channel());\n        }\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    protected",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "protected"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "processSelect",
                                              "body": "                                                   {\n        try {\n            if (key.isConnectable()) {\n                finishConnection(key);\n            } else if (key.isReadable()) {\n                read(key);\n            } else if (key.isWritable()) {\n                write(key);\n            }\n        } catch (IOException e) {\n            cleanUp((SocketChannel) key.channel());\n        }\n    }",
                                              "identifiers": "key isConnectable finishConnection key key isReadable read key key isWritable write key e cleanUp key channel",
                                              "signature": "    @Override\n    protected void processSelect(SelectionKey key)",
                                              "signature_woname": "    @Override\n    protected void (SelectionKey key)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                4120,
                                                5045
                                              ],
                                              "original_string": "    public PipeWorker createPipe(ISocketHandler localHandler, SocketChannel localChannel, String ipAddress, int port) throws IOException {\n        // prepare remote socket\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(new InetSocketAddress(ipAddress, port));\n\n        // create write buffer for specified socket\n        createWriteBuffer(socketChannel);\n\n        // create pipe worker for handling encrypt and decrypt\n        PipeWorker pipe = new PipeWorker(localHandler, localChannel, this, socketChannel, _config);\n\n        // setup pipe info\n        //pipe.setRemoteChannel(socketChannel);\n        _pipes.put(socketChannel, pipe);\n\n        synchronized(_pendingRequest) {\n            _pendingRequest.add(new ChangeRequest(socketChannel, ChangeRequest.REGISTER_CHANNEL, SelectionKey.OP_CONNECT));\n        }\n\n        return pipe;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "PipeWorker",
                                                "classes": []
                                              },
                                              "name": "createPipe",
                                              "body": "                                                                                                                                         {\n        // prepare remote socket\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(new InetSocketAddress(ipAddress, port));\n\n        // create write buffer for specified socket\n        createWriteBuffer(socketChannel);\n\n        // create pipe worker for handling encrypt and decrypt\n        PipeWorker pipe = new PipeWorker(localHandler, localChannel, this, socketChannel, _config);\n\n        // setup pipe info\n        //pipe.setRemoteChannel(socketChannel);\n        _pipes.put(socketChannel, pipe);\n\n        synchronized(_pendingRequest) {\n            _pendingRequest.add(new ChangeRequest(socketChannel, ChangeRequest.REGISTER_CHANNEL, SelectionKey.OP_CONNECT));\n        }\n\n        return pipe;\n    }",
                                              "identifiers": "socketChannel SocketChannel open socketChannel configureBlocking socketChannel connect ipAddress port createWriteBuffer socketChannel pipe localHandler localChannel socketChannel _config _pipes put socketChannel pipe _pendingRequest _pendingRequest add socketChannel ChangeRequest REGISTER_CHANNEL SelectionKey OP_CONNECT pipe",
                                              "signature": "    public PipeWorker createPipe(ISocketHandler localHandler, SocketChannel localChannel, String ipAddress, int port)",
                                              "signature_woname": "    public PipeWorker (ISocketHandler localHandler, SocketChannel localChannel, String ipAddress, int port)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                5051,
                                                5882
                                              ],
                                              "original_string": "    private void read(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        // clear read buffer for new data\n        _readBuffer.clear();\n\n        // read data\n        int readCount;\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            // remote socket closed\n            cleanUp(socketChannel);\n\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        // Handle the response\n        pipe.processData(_readBuffer.array(), readCount, false);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "read",
                                              "body": "                                                           {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe == null) {\n            // should not happen\n            cleanUp(socketChannel);\n            return;\n        }\n\n        // clear read buffer for new data\n        _readBuffer.clear();\n\n        // read data\n        int readCount;\n        try {\n            readCount = socketChannel.read(_readBuffer);\n        } catch (IOException e) {\n            // remote socket closed\n            cleanUp(socketChannel);\n\n            return;\n        }\n\n        if (readCount == -1) {\n            cleanUp(socketChannel);\n            return;\n        }\n\n        // Handle the response\n        pipe.processData(_readBuffer.array(), readCount, false);\n    }",
                                              "identifiers": "socketChannel key channel pipe _pipes get socketChannel pipe cleanUp socketChannel _readBuffer clear readCount readCount socketChannel read _readBuffer e cleanUp socketChannel readCount cleanUp socketChannel pipe processData _readBuffer array readCount",
                                              "signature": "    private void read(SelectionKey key)",
                                              "signature_woname": "    private void (SelectionKey key)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                5888,
                                                6762
                                              ],
                                              "original_string": "    private void write(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // write data to socket\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"RemoteSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "write",
                                              "body": "                                                            {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        List queue = (List) _pendingData.get(socketChannel);\n        if (queue != null) {\n            synchronized (queue) {\n                // write data to socket\n                while (!queue.isEmpty()) {\n                    ByteBuffer buf = (ByteBuffer) queue.get(0);\n                    socketChannel.write(buf);\n                    if (buf.remaining() > 0) {\n                        break;\n                    }\n                    queue.remove(0);\n                }\n\n                if (queue.isEmpty()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n        }\n        else {\n            logger.warning(\"RemoteSocket::write queue = null: \" + socketChannel);\n            return;\n        }\n    }",
                                              "identifiers": "socketChannel key channel queue _pendingData get socketChannel queue queue queue isEmpty buf queue get socketChannel write buf buf remaining queue remove queue isEmpty key interestOps SelectionKey OP_READ logger warning socketChannel",
                                              "signature": "    private void write(SelectionKey key)",
                                              "signature_woname": "    private void (SelectionKey key)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                6768,
                                                7218
                                              ],
                                              "original_string": "    private void finishConnection(SelectionKey key) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        try {\n            socketChannel.finishConnect();\n        } catch (IOException e) {\n            logger.warning(\"RemoteSocketHandler::finishConnection I/O exception: \" + e.toString());\n            cleanUp(socketChannel);\n            return;\n        }\n\n        key.interestOps(SelectionKey.OP_WRITE);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "finishConnection",
                                              "body": "                                                                       {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n\n        try {\n            socketChannel.finishConnect();\n        } catch (IOException e) {\n            logger.warning(\"RemoteSocketHandler::finishConnection I/O exception: \" + e.toString());\n            cleanUp(socketChannel);\n            return;\n        }\n\n        key.interestOps(SelectionKey.OP_WRITE);\n    }",
                                              "identifiers": "socketChannel key channel socketChannel finishConnect e logger warning e toString cleanUp socketChannel key interestOps SelectionKey OP_WRITE",
                                              "signature": "    private void finishConnection(SelectionKey key)",
                                              "signature_woname": "    private void (SelectionKey key)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                7224,
                                                7661
                                              ],
                                              "original_string": "    @Override\n    protected void cleanUp(SocketChannel socketChannel) {\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"RemoteSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"RemoteSocket closed (NULL): \" + socketChannel);\n        }\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    protected",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "protected"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "cleanUp",
                                              "body": "                                                        {\n        super.cleanUp(socketChannel);\n\n        PipeWorker pipe = _pipes.get(socketChannel);\n        if (pipe != null) {\n            pipe.close();\n            _pipes.remove(socketChannel);\n            logger.fine(\"RemoteSocket closed: \" + pipe.socketInfo);\n        }\n        else {\n            logger.fine(\"RemoteSocket closed (NULL): \" + socketChannel);\n        }\n    }",
                                              "identifiers": "cleanUp socketChannel pipe _pipes get socketChannel pipe pipe close _pipes remove socketChannel logger fine pipe socketInfo logger fine socketChannel",
                                              "signature": "    @Override\n    protected void cleanUp(SocketChannel socketChannel)",
                                              "signature_woname": "    @Override\n    protected void (SocketChannel socketChannel)"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "imports": [
                                      {
                                        "original_string": "public class Config {\n    private String _ipAddr;\n    private int _port;\n    private String _localIpAddr;\n    private int _localPort;\n    private String _method;\n    private String _password;\n    private String _logLevel;\n    private IProxy.TYPE _proxyType;\n\n    public Config() {\n        loadFromJson(\"\");\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }\n\n    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }\n\n    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }\n\n    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }\n\n    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }\n\n    public void setRemotePort(int value) {\n        _port = value;\n    }\n\n    public int getRemotePort() {\n        return _port;\n    }\n\n    public void setLocalPort(int value) {\n        _localPort = value;\n    }\n\n    public int getLocalPort() {\n        return _localPort;\n    }\n\n    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }\n\n    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }\n    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }\n\n    public void setMethod(String value) {\n        _method = value;\n    }\n\n    public String getMethod() {\n        return _method;\n    }\n\n    public void setPassword(String value) {\n        _password = value;\n    }\n\n    public String getPassword() {\n        return _password;\n    }\n\n    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }\n\n    public String getLogLevel() {\n        return _logLevel;\n    }\n\n    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }\n\n    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }\n}",
                                        "definition": "public class Config",
                                        "byte_span": [
                                          1735,
                                          5565
                                        ],
                                        "start_point": [
                                          41,
                                          0
                                        ],
                                        "end_point": [
                                          175,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Config",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    private String _ipAddr;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_ipAddr",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private int _port;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "_port",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _localIpAddr;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_localIpAddr",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private int _localPort;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "_localPort",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _method;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_method",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _password;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_password",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _logLevel;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_logLevel",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private IProxy.TYPE _proxyType;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "IProxy.TYPE",
                                              "name": "_proxyType",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              1998,
                                              2047
                                            ],
                                            "original_string": "    public Config() {\n        loadFromJson(\"\");\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                    {\n        loadFromJson(\"\");\n    }",
                                            "identifiers": "loadFromJson",
                                            "signature": "    public Config()",
                                            "signature_woname": "    public ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2053,
                                              2393
                                            ],
                                            "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                                                                                                              {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                            "identifiers": "_ipAddr ipAddr _port port _localIpAddr localIpAddr _localPort localPort _method method _password password _proxyType IProxy TYPE AUTO",
                                            "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password)",
                                            "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2399,
                                              2627
                                            ],
                                            "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                                                                                                                                {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                            "identifiers": "ipAddr port localIpAddr localPort method password _proxyType type",
                                            "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)",
                                            "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2633,
                                              2710
                                            ],
                                            "original_string": "    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setRemoteIpAddress",
                                            "body": "                                                 {\n        _ipAddr = value;\n    }",
                                            "identifiers": "_ipAddr value",
                                            "signature": "    public void setRemoteIpAddress(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2716,
                                              2782
                                            ],
                                            "original_string": "    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getRemoteIpAddress",
                                            "body": "                                       {\n        return _ipAddr;\n    }",
                                            "identifiers": "_ipAddr",
                                            "signature": "    public String getRemoteIpAddress()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2788,
                                              2869
                                            ],
                                            "original_string": "    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLocalIpAddress",
                                            "body": "                                                {\n        _localIpAddr = value;\n    }",
                                            "identifiers": "_localIpAddr value",
                                            "signature": "    public void setLocalIpAddress(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2875,
                                              2945
                                            ],
                                            "original_string": "    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getLocalIpAddress",
                                            "body": "                                      {\n        return _localIpAddr;\n    }",
                                            "identifiers": "_localIpAddr",
                                            "signature": "    public String getLocalIpAddress()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2951,
                                              3018
                                            ],
                                            "original_string": "    public void setRemotePort(int value) {\n        _port = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setRemotePort",
                                            "body": "                                         {\n        _port = value;\n    }",
                                            "identifiers": "_port value",
                                            "signature": "    public void setRemotePort(int value)",
                                            "signature_woname": "    public void (int value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3024,
                                              3080
                                            ],
                                            "original_string": "    public int getRemotePort() {\n        return _port;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getRemotePort",
                                            "body": "                               {\n        return _port;\n    }",
                                            "identifiers": "_port",
                                            "signature": "    public int getRemotePort()",
                                            "signature_woname": "    public int ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3086,
                                              3157
                                            ],
                                            "original_string": "    public void setLocalPort(int value) {\n        _localPort = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLocalPort",
                                            "body": "                                        {\n        _localPort = value;\n    }",
                                            "identifiers": "_localPort value",
                                            "signature": "    public void setLocalPort(int value)",
                                            "signature_woname": "    public void (int value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3163,
                                              3223
                                            ],
                                            "original_string": "    public int getLocalPort() {\n        return _localPort;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getLocalPort",
                                            "body": "                              {\n        return _localPort;\n    }",
                                            "identifiers": "_localPort",
                                            "signature": "    public int getLocalPort()",
                                            "signature_woname": "    public int ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3229,
                                              3599
                                            ],
                                            "original_string": "    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setProxyType",
                                            "body": "                                           {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                            "identifiers": "_proxyType IProxy TYPE AUTO value toLowerCase equals IProxy TYPE HTTP toString toLowerCase _proxyType IProxy TYPE HTTP value toLowerCase equals IProxy TYPE SOCKS5 toString toLowerCase _proxyType IProxy TYPE SOCKS5",
                                            "signature": "    public void setProxyType(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3605,
                                              3684
                                            ],
                                            "original_string": "    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setProxyType",
                                            "body": "                                                {\n        _proxyType = value;\n    }",
                                            "identifiers": "_proxyType value",
                                            "signature": "    public void setProxyType(IProxy.TYPE value)",
                                            "signature_woname": "    public void (IProxy.TYPE value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3689,
                                              3757
                                            ],
                                            "original_string": "    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "IProxy.TYPE",
                                              "classes": []
                                            },
                                            "name": "getProxyType",
                                            "body": "                                      {\n        return _proxyType;\n    }",
                                            "identifiers": "_proxyType",
                                            "signature": "    public IProxy.TYPE getProxyType()",
                                            "signature_woname": "    public IProxy.TYPE ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3763,
                                              3831
                                            ],
                                            "original_string": "    public void setMethod(String value) {\n        _method = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setMethod",
                                            "body": "                                        {\n        _method = value;\n    }",
                                            "identifiers": "_method value",
                                            "signature": "    public void setMethod(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3837,
                                              3894
                                            ],
                                            "original_string": "    public String getMethod() {\n        return _method;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getMethod",
                                            "body": "                              {\n        return _method;\n    }",
                                            "identifiers": "_method",
                                            "signature": "    public String getMethod()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3900,
                                              3972
                                            ],
                                            "original_string": "    public void setPassword(String value) {\n        _password = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setPassword",
                                            "body": "                                          {\n        _password = value;\n    }",
                                            "identifiers": "_password value",
                                            "signature": "    public void setPassword(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3978,
                                              4039
                                            ],
                                            "original_string": "    public String getPassword() {\n        return _password;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getPassword",
                                            "body": "                                {\n        return _password;\n    }",
                                            "identifiers": "_password",
                                            "signature": "    public String getPassword()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4045,
                                              4150
                                            ],
                                            "original_string": "    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLogLevel",
                                            "body": "                                          {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                            "identifiers": "_logLevel value Log init getLogLevel",
                                            "signature": "    public void setLogLevel(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4156,
                                              4217
                                            ],
                                            "original_string": "    public String getLogLevel() {\n        return _logLevel;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getLogLevel",
                                            "body": "                                {\n        return _logLevel;\n    }",
                                            "identifiers": "_logLevel",
                                            "signature": "    public String getLogLevel()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4223,
                                              5070
                                            ],
                                            "original_string": "    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "loadFromJson",
                                            "body": "                                             {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                            "identifiers": "jsonStr length jsonStr jObj JSONValue parse jsonStr _ipAddr jObj getOrDefault _port jObj getOrDefault intValue _localIpAddr jObj getOrDefault _localPort jObj getOrDefault intValue _method jObj getOrDefault AesCrypt CIPHER_AES_256_CFB _password jObj getOrDefault _logLevel jObj getOrDefault setProxyType jObj getOrDefault IProxy TYPE SOCKS5 toString toLowerCase setLogLevel _logLevel",
                                            "signature": "    public void loadFromJson(String jsonStr)",
                                            "signature_woname": "    public void (String jsonStr)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              5076,
                                              5563
                                            ],
                                            "original_string": "    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "saveToJson",
                                            "body": "                               {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                            "identifiers": "jObj jObj put _ipAddr jObj put _port jObj put _localIpAddr jObj put _localPort jObj put _method jObj put _password jObj put _proxyType toString toLowerCase jObj put _logLevel Util prettyPrintJson jObj",
                                            "signature": "    public String saveToJson()",
                                            "signature_woname": "    public String ()"
                                          }
                                        ]
                                      },
                                      {
                                        "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                        "definition": "public class Util",
                                        "byte_span": [
                                          1779,
                                          7484
                                        ],
                                        "start_point": [
                                          45,
                                          0
                                        ],
                                        "end_point": [
                                          219,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Util",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              1803,
                                              2018
                                            ],
                                            "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "dumpBytes",
                                            "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                            "identifiers": "sb a length b a sb append String format b sb toString",
                                            "signature": "    public static String dumpBytes(byte[] a)",
                                            "signature_woname": "    public static String (byte[] a)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2024,
                                              2180
                                            ],
                                            "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "byte[]",
                                              "classes": []
                                            },
                                            "name": "randomBytes",
                                            "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                            "identifiers": "bytes size nextBytes bytes bytes",
                                            "signature": "    public static byte[] randomBytes(int size)",
                                            "signature_woname": "    public static byte[] (int size)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2186,
                                              2412
                                            ],
                                            "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getErrorMessage",
                                            "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                            "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                            "signature": "    public static String getErrorMessage(Throwable e)",
                                            "signature_woname": "    public static String (Throwable e)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2418,
                                              4165
                                            ],
                                            "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "prettyPrintJson",
                                            "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                            "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                            "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                            "signature_woname": "    public static String (JSONObject jObj)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4171,
                                              5829
                                            ],
                                            "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getRequestedHostInfo",
                                            "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                            "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                            "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                            "signature_woname": "    public static String (byte[] data)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              5835,
                                              6128
                                            ],
                                            "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "bytesToString",
                                            "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                            "identifiers": "str str data start length e e printStackTrace str",
                                            "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                            "signature_woname": "    public static String (byte[] data, int start, int length)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6134,
                                              6648
                                            ],
                                            "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "byte[]",
                                              "classes": []
                                            },
                                            "name": "composeSSHeader",
                                            "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                            "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                            "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                            "signature_woname": "    public static byte[] (String host, int port)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6654,
                                              6969
                                            ],
                                            "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "boolean",
                                              "classes": []
                                            },
                                            "name": "saveFile",
                                            "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                            "identifiers": "writer writer fn writer println content writer close e",
                                            "signature": "    public static boolean saveFile(String fn, String content)",
                                            "signature_woname": "    public static boolean (String fn, String content)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6975,
                                              7262
                                            ],
                                            "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getFileContent",
                                            "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                            "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                            "signature": "    public static String getFileContent(String fn)",
                                            "signature_woname": "    public static String (String fn)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              7268,
                                              7357
                                            ],
                                            "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "short",
                                              "classes": []
                                            },
                                            "name": "byteToUnsignedByte",
                                            "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                            "identifiers": "b",
                                            "signature": "    private static short byteToUnsignedByte(byte b)",
                                            "signature_woname": "    private static short (byte b)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              7363,
                                              7482
                                            ],
                                            "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getPort",
                                            "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                            "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                            "signature": "    private static int getPort(byte b, byte b1)",
                                            "signature_woname": "    private static int (byte b, byte b1)"
                                          }
                                        ]
                                      }
                                    ]
                                  },
                                  {
                                    "name": "SocketHandlerBase.java",
                                    "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network.nio;\n\nimport com.stfl.misc.Config;\nimport com.stfl.misc.Util;\nimport com.stfl.Constant;\nimport com.stfl.network.IServer;\nimport com.stfl.ss.CryptFactory;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedSelectorException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.logging.Logger;\n\n/**\n * Base class of socket handler for processing all IO event for sockets\n */\npublic abstract class SocketHandlerBase implements IServer, ISocketHandler {\n    private Logger logger = Logger.getLogger(SocketHandlerBase.class.getName());\n    protected Selector _selector;\n    protected Config _config;\n    protected final List _pendingRequest = new LinkedList();\n    protected final ConcurrentHashMap _pendingData = new ConcurrentHashMap();\n    protected ConcurrentMap<SocketChannel, PipeWorker> _pipes = new ConcurrentHashMap<>();\n    protected ByteBuffer _readBuffer = ByteBuffer.allocate(Constant.BUFFER_SIZE);\n\n    protected abstract Selector initSelector() throws IOException;\n    protected abstract boolean processPendingRequest(ChangeRequest request);\n    protected abstract void processSelect(SelectionKey key);\n\n\n    public SocketHandlerBase(Config config) throws IOException, InvalidAlgorithmParameterException {\n        if (!CryptFactory.isCipherExisted(config.getMethod())) {\n            throw new InvalidAlgorithmParameterException(config.getMethod());\n        }\n        _config = config;\n        _selector = initSelector();\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                synchronized (_pendingRequest) {\n                    Iterator changes = _pendingRequest.iterator();\n                    while (changes.hasNext()) {\n                        ChangeRequest change = (ChangeRequest) changes.next();\n                        if (!processPendingRequest(change))\n                            break;\n                        changes.remove();\n                    }\n                }\n\n                // wait events from selected channels\n                _selector.select();\n\n                Iterator selectedKeys = _selector.selectedKeys().iterator();\n                while (selectedKeys.hasNext()) {\n                    SelectionKey key = (SelectionKey) selectedKeys.next();\n                    selectedKeys.remove();\n\n                    if (!key.isValid()) {\n                        continue;\n                    }\n\n                    processSelect(key);\n                }\n            }\n            catch (ClosedSelectorException e) {\n                break;\n            }\n            catch (Exception e) {\n                logger.warning(Util.getErrorMessage(e));\n            }\n        }\n        logger.fine(this.getClass().getName() + \" Closed.\");\n    }\n\n    protected void createWriteBuffer(SocketChannel socketChannel) {\n        List queue = new ArrayList();\n        Object put;\n        put = _pendingData.putIfAbsent(socketChannel, queue);\n        if (put != null) {\n            logger.severe(\"Dup write buffer creation: \" + socketChannel);\n        }\n    }\n\n    protected void cleanUp(SocketChannel socketChannel) {\n        try {\n            socketChannel.close();\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n        }\n        SelectionKey key = socketChannel.keyFor(_selector);\n        if (key != null) {\n            key.cancel();\n        }\n\n        if (_pendingData.containsKey(socketChannel)) {\n            _pendingData.remove(socketChannel);\n        }\n    }\n\n    @Override\n    public void send(ChangeRequest request, byte[] data) {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                List queue = (List) _pendingData.get(request.socket);\n                if (queue != null) {\n                    synchronized (queue) {\n                        // in general case, the write queue is always existed, unless, the socket has been shutdown\n                        queue.add(ByteBuffer.wrap(data));\n                    }\n                }\n                else {\n                    logger.warning(Util.getErrorMessage(new Throwable(\"Socket is closed! dropping this request\")));\n                }\n                break;\n        }\n\n        synchronized (_pendingRequest) {\n            _pendingRequest.add(request);\n        }\n\n        _selector.wakeup();\n    }\n\n    @Override\n    public void send(ChangeRequest request) {\n        send(request, null);\n    }\n\n    public void close() {\n        for (PipeWorker p : _pipes.values()) {\n            p.forceClose();\n        }\n        _pipes.clear();\n        try {\n            _selector.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n    }\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.nio;",
                                        "import com.stfl.misc.Config;",
                                        "import com.stfl.misc.Util;",
                                        "import com.stfl.Constant;",
                                        "import com.stfl.network.IServer;",
                                        "import com.stfl.ss.CryptFactory;",
                                        "import java.io.IOException;",
                                        "import java.nio.ByteBuffer;",
                                        "import java.nio.channels.ClosedSelectorException;",
                                        "import java.nio.channels.SelectionKey;",
                                        "import java.nio.channels.Selector;",
                                        "import java.nio.channels.SocketChannel;",
                                        "import java.security.InvalidAlgorithmParameterException;",
                                        "import java.util.*;",
                                        "import java.util.concurrent.ConcurrentHashMap;",
                                        "import java.util.concurrent.ConcurrentMap;",
                                        "import java.util.logging.Logger;"
                                      ],
                                      "methods": [],
                                      "classes": [
                                        {
                                          "original_string": "public abstract class SocketHandlerBase implements IServer, ISocketHandler {\n    private Logger logger = Logger.getLogger(SocketHandlerBase.class.getName());\n    protected Selector _selector;\n    protected Config _config;\n    protected final List _pendingRequest = new LinkedList();\n    protected final ConcurrentHashMap _pendingData = new ConcurrentHashMap();\n    protected ConcurrentMap<SocketChannel, PipeWorker> _pipes = new ConcurrentHashMap<>();\n    protected ByteBuffer _readBuffer = ByteBuffer.allocate(Constant.BUFFER_SIZE);\n\n    protected abstract Selector initSelector() throws IOException;\n    protected abstract boolean processPendingRequest(ChangeRequest request);\n    protected abstract void processSelect(SelectionKey key);\n\n\n    public SocketHandlerBase(Config config) throws IOException, InvalidAlgorithmParameterException {\n        if (!CryptFactory.isCipherExisted(config.getMethod())) {\n            throw new InvalidAlgorithmParameterException(config.getMethod());\n        }\n        _config = config;\n        _selector = initSelector();\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                synchronized (_pendingRequest) {\n                    Iterator changes = _pendingRequest.iterator();\n                    while (changes.hasNext()) {\n                        ChangeRequest change = (ChangeRequest) changes.next();\n                        if (!processPendingRequest(change))\n                            break;\n                        changes.remove();\n                    }\n                }\n\n                // wait events from selected channels\n                _selector.select();\n\n                Iterator selectedKeys = _selector.selectedKeys().iterator();\n                while (selectedKeys.hasNext()) {\n                    SelectionKey key = (SelectionKey) selectedKeys.next();\n                    selectedKeys.remove();\n\n                    if (!key.isValid()) {\n                        continue;\n                    }\n\n                    processSelect(key);\n                }\n            }\n            catch (ClosedSelectorException e) {\n                break;\n            }\n            catch (Exception e) {\n                logger.warning(Util.getErrorMessage(e));\n            }\n        }\n        logger.fine(this.getClass().getName() + \" Closed.\");\n    }\n\n    protected void createWriteBuffer(SocketChannel socketChannel) {\n        List queue = new ArrayList();\n        Object put;\n        put = _pendingData.putIfAbsent(socketChannel, queue);\n        if (put != null) {\n            logger.severe(\"Dup write buffer creation: \" + socketChannel);\n        }\n    }\n\n    protected void cleanUp(SocketChannel socketChannel) {\n        try {\n            socketChannel.close();\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n        }\n        SelectionKey key = socketChannel.keyFor(_selector);\n        if (key != null) {\n            key.cancel();\n        }\n\n        if (_pendingData.containsKey(socketChannel)) {\n            _pendingData.remove(socketChannel);\n        }\n    }\n\n    @Override\n    public void send(ChangeRequest request, byte[] data) {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                List queue = (List) _pendingData.get(request.socket);\n                if (queue != null) {\n                    synchronized (queue) {\n                        // in general case, the write queue is always existed, unless, the socket has been shutdown\n                        queue.add(ByteBuffer.wrap(data));\n                    }\n                }\n                else {\n                    logger.warning(Util.getErrorMessage(new Throwable(\"Socket is closed! dropping this request\")));\n                }\n                break;\n        }\n\n        synchronized (_pendingRequest) {\n            _pendingRequest.add(request);\n        }\n\n        _selector.wakeup();\n    }\n\n    @Override\n    public void send(ChangeRequest request) {\n        send(request, null);\n    }\n\n    public void close() {\n        for (PipeWorker p : _pipes.values()) {\n            p.forceClose();\n        }\n        _pipes.clear();\n        try {\n            _selector.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n    }\n}",
                                          "definition": "public abstract class SocketHandlerBase implements IServer, ISocketHandler",
                                          "byte_span": [
                                            2196,
                                            6505
                                          ],
                                          "start_point": [
                                            54,
                                            0
                                          ],
                                          "end_point": [
                                            180,
                                            1
                                          ],
                                          "class_docstring": "",
                                          "name": "SocketHandlerBase",
                                          "attributes": {
                                            "modifiers": "public abstract",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public",
                                              "abstract"
                                            ],
                                            "comments": [],
                                            "fields": [
                                              {
                                                "attribute_expression": "    private Logger logger = Logger.getLogger(SocketHandlerBase.class.getName());",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Logger",
                                                "name": "logger = Logger.getLogger(SocketHandlerBase.class.getName())",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    protected Selector _selector;",
                                                "docstring": "",
                                                "modifiers": "protected",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "protected"
                                                ],
                                                "comments": [],
                                                "type": "Selector",
                                                "name": "_selector",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    protected Config _config;",
                                                "docstring": "",
                                                "modifiers": "protected",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "protected"
                                                ],
                                                "comments": [],
                                                "type": "Config",
                                                "name": "_config",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    protected final List _pendingRequest = new LinkedList();",
                                                "docstring": "",
                                                "modifiers": "protected final",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "protected",
                                                  "final"
                                                ],
                                                "comments": [],
                                                "type": "List",
                                                "name": "_pendingRequest = new LinkedList()",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    protected final ConcurrentHashMap _pendingData = new ConcurrentHashMap();",
                                                "docstring": "",
                                                "modifiers": "protected final",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "protected",
                                                  "final"
                                                ],
                                                "comments": [],
                                                "type": "ConcurrentHashMap",
                                                "name": "_pendingData = new ConcurrentHashMap()",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    protected ConcurrentMap<SocketChannel, PipeWorker> _pipes = new ConcurrentHashMap<>();",
                                                "docstring": "",
                                                "modifiers": "protected",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "protected"
                                                ],
                                                "comments": [],
                                                "type": "ConcurrentMap<SocketChannel, PipeWorker>",
                                                "name": "_pipes = new ConcurrentHashMap<>()",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    protected ByteBuffer _readBuffer = ByteBuffer.allocate(Constant.BUFFER_SIZE);",
                                                "docstring": "",
                                                "modifiers": "protected",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "protected"
                                                ],
                                                "comments": [],
                                                "type": "ByteBuffer",
                                                "name": "_readBuffer = ByteBuffer.allocate(Constant.BUFFER_SIZE)",
                                                "syntax_pass": true
                                              }
                                            ],
                                            "classes": []
                                          },
                                          "syntax_pass": true,
                                          "methods": [
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2735,
                                                2797
                                              ],
                                              "original_string": "    protected abstract Selector initSelector() throws IOException;",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "protected abstract",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "protected",
                                                  "abstract"
                                                ],
                                                "comments": [],
                                                "return_type": "Selector",
                                                "classes": []
                                              },
                                              "name": "initSelector",
                                              "body": "",
                                              "identifiers": "",
                                              "signature": "    protected abstract Selector initSelector()",
                                              "signature_woname": "    protected abstract Selector ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2802,
                                                2874
                                              ],
                                              "original_string": "    protected abstract boolean processPendingRequest(ChangeRequest request);",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "protected abstract",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "protected",
                                                  "abstract"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "processPendingRequest",
                                              "body": "",
                                              "identifiers": "",
                                              "signature": "    protected abstract boolean processPendingRequest(ChangeRequest request)",
                                              "signature_woname": "    protected abstract boolean (ChangeRequest request)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2879,
                                                2935
                                              ],
                                              "original_string": "    protected abstract void processSelect(SelectionKey key);",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "protected abstract",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "protected",
                                                  "abstract"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "processSelect",
                                              "body": "",
                                              "identifiers": "",
                                              "signature": "    protected abstract void processSelect(SelectionKey key)",
                                              "signature_woname": "    protected abstract void (SelectionKey key)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2942,
                                                3259
                                              ],
                                              "original_string": "    public SocketHandlerBase(Config config) throws IOException, InvalidAlgorithmParameterException {\n        if (!CryptFactory.isCipherExisted(config.getMethod())) {\n            throw new InvalidAlgorithmParameterException(config.getMethod());\n        }\n        _config = config;\n        _selector = initSelector();\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "",
                                                "classes": []
                                              },
                                              "name": "SocketHandlerBase",
                                              "body": "                                                                                                   {\n        if (!CryptFactory.isCipherExisted(config.getMethod())) {\n            throw new InvalidAlgorithmParameterException(config.getMethod());\n        }\n        _config = config;\n        _selector = initSelector();\n    }",
                                              "identifiers": "CryptFactory isCipherExisted config getMethod config getMethod _config config _selector initSelector",
                                              "signature": "    public SocketHandlerBase(Config config)",
                                              "signature_woname": "    public (Config config)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                3265,
                                                4534
                                              ],
                                              "original_string": "    @Override\n    public void run() {\n        while (true) {\n            try {\n                synchronized (_pendingRequest) {\n                    Iterator changes = _pendingRequest.iterator();\n                    while (changes.hasNext()) {\n                        ChangeRequest change = (ChangeRequest) changes.next();\n                        if (!processPendingRequest(change))\n                            break;\n                        changes.remove();\n                    }\n                }\n\n                // wait events from selected channels\n                _selector.select();\n\n                Iterator selectedKeys = _selector.selectedKeys().iterator();\n                while (selectedKeys.hasNext()) {\n                    SelectionKey key = (SelectionKey) selectedKeys.next();\n                    selectedKeys.remove();\n\n                    if (!key.isValid()) {\n                        continue;\n                    }\n\n                    processSelect(key);\n                }\n            }\n            catch (ClosedSelectorException e) {\n                break;\n            }\n            catch (Exception e) {\n                logger.warning(Util.getErrorMessage(e));\n            }\n        }\n        logger.fine(this.getClass().getName() + \" Closed.\");\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "run",
                                              "body": "                      {\n        while (true) {\n            try {\n                synchronized (_pendingRequest) {\n                    Iterator changes = _pendingRequest.iterator();\n                    while (changes.hasNext()) {\n                        ChangeRequest change = (ChangeRequest) changes.next();\n                        if (!processPendingRequest(change))\n                            break;\n                        changes.remove();\n                    }\n                }\n\n                // wait events from selected channels\n                _selector.select();\n\n                Iterator selectedKeys = _selector.selectedKeys().iterator();\n                while (selectedKeys.hasNext()) {\n                    SelectionKey key = (SelectionKey) selectedKeys.next();\n                    selectedKeys.remove();\n\n                    if (!key.isValid()) {\n                        continue;\n                    }\n\n                    processSelect(key);\n                }\n            }\n            catch (ClosedSelectorException e) {\n                break;\n            }\n            catch (Exception e) {\n                logger.warning(Util.getErrorMessage(e));\n            }\n        }\n        logger.fine(this.getClass().getName() + \" Closed.\");\n    }",
                                              "identifiers": "_pendingRequest changes _pendingRequest iterator changes hasNext change changes next processPendingRequest change changes remove _selector select selectedKeys _selector selectedKeys iterator selectedKeys hasNext key selectedKeys next selectedKeys remove key isValid processSelect key e e logger warning Util getErrorMessage e logger fine getClass getName",
                                              "signature": "    @Override\n    public void run()",
                                              "signature_woname": "    @Override\n    public void ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                4540,
                                                4840
                                              ],
                                              "original_string": "    protected void createWriteBuffer(SocketChannel socketChannel) {\n        List queue = new ArrayList();\n        Object put;\n        put = _pendingData.putIfAbsent(socketChannel, queue);\n        if (put != null) {\n            logger.severe(\"Dup write buffer creation: \" + socketChannel);\n        }\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "protected",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "protected"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "createWriteBuffer",
                                              "body": "                                                                  {\n        List queue = new ArrayList();\n        Object put;\n        put = _pendingData.putIfAbsent(socketChannel, queue);\n        if (put != null) {\n            logger.severe(\"Dup write buffer creation: \" + socketChannel);\n        }\n    }",
                                              "identifiers": "queue put put _pendingData putIfAbsent socketChannel queue put logger severe socketChannel",
                                              "signature": "    protected void createWriteBuffer(SocketChannel socketChannel)",
                                              "signature_woname": "    protected void (SocketChannel socketChannel)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                4846,
                                                5285
                                              ],
                                              "original_string": "    protected void cleanUp(SocketChannel socketChannel) {\n        try {\n            socketChannel.close();\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n        }\n        SelectionKey key = socketChannel.keyFor(_selector);\n        if (key != null) {\n            key.cancel();\n        }\n\n        if (_pendingData.containsKey(socketChannel)) {\n            _pendingData.remove(socketChannel);\n        }\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "protected",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "protected"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "cleanUp",
                                              "body": "                                                        {\n        try {\n            socketChannel.close();\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n        }\n        SelectionKey key = socketChannel.keyFor(_selector);\n        if (key != null) {\n            key.cancel();\n        }\n\n        if (_pendingData.containsKey(socketChannel)) {\n            _pendingData.remove(socketChannel);\n        }\n    }",
                                              "identifiers": "socketChannel close e logger info Util getErrorMessage e key socketChannel keyFor _selector key key cancel _pendingData containsKey socketChannel _pendingData remove socketChannel",
                                              "signature": "    protected void cleanUp(SocketChannel socketChannel)",
                                              "signature_woname": "    protected void (SocketChannel socketChannel)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                5291,
                                                6123
                                              ],
                                              "original_string": "    @Override\n    public void send(ChangeRequest request, byte[] data) {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                List queue = (List) _pendingData.get(request.socket);\n                if (queue != null) {\n                    synchronized (queue) {\n                        // in general case, the write queue is always existed, unless, the socket has been shutdown\n                        queue.add(ByteBuffer.wrap(data));\n                    }\n                }\n                else {\n                    logger.warning(Util.getErrorMessage(new Throwable(\"Socket is closed! dropping this request\")));\n                }\n                break;\n        }\n\n        synchronized (_pendingRequest) {\n            _pendingRequest.add(request);\n        }\n\n        _selector.wakeup();\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "send",
                                              "body": "                                                         {\n        switch (request.type) {\n            case ChangeRequest.CHANGE_SOCKET_OP:\n                List queue = (List) _pendingData.get(request.socket);\n                if (queue != null) {\n                    synchronized (queue) {\n                        // in general case, the write queue is always existed, unless, the socket has been shutdown\n                        queue.add(ByteBuffer.wrap(data));\n                    }\n                }\n                else {\n                    logger.warning(Util.getErrorMessage(new Throwable(\"Socket is closed! dropping this request\")));\n                }\n                break;\n        }\n\n        synchronized (_pendingRequest) {\n            _pendingRequest.add(request);\n        }\n\n        _selector.wakeup();\n    }",
                                              "identifiers": "request type ChangeRequest CHANGE_SOCKET_OP queue _pendingData get request socket queue queue queue add ByteBuffer wrap data logger warning Util getErrorMessage _pendingRequest _pendingRequest add request _selector wakeup",
                                              "signature": "    @Override\n    public void send(ChangeRequest request, byte[] data)",
                                              "signature_woname": "    @Override\n    public void (ChangeRequest request, byte[] data)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                6129,
                                                6219
                                              ],
                                              "original_string": "    @Override\n    public void send(ChangeRequest request) {\n        send(request, null);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "send",
                                              "body": "                                            {\n        send(request, null);\n    }",
                                              "identifiers": "send request",
                                              "signature": "    @Override\n    public void send(ChangeRequest request)",
                                              "signature_woname": "    @Override\n    public void (ChangeRequest request)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                6225,
                                                6503
                                              ],
                                              "original_string": "    public void close() {\n        for (PipeWorker p : _pipes.values()) {\n            p.forceClose();\n        }\n        _pipes.clear();\n        try {\n            _selector.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "close",
                                              "body": "                        {\n        for (PipeWorker p : _pipes.values()) {\n            p.forceClose();\n        }\n        _pipes.clear();\n        try {\n            _selector.close();\n        } catch (IOException e) {\n            logger.warning(Util.getErrorMessage(e));\n        }\n    }",
                                              "identifiers": "p _pipes values p forceClose _pipes clear _selector close e logger warning Util getErrorMessage e",
                                              "signature": "    public void close()",
                                              "signature_woname": "    public void ()"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "imports": [
                                      {
                                        "original_string": "public class Config {\n    private String _ipAddr;\n    private int _port;\n    private String _localIpAddr;\n    private int _localPort;\n    private String _method;\n    private String _password;\n    private String _logLevel;\n    private IProxy.TYPE _proxyType;\n\n    public Config() {\n        loadFromJson(\"\");\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }\n\n    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }\n\n    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }\n\n    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }\n\n    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }\n\n    public void setRemotePort(int value) {\n        _port = value;\n    }\n\n    public int getRemotePort() {\n        return _port;\n    }\n\n    public void setLocalPort(int value) {\n        _localPort = value;\n    }\n\n    public int getLocalPort() {\n        return _localPort;\n    }\n\n    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }\n\n    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }\n    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }\n\n    public void setMethod(String value) {\n        _method = value;\n    }\n\n    public String getMethod() {\n        return _method;\n    }\n\n    public void setPassword(String value) {\n        _password = value;\n    }\n\n    public String getPassword() {\n        return _password;\n    }\n\n    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }\n\n    public String getLogLevel() {\n        return _logLevel;\n    }\n\n    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }\n\n    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }\n}",
                                        "definition": "public class Config",
                                        "byte_span": [
                                          1735,
                                          5565
                                        ],
                                        "start_point": [
                                          41,
                                          0
                                        ],
                                        "end_point": [
                                          175,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Config",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    private String _ipAddr;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_ipAddr",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private int _port;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "_port",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _localIpAddr;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_localIpAddr",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private int _localPort;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "_localPort",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _method;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_method",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _password;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_password",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _logLevel;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_logLevel",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private IProxy.TYPE _proxyType;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "IProxy.TYPE",
                                              "name": "_proxyType",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              1998,
                                              2047
                                            ],
                                            "original_string": "    public Config() {\n        loadFromJson(\"\");\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                    {\n        loadFromJson(\"\");\n    }",
                                            "identifiers": "loadFromJson",
                                            "signature": "    public Config()",
                                            "signature_woname": "    public ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2053,
                                              2393
                                            ],
                                            "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                                                                                                              {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                            "identifiers": "_ipAddr ipAddr _port port _localIpAddr localIpAddr _localPort localPort _method method _password password _proxyType IProxy TYPE AUTO",
                                            "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password)",
                                            "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2399,
                                              2627
                                            ],
                                            "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                                                                                                                                {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                            "identifiers": "ipAddr port localIpAddr localPort method password _proxyType type",
                                            "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)",
                                            "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2633,
                                              2710
                                            ],
                                            "original_string": "    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setRemoteIpAddress",
                                            "body": "                                                 {\n        _ipAddr = value;\n    }",
                                            "identifiers": "_ipAddr value",
                                            "signature": "    public void setRemoteIpAddress(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2716,
                                              2782
                                            ],
                                            "original_string": "    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getRemoteIpAddress",
                                            "body": "                                       {\n        return _ipAddr;\n    }",
                                            "identifiers": "_ipAddr",
                                            "signature": "    public String getRemoteIpAddress()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2788,
                                              2869
                                            ],
                                            "original_string": "    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLocalIpAddress",
                                            "body": "                                                {\n        _localIpAddr = value;\n    }",
                                            "identifiers": "_localIpAddr value",
                                            "signature": "    public void setLocalIpAddress(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2875,
                                              2945
                                            ],
                                            "original_string": "    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getLocalIpAddress",
                                            "body": "                                      {\n        return _localIpAddr;\n    }",
                                            "identifiers": "_localIpAddr",
                                            "signature": "    public String getLocalIpAddress()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2951,
                                              3018
                                            ],
                                            "original_string": "    public void setRemotePort(int value) {\n        _port = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setRemotePort",
                                            "body": "                                         {\n        _port = value;\n    }",
                                            "identifiers": "_port value",
                                            "signature": "    public void setRemotePort(int value)",
                                            "signature_woname": "    public void (int value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3024,
                                              3080
                                            ],
                                            "original_string": "    public int getRemotePort() {\n        return _port;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getRemotePort",
                                            "body": "                               {\n        return _port;\n    }",
                                            "identifiers": "_port",
                                            "signature": "    public int getRemotePort()",
                                            "signature_woname": "    public int ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3086,
                                              3157
                                            ],
                                            "original_string": "    public void setLocalPort(int value) {\n        _localPort = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLocalPort",
                                            "body": "                                        {\n        _localPort = value;\n    }",
                                            "identifiers": "_localPort value",
                                            "signature": "    public void setLocalPort(int value)",
                                            "signature_woname": "    public void (int value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3163,
                                              3223
                                            ],
                                            "original_string": "    public int getLocalPort() {\n        return _localPort;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getLocalPort",
                                            "body": "                              {\n        return _localPort;\n    }",
                                            "identifiers": "_localPort",
                                            "signature": "    public int getLocalPort()",
                                            "signature_woname": "    public int ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3229,
                                              3599
                                            ],
                                            "original_string": "    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setProxyType",
                                            "body": "                                           {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                            "identifiers": "_proxyType IProxy TYPE AUTO value toLowerCase equals IProxy TYPE HTTP toString toLowerCase _proxyType IProxy TYPE HTTP value toLowerCase equals IProxy TYPE SOCKS5 toString toLowerCase _proxyType IProxy TYPE SOCKS5",
                                            "signature": "    public void setProxyType(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3605,
                                              3684
                                            ],
                                            "original_string": "    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setProxyType",
                                            "body": "                                                {\n        _proxyType = value;\n    }",
                                            "identifiers": "_proxyType value",
                                            "signature": "    public void setProxyType(IProxy.TYPE value)",
                                            "signature_woname": "    public void (IProxy.TYPE value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3689,
                                              3757
                                            ],
                                            "original_string": "    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "IProxy.TYPE",
                                              "classes": []
                                            },
                                            "name": "getProxyType",
                                            "body": "                                      {\n        return _proxyType;\n    }",
                                            "identifiers": "_proxyType",
                                            "signature": "    public IProxy.TYPE getProxyType()",
                                            "signature_woname": "    public IProxy.TYPE ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3763,
                                              3831
                                            ],
                                            "original_string": "    public void setMethod(String value) {\n        _method = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setMethod",
                                            "body": "                                        {\n        _method = value;\n    }",
                                            "identifiers": "_method value",
                                            "signature": "    public void setMethod(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3837,
                                              3894
                                            ],
                                            "original_string": "    public String getMethod() {\n        return _method;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getMethod",
                                            "body": "                              {\n        return _method;\n    }",
                                            "identifiers": "_method",
                                            "signature": "    public String getMethod()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3900,
                                              3972
                                            ],
                                            "original_string": "    public void setPassword(String value) {\n        _password = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setPassword",
                                            "body": "                                          {\n        _password = value;\n    }",
                                            "identifiers": "_password value",
                                            "signature": "    public void setPassword(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3978,
                                              4039
                                            ],
                                            "original_string": "    public String getPassword() {\n        return _password;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getPassword",
                                            "body": "                                {\n        return _password;\n    }",
                                            "identifiers": "_password",
                                            "signature": "    public String getPassword()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4045,
                                              4150
                                            ],
                                            "original_string": "    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLogLevel",
                                            "body": "                                          {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                            "identifiers": "_logLevel value Log init getLogLevel",
                                            "signature": "    public void setLogLevel(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4156,
                                              4217
                                            ],
                                            "original_string": "    public String getLogLevel() {\n        return _logLevel;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getLogLevel",
                                            "body": "                                {\n        return _logLevel;\n    }",
                                            "identifiers": "_logLevel",
                                            "signature": "    public String getLogLevel()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4223,
                                              5070
                                            ],
                                            "original_string": "    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "loadFromJson",
                                            "body": "                                             {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                            "identifiers": "jsonStr length jsonStr jObj JSONValue parse jsonStr _ipAddr jObj getOrDefault _port jObj getOrDefault intValue _localIpAddr jObj getOrDefault _localPort jObj getOrDefault intValue _method jObj getOrDefault AesCrypt CIPHER_AES_256_CFB _password jObj getOrDefault _logLevel jObj getOrDefault setProxyType jObj getOrDefault IProxy TYPE SOCKS5 toString toLowerCase setLogLevel _logLevel",
                                            "signature": "    public void loadFromJson(String jsonStr)",
                                            "signature_woname": "    public void (String jsonStr)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              5076,
                                              5563
                                            ],
                                            "original_string": "    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "saveToJson",
                                            "body": "                               {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                            "identifiers": "jObj jObj put _ipAddr jObj put _port jObj put _localIpAddr jObj put _localPort jObj put _method jObj put _password jObj put _proxyType toString toLowerCase jObj put _logLevel Util prettyPrintJson jObj",
                                            "signature": "    public String saveToJson()",
                                            "signature_woname": "    public String ()"
                                          }
                                        ]
                                      },
                                      {
                                        "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                        "definition": "public class Util",
                                        "byte_span": [
                                          1779,
                                          7484
                                        ],
                                        "start_point": [
                                          45,
                                          0
                                        ],
                                        "end_point": [
                                          219,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Util",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              1803,
                                              2018
                                            ],
                                            "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "dumpBytes",
                                            "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                            "identifiers": "sb a length b a sb append String format b sb toString",
                                            "signature": "    public static String dumpBytes(byte[] a)",
                                            "signature_woname": "    public static String (byte[] a)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2024,
                                              2180
                                            ],
                                            "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "byte[]",
                                              "classes": []
                                            },
                                            "name": "randomBytes",
                                            "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                            "identifiers": "bytes size nextBytes bytes bytes",
                                            "signature": "    public static byte[] randomBytes(int size)",
                                            "signature_woname": "    public static byte[] (int size)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2186,
                                              2412
                                            ],
                                            "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getErrorMessage",
                                            "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                            "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                            "signature": "    public static String getErrorMessage(Throwable e)",
                                            "signature_woname": "    public static String (Throwable e)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2418,
                                              4165
                                            ],
                                            "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "prettyPrintJson",
                                            "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                            "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                            "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                            "signature_woname": "    public static String (JSONObject jObj)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4171,
                                              5829
                                            ],
                                            "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getRequestedHostInfo",
                                            "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                            "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                            "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                            "signature_woname": "    public static String (byte[] data)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              5835,
                                              6128
                                            ],
                                            "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "bytesToString",
                                            "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                            "identifiers": "str str data start length e e printStackTrace str",
                                            "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                            "signature_woname": "    public static String (byte[] data, int start, int length)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6134,
                                              6648
                                            ],
                                            "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "byte[]",
                                              "classes": []
                                            },
                                            "name": "composeSSHeader",
                                            "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                            "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                            "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                            "signature_woname": "    public static byte[] (String host, int port)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6654,
                                              6969
                                            ],
                                            "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "boolean",
                                              "classes": []
                                            },
                                            "name": "saveFile",
                                            "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                            "identifiers": "writer writer fn writer println content writer close e",
                                            "signature": "    public static boolean saveFile(String fn, String content)",
                                            "signature_woname": "    public static boolean (String fn, String content)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6975,
                                              7262
                                            ],
                                            "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getFileContent",
                                            "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                            "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                            "signature": "    public static String getFileContent(String fn)",
                                            "signature_woname": "    public static String (String fn)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              7268,
                                              7357
                                            ],
                                            "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "short",
                                              "classes": []
                                            },
                                            "name": "byteToUnsignedByte",
                                            "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                            "identifiers": "b",
                                            "signature": "    private static short byteToUnsignedByte(byte b)",
                                            "signature_woname": "    private static short (byte b)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              7363,
                                              7482
                                            ],
                                            "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getPort",
                                            "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                            "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                            "signature": "    private static int getPort(byte b, byte b1)",
                                            "signature_woname": "    private static int (byte b, byte b1)"
                                          }
                                        ]
                                      },
                                      {
                                        "original_string": "public class Constant {\n    public static final String PROG_NAME = \"shadowsocks-java\";\n    public static final String VERSION = \"0.2\";\n    public static final int BUFFER_SIZE = 16384;\n    public static final String CONF_FILE = \"config.json\";\n    public static final Locale LOCALE = Locale.getDefault();\n}",
                                        "definition": "public class Constant",
                                        "byte_span": [
                                          45,
                                          349
                                        ],
                                        "start_point": [
                                          4,
                                          0
                                        ],
                                        "end_point": [
                                          10,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Constant",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    public static final String PROG_NAME = \"shadowsocks-java\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "PROG_NAME = \"shadowsocks-java\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final String VERSION = \"0.2\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "VERSION = \"0.2\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final int BUFFER_SIZE = 16384;",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "BUFFER_SIZE = 16384",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final String CONF_FILE = \"config.json\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "CONF_FILE = \"config.json\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final Locale LOCALE = Locale.getDefault();",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "Locale",
                                              "name": "LOCALE = Locale.getDefault()",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": []
                                      },
                                      {
                                        "original_string": "public class CryptFactory {\n    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};\n    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());\n\n    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }\n\n    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                        "definition": "public class CryptFactory",
                                        "byte_span": [
                                          1649,
                                          2693
                                        ],
                                        "start_point": [
                                          40,
                                          0
                                        ],
                                        "end_point": [
                                          71,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "CryptFactory",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};",
                                              "docstring": "",
                                              "modifiers": "private static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "Map<String, String>",
                                              "name": "crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }}",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());",
                                              "docstring": "",
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "type": "Logger",
                                              "name": "logger = Logger.getLogger(CryptFactory.class.getName())",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2057,
                                              2158
                                            ],
                                            "original_string": "    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "boolean",
                                              "classes": []
                                            },
                                            "name": "isCipherExisted",
                                            "body": "                                                       {\n        return (crypts.get(name) != null);\n    }",
                                            "identifiers": "crypts get name",
                                            "signature": "    public static boolean isCipherExisted(String name)",
                                            "signature_woname": "    public static boolean (String name)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2164,
                                              2504
                                            ],
                                            "original_string": "    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "ICrypt",
                                              "classes": []
                                            },
                                            "name": "get",
                                            "body": "                                                           {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                            "identifiers": "obj Reflection get crypts get name name password obj e logger info com stfl misc Util getErrorMessage e",
                                            "signature": "    public static ICrypt get(String name, String password)",
                                            "signature_woname": "    public static ICrypt (String name, String password)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2510,
                                              2691
                                            ],
                                            "original_string": "    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "List<String>",
                                              "classes": []
                                            },
                                            "name": "getSupportedCiphers",
                                            "body": "                                                     {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                            "identifiers": "sortedKeys crypts keySet Collections sort sortedKeys sortedKeys",
                                            "signature": "    public static List<String> getSupportedCiphers()",
                                            "signature_woname": "    public static List<String> ()"
                                          }
                                        ]
                                      }
                                    ]
                                  },
                                  {
                                    "name": "ChangeRequest.java",
                                    "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network.nio;\n\nimport java.nio.channels.SocketChannel;\n\n/**\n * Request for nio socket handler\n */\npublic class ChangeRequest {\n    public static final int REGISTER_CHANNEL = 1;\n    public static final int CHANGE_SOCKET_OP = 2;\n    public static final int CLOSE_CHANNEL = 3;\n\n    public SocketChannel socket;\n    public int type;\n    public int op;\n\n    public ChangeRequest(SocketChannel socket, int type, int op) {\n        this.socket = socket;\n        this.type = type;\n        this.op = op;\n    }\n\n    public ChangeRequest(SocketChannel socket, int type) {\n        this(socket, type, 0);\n    }\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.nio;",
                                        "import java.nio.channels.SocketChannel;"
                                      ],
                                      "methods": [],
                                      "classes": [
                                        {
                                          "original_string": "public class ChangeRequest {\n    public static final int REGISTER_CHANNEL = 1;\n    public static final int CHANGE_SOCKET_OP = 2;\n    public static final int CLOSE_CHANNEL = 3;\n\n    public SocketChannel socket;\n    public int type;\n    public int op;\n\n    public ChangeRequest(SocketChannel socket, int type, int op) {\n        this.socket = socket;\n        this.type = type;\n        this.op = op;\n    }\n\n    public ChangeRequest(SocketChannel socket, int type) {\n        this(socket, type, 0);\n    }\n}",
                                          "definition": "public class ChangeRequest",
                                          "byte_span": [
                                            1629,
                                            2129
                                          ],
                                          "start_point": [
                                            38,
                                            0
                                          ],
                                          "end_point": [
                                            56,
                                            1
                                          ],
                                          "class_docstring": "",
                                          "name": "ChangeRequest",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "fields": [
                                              {
                                                "attribute_expression": "    public static final int REGISTER_CHANNEL = 1;",
                                                "docstring": "",
                                                "modifiers": "public static final",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public",
                                                  "static",
                                                  "final"
                                                ],
                                                "comments": [],
                                                "type": "int",
                                                "name": "REGISTER_CHANNEL = 1",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    public static final int CHANGE_SOCKET_OP = 2;",
                                                "docstring": "",
                                                "modifiers": "public static final",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public",
                                                  "static",
                                                  "final"
                                                ],
                                                "comments": [],
                                                "type": "int",
                                                "name": "CHANGE_SOCKET_OP = 2",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    public static final int CLOSE_CHANNEL = 3;",
                                                "docstring": "",
                                                "modifiers": "public static final",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public",
                                                  "static",
                                                  "final"
                                                ],
                                                "comments": [],
                                                "type": "int",
                                                "name": "CLOSE_CHANNEL = 3",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    public SocketChannel socket;",
                                                "docstring": "",
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "type": "SocketChannel",
                                                "name": "socket",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    public int type;",
                                                "docstring": "",
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "type": "int",
                                                "name": "type",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    public int op;",
                                                "docstring": "",
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "type": "int",
                                                "name": "op",
                                                "syntax_pass": true
                                              }
                                            ],
                                            "classes": []
                                          },
                                          "syntax_pass": true,
                                          "methods": [
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                1884,
                                                2030
                                              ],
                                              "original_string": "    public ChangeRequest(SocketChannel socket, int type, int op) {\n        this.socket = socket;\n        this.type = type;\n        this.op = op;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "",
                                                "classes": []
                                              },
                                              "name": "ChangeRequest",
                                              "body": "                                                                 {\n        this.socket = socket;\n        this.type = type;\n        this.op = op;\n    }",
                                              "identifiers": "socket socket type type op op",
                                              "signature": "    public ChangeRequest(SocketChannel socket, int type, int op)",
                                              "signature_woname": "    public (SocketChannel socket, int type, int op)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2036,
                                                2127
                                              ],
                                              "original_string": "    public ChangeRequest(SocketChannel socket, int type) {\n        this(socket, type, 0);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "",
                                                "classes": []
                                              },
                                              "name": "ChangeRequest",
                                              "body": "                                                         {\n        this(socket, type, 0);\n    }",
                                              "identifiers": "socket type",
                                              "signature": "    public ChangeRequest(SocketChannel socket, int type)",
                                              "signature_woname": "    public (SocketChannel socket, int type)"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "imports": []
                                  },
                                  {
                                    "name": "PipeEvent.java",
                                    "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network.nio;\n\n/**\n * pipe event for pipe worker\n */\npublic class PipeEvent {\n    public byte[] data;\n    public boolean isEncrypted;\n\n    public PipeEvent() {}\n\n    public PipeEvent(byte[] data, boolean isEncrypted) {\n        this.data = data;\n        this.isEncrypted = isEncrypted;\n    }\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.nio;"
                                      ],
                                      "methods": [],
                                      "classes": [
                                        {
                                          "original_string": "public class PipeEvent {\n    public byte[] data;\n    public boolean isEncrypted;\n\n    public PipeEvent() {}\n\n    public PipeEvent(byte[] data, boolean isEncrypted) {\n        this.data = data;\n        this.isEncrypted = isEncrypted;\n    }\n}",
                                          "definition": "public class PipeEvent",
                                          "byte_span": [
                                            1584,
                                            1823
                                          ],
                                          "start_point": [
                                            36,
                                            0
                                          ],
                                          "end_point": [
                                            46,
                                            1
                                          ],
                                          "class_docstring": "",
                                          "name": "PipeEvent",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "fields": [
                                              {
                                                "attribute_expression": "    public byte[] data;",
                                                "docstring": "",
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "type": "byte[]",
                                                "name": "data",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    public boolean isEncrypted;",
                                                "docstring": "",
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "type": "boolean",
                                                "name": "isEncrypted",
                                                "syntax_pass": true
                                              }
                                            ],
                                            "classes": []
                                          },
                                          "syntax_pass": true,
                                          "methods": [
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                1670,
                                                1691
                                              ],
                                              "original_string": "    public PipeEvent() {}",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "",
                                                "classes": []
                                              },
                                              "name": "PipeEvent",
                                              "body": "                       {}",
                                              "identifiers": "",
                                              "signature": "    public PipeEvent()",
                                              "signature_woname": "    public ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                1697,
                                                1821
                                              ],
                                              "original_string": "    public PipeEvent(byte[] data, boolean isEncrypted) {\n        this.data = data;\n        this.isEncrypted = isEncrypted;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "",
                                                "classes": []
                                              },
                                              "name": "PipeEvent",
                                              "body": "                                                       {\n        this.data = data;\n        this.isEncrypted = isEncrypted;\n    }",
                                              "identifiers": "data data isEncrypted isEncrypted",
                                              "signature": "    public PipeEvent(byte[] data, boolean isEncrypted)",
                                              "signature_woname": "    public (byte[] data, boolean isEncrypted)"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "imports": []
                                  }
                                ],
                                "subdirs": []
                              },
                              {
                                "dir": "io",
                                "files": [
                                  {
                                    "name": "PipeSocket.java",
                                    "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network.io;\n\nimport com.stfl.misc.Config;\nimport com.stfl.misc.Util;\nimport com.stfl.Constant;\nimport com.stfl.network.proxy.IProxy;\nimport com.stfl.network.proxy.ProxyFactory;\nimport com.stfl.ss.CryptFactory;\nimport com.stfl.ss.ICrypt;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.net.SocketTimeoutException;\nimport java.util.List;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Logger;\n\n/**\n * Pipe local and remote sockets while server is running under blocking mode.\n */\npublic class PipeSocket implements Runnable {\n    private Logger logger = Logger.getLogger(PipeSocket.class.getName());\n\n    private final int TIMEOUT = 10000; // 10s\n    private ByteArrayOutputStream _remoteOutStream;\n    private ByteArrayOutputStream _localOutStream;\n    private Socket _remote;\n    private Socket _local;\n    private IProxy _proxy;\n    private ICrypt _crypt;\n    private boolean _isClosed;\n    private Executor _executor;\n    private Config _config;\n\n    public PipeSocket(Executor executor, Socket socket, Config config) throws IOException {\n        _executor = executor;\n        _local = socket;\n        _local.setSoTimeout(TIMEOUT);\n        _config = config;\n        _crypt = CryptFactory.get(_config.getMethod(), _config.getPassword());\n        _proxy = ProxyFactory.get(_config.getProxyType());\n        _remoteOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n        _localOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n    }\n\n    @Override\n    public void run() {\n        try {\n            _remote = initRemote(_config);\n            _remote.setSoTimeout(TIMEOUT);\n        } catch (IOException e) {\n            close();\n            logger.warning(Util.getErrorMessage(e));\n            return;\n        }\n\n        _executor.execute(getLocalWorker());\n        _executor.execute(getRemoteWorker());\n    }\n\n    private Socket initRemote(Config config) throws IOException {\n        return new Socket(config.getRemoteIpAddress(), config.getRemotePort());\n    }\n\n    private Runnable getLocalWorker() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                byte[] dataBuffer = new byte[Constant.BUFFER_SIZE];\n                byte[] buffer;\n                int readCount;\n                List<byte[]> sendData = null;\n\n                // prepare local stream\n                try {\n                    stream = new BufferedInputStream(_local.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from local socket\n                while (true) {\n                    try {\n                         // read data\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Local socket closed (Read)!\");\n                        }\n\n                        // initialize proxy\n                        if (!_proxy.isReady()) {\n                            byte[] temp;\n                            buffer = new byte[readCount];\n\n                            // dup dataBuffer to use in later\n                            System.arraycopy(dataBuffer, 0, buffer, 0, readCount);\n\n                            temp = _proxy.getResponse(buffer);\n                            if ((temp != null) && (!_sendLocal(temp, temp.length))) {\n                                throw new IOException(\"Local socket closed (proxy-Write)!\");\n                            }\n                            // packet for remote socket\n                            sendData = _proxy.getRemoteResponse(buffer);\n                            if (sendData == null) {\n                                continue;\n                            }\n                            logger.info(\"Connected to: \" + Util.getRequestedHostInfo(sendData.get(0)));\n                        }\n                        else {\n                            sendData.clear();\n                            sendData.add(dataBuffer);\n                        }\n\n                        for (byte[] bytes : sendData) {\n                            // send data to remote socket\n                            if (!sendRemote(bytes, bytes.length)) {\n                                throw new IOException(\"Remote socket closed (Write)!\");\n                            }\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n                }\n                close();\n                logger.fine(String.format(\"localWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }\n\n    private Runnable getRemoteWorker() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                int readCount;\n                byte[] dataBuffer = new byte[4096];\n\n                // prepare remote stream\n                try {\n                    //stream = _remote.getInputStream();\n                    stream = new BufferedInputStream (_remote.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from remote socket\n                while (true) {\n                    try {\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Remote socket closed (Read)!\");\n                        }\n\n                        // send data to local socket\n                        if (!sendLocal(dataBuffer, readCount)) {\n                            throw new IOException(\"Local socket closed (Write)!\");\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n\n                }\n                close();\n                logger.fine(String.format(\"remoteWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }\n\n    public void close() {\n        if (_isClosed) {\n            return;\n        }\n        _isClosed = true;\n\n        try {\n            _local.shutdownInput();\n            _local.shutdownOutput();\n            _local.close();\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close local socket (I/O exception)!\");\n        }\n        try {\n            if (_remote != null) {\n                _remote.shutdownInput();\n                _remote.shutdownOutput();\n                _remote.close();\n            }\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close remote socket (I/O exception)!\");\n        }\n    }\n\n    private boolean sendRemote(byte[] data, int length) {\n        _crypt.encrypt(data, length, _remoteOutStream);\n        byte[] sendData = _remoteOutStream.toByteArray();\n\n        return _sendRemote(sendData, sendData.length);\n    }\n\n    private boolean _sendRemote(byte[] data, int length) {\n        try {\n            if (length > 0) {\n                OutputStream outStream = _remote.getOutputStream();\n                outStream.write(data, 0, length);\n            }\n            else {\n                logger.info(\"Nothing to sendRemote!\\n\");\n            }\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n\n        return true;\n    }\n\n    private boolean sendLocal(byte[] data, int length) {\n        _crypt.decrypt(data, length, _localOutStream);\n        byte[] sendData = _localOutStream.toByteArray();\n\n        return _sendLocal(sendData, sendData.length);\n    }\n\n    private boolean _sendLocal(byte[] data, int length) {\n        try {\n            OutputStream outStream = _local.getOutputStream();\n            outStream.write(data, 0, length);\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n        return true;\n    }\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.io;",
                                        "import com.stfl.misc.Config;",
                                        "import com.stfl.misc.Util;",
                                        "import com.stfl.Constant;",
                                        "import com.stfl.network.proxy.IProxy;",
                                        "import com.stfl.network.proxy.ProxyFactory;",
                                        "import com.stfl.ss.CryptFactory;",
                                        "import com.stfl.ss.ICrypt;",
                                        "import java.io.*;",
                                        "import java.net.Socket;",
                                        "import java.net.SocketTimeoutException;",
                                        "import java.util.List;",
                                        "import java.util.concurrent.Executor;",
                                        "import java.util.logging.Logger;"
                                      ],
                                      "methods": [],
                                      "classes": [
                                        {
                                          "original_string": "public class PipeSocket implements Runnable {\n    private Logger logger = Logger.getLogger(PipeSocket.class.getName());\n\n    private final int TIMEOUT = 10000; // 10s\n    private ByteArrayOutputStream _remoteOutStream;\n    private ByteArrayOutputStream _localOutStream;\n    private Socket _remote;\n    private Socket _local;\n    private IProxy _proxy;\n    private ICrypt _crypt;\n    private boolean _isClosed;\n    private Executor _executor;\n    private Config _config;\n\n    public PipeSocket(Executor executor, Socket socket, Config config) throws IOException {\n        _executor = executor;\n        _local = socket;\n        _local.setSoTimeout(TIMEOUT);\n        _config = config;\n        _crypt = CryptFactory.get(_config.getMethod(), _config.getPassword());\n        _proxy = ProxyFactory.get(_config.getProxyType());\n        _remoteOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n        _localOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n    }\n\n    @Override\n    public void run() {\n        try {\n            _remote = initRemote(_config);\n            _remote.setSoTimeout(TIMEOUT);\n        } catch (IOException e) {\n            close();\n            logger.warning(Util.getErrorMessage(e));\n            return;\n        }\n\n        _executor.execute(getLocalWorker());\n        _executor.execute(getRemoteWorker());\n    }\n\n    private Socket initRemote(Config config) throws IOException {\n        return new Socket(config.getRemoteIpAddress(), config.getRemotePort());\n    }\n\n    private Runnable getLocalWorker() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                byte[] dataBuffer = new byte[Constant.BUFFER_SIZE];\n                byte[] buffer;\n                int readCount;\n                List<byte[]> sendData = null;\n\n                // prepare local stream\n                try {\n                    stream = new BufferedInputStream(_local.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from local socket\n                while (true) {\n                    try {\n                         // read data\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Local socket closed (Read)!\");\n                        }\n\n                        // initialize proxy\n                        if (!_proxy.isReady()) {\n                            byte[] temp;\n                            buffer = new byte[readCount];\n\n                            // dup dataBuffer to use in later\n                            System.arraycopy(dataBuffer, 0, buffer, 0, readCount);\n\n                            temp = _proxy.getResponse(buffer);\n                            if ((temp != null) && (!_sendLocal(temp, temp.length))) {\n                                throw new IOException(\"Local socket closed (proxy-Write)!\");\n                            }\n                            // packet for remote socket\n                            sendData = _proxy.getRemoteResponse(buffer);\n                            if (sendData == null) {\n                                continue;\n                            }\n                            logger.info(\"Connected to: \" + Util.getRequestedHostInfo(sendData.get(0)));\n                        }\n                        else {\n                            sendData.clear();\n                            sendData.add(dataBuffer);\n                        }\n\n                        for (byte[] bytes : sendData) {\n                            // send data to remote socket\n                            if (!sendRemote(bytes, bytes.length)) {\n                                throw new IOException(\"Remote socket closed (Write)!\");\n                            }\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n                }\n                close();\n                logger.fine(String.format(\"localWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }\n\n    private Runnable getRemoteWorker() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                int readCount;\n                byte[] dataBuffer = new byte[4096];\n\n                // prepare remote stream\n                try {\n                    //stream = _remote.getInputStream();\n                    stream = new BufferedInputStream (_remote.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from remote socket\n                while (true) {\n                    try {\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Remote socket closed (Read)!\");\n                        }\n\n                        // send data to local socket\n                        if (!sendLocal(dataBuffer, readCount)) {\n                            throw new IOException(\"Local socket closed (Write)!\");\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n\n                }\n                close();\n                logger.fine(String.format(\"remoteWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }\n\n    public void close() {\n        if (_isClosed) {\n            return;\n        }\n        _isClosed = true;\n\n        try {\n            _local.shutdownInput();\n            _local.shutdownOutput();\n            _local.close();\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close local socket (I/O exception)!\");\n        }\n        try {\n            if (_remote != null) {\n                _remote.shutdownInput();\n                _remote.shutdownOutput();\n                _remote.close();\n            }\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close remote socket (I/O exception)!\");\n        }\n    }\n\n    private boolean sendRemote(byte[] data, int length) {\n        _crypt.encrypt(data, length, _remoteOutStream);\n        byte[] sendData = _remoteOutStream.toByteArray();\n\n        return _sendRemote(sendData, sendData.length);\n    }\n\n    private boolean _sendRemote(byte[] data, int length) {\n        try {\n            if (length > 0) {\n                OutputStream outStream = _remote.getOutputStream();\n                outStream.write(data, 0, length);\n            }\n            else {\n                logger.info(\"Nothing to sendRemote!\\n\");\n            }\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n\n        return true;\n    }\n\n    private boolean sendLocal(byte[] data, int length) {\n        _crypt.decrypt(data, length, _localOutStream);\n        byte[] sendData = _localOutStream.toByteArray();\n\n        return _sendLocal(sendData, sendData.length);\n    }\n\n    private boolean _sendLocal(byte[] data, int length) {\n        try {\n            OutputStream outStream = _local.getOutputStream();\n            outStream.write(data, 0, length);\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n        return true;\n    }\n}",
                                          "definition": "public class PipeSocket implements Runnable",
                                          "byte_span": [
                                            2033,
                                            9941
                                          ],
                                          "start_point": [
                                            51,
                                            0
                                          ],
                                          "end_point": [
                                            273,
                                            1
                                          ],
                                          "class_docstring": "",
                                          "name": "PipeSocket",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "fields": [
                                              {
                                                "attribute_expression": "    private Logger logger = Logger.getLogger(PipeSocket.class.getName());",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Logger",
                                                "name": "logger = Logger.getLogger(PipeSocket.class.getName())",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private final int TIMEOUT = 10000;",
                                                "docstring": "",
                                                "modifiers": "private final",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private",
                                                  "final"
                                                ],
                                                "comments": [],
                                                "type": "int",
                                                "name": "TIMEOUT = 10000",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private ByteArrayOutputStream _remoteOutStream;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "ByteArrayOutputStream",
                                                "name": "_remoteOutStream",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private ByteArrayOutputStream _localOutStream;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "ByteArrayOutputStream",
                                                "name": "_localOutStream",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private Socket _remote;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Socket",
                                                "name": "_remote",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private Socket _local;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Socket",
                                                "name": "_local",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private IProxy _proxy;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "IProxy",
                                                "name": "_proxy",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private ICrypt _crypt;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "ICrypt",
                                                "name": "_crypt",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private boolean _isClosed;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "boolean",
                                                "name": "_isClosed",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private Executor _executor;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Executor",
                                                "name": "_executor",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private Config _config;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Config",
                                                "name": "_config",
                                                "syntax_pass": true
                                              }
                                            ],
                                            "classes": []
                                          },
                                          "syntax_pass": true,
                                          "methods": [
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2508,
                                                3009
                                              ],
                                              "original_string": "    public PipeSocket(Executor executor, Socket socket, Config config) throws IOException {\n        _executor = executor;\n        _local = socket;\n        _local.setSoTimeout(TIMEOUT);\n        _config = config;\n        _crypt = CryptFactory.get(_config.getMethod(), _config.getPassword());\n        _proxy = ProxyFactory.get(_config.getProxyType());\n        _remoteOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n        _localOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "",
                                                "classes": []
                                              },
                                              "name": "PipeSocket",
                                              "body": "                                                                                          {\n        _executor = executor;\n        _local = socket;\n        _local.setSoTimeout(TIMEOUT);\n        _config = config;\n        _crypt = CryptFactory.get(_config.getMethod(), _config.getPassword());\n        _proxy = ProxyFactory.get(_config.getProxyType());\n        _remoteOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n        _localOutStream = new ByteArrayOutputStream(Constant.BUFFER_SIZE);\n    }",
                                              "identifiers": "_executor executor _local socket _local setSoTimeout TIMEOUT _config config _crypt CryptFactory get _config getMethod _config getPassword _proxy ProxyFactory get _config getProxyType _remoteOutStream Constant BUFFER_SIZE _localOutStream Constant BUFFER_SIZE",
                                              "signature": "    public PipeSocket(Executor executor, Socket socket, Config config)",
                                              "signature_woname": "    public (Executor executor, Socket socket, Config config)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                3015,
                                                3384
                                              ],
                                              "original_string": "    @Override\n    public void run() {\n        try {\n            _remote = initRemote(_config);\n            _remote.setSoTimeout(TIMEOUT);\n        } catch (IOException e) {\n            close();\n            logger.warning(Util.getErrorMessage(e));\n            return;\n        }\n\n        _executor.execute(getLocalWorker());\n        _executor.execute(getRemoteWorker());\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "run",
                                              "body": "                      {\n        try {\n            _remote = initRemote(_config);\n            _remote.setSoTimeout(TIMEOUT);\n        } catch (IOException e) {\n            close();\n            logger.warning(Util.getErrorMessage(e));\n            return;\n        }\n\n        _executor.execute(getLocalWorker());\n        _executor.execute(getRemoteWorker());\n    }",
                                              "identifiers": "_remote initRemote _config _remote setSoTimeout TIMEOUT e close logger warning Util getErrorMessage e _executor execute getLocalWorker _executor execute getRemoteWorker",
                                              "signature": "    @Override\n    public void run()",
                                              "signature_woname": "    @Override\n    public void ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                3390,
                                                3537
                                              ],
                                              "original_string": "    private Socket initRemote(Config config) throws IOException {\n        return new Socket(config.getRemoteIpAddress(), config.getRemotePort());\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "Socket",
                                                "classes": []
                                              },
                                              "name": "initRemote",
                                              "body": "                                                                {\n        return new Socket(config.getRemoteIpAddress(), config.getRemotePort());\n    }",
                                              "identifiers": "config getRemoteIpAddress config getRemotePort",
                                              "signature": "    private Socket initRemote(Config config)",
                                              "signature_woname": "    private Socket (Config config)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                3543,
                                                6428
                                              ],
                                              "original_string": "    private Runnable getLocalWorker() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                byte[] dataBuffer = new byte[Constant.BUFFER_SIZE];\n                byte[] buffer;\n                int readCount;\n                List<byte[]> sendData = null;\n\n                // prepare local stream\n                try {\n                    stream = new BufferedInputStream(_local.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from local socket\n                while (true) {\n                    try {\n                         // read data\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Local socket closed (Read)!\");\n                        }\n\n                        // initialize proxy\n                        if (!_proxy.isReady()) {\n                            byte[] temp;\n                            buffer = new byte[readCount];\n\n                            // dup dataBuffer to use in later\n                            System.arraycopy(dataBuffer, 0, buffer, 0, readCount);\n\n                            temp = _proxy.getResponse(buffer);\n                            if ((temp != null) && (!_sendLocal(temp, temp.length))) {\n                                throw new IOException(\"Local socket closed (proxy-Write)!\");\n                            }\n                            // packet for remote socket\n                            sendData = _proxy.getRemoteResponse(buffer);\n                            if (sendData == null) {\n                                continue;\n                            }\n                            logger.info(\"Connected to: \" + Util.getRequestedHostInfo(sendData.get(0)));\n                        }\n                        else {\n                            sendData.clear();\n                            sendData.add(dataBuffer);\n                        }\n\n                        for (byte[] bytes : sendData) {\n                            // send data to remote socket\n                            if (!sendRemote(bytes, bytes.length)) {\n                                throw new IOException(\"Remote socket closed (Write)!\");\n                            }\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n                }\n                close();\n                logger.fine(String.format(\"localWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "Runnable",
                                                "classes": []
                                              },
                                              "name": "getLocalWorker",
                                              "body": "                                      {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                byte[] dataBuffer = new byte[Constant.BUFFER_SIZE];\n                byte[] buffer;\n                int readCount;\n                List<byte[]> sendData = null;\n\n                // prepare local stream\n                try {\n                    stream = new BufferedInputStream(_local.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from local socket\n                while (true) {\n                    try {\n                         // read data\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Local socket closed (Read)!\");\n                        }\n\n                        // initialize proxy\n                        if (!_proxy.isReady()) {\n                            byte[] temp;\n                            buffer = new byte[readCount];\n\n                            // dup dataBuffer to use in later\n                            System.arraycopy(dataBuffer, 0, buffer, 0, readCount);\n\n                            temp = _proxy.getResponse(buffer);\n                            if ((temp != null) && (!_sendLocal(temp, temp.length))) {\n                                throw new IOException(\"Local socket closed (proxy-Write)!\");\n                            }\n                            // packet for remote socket\n                            sendData = _proxy.getRemoteResponse(buffer);\n                            if (sendData == null) {\n                                continue;\n                            }\n                            logger.info(\"Connected to: \" + Util.getRequestedHostInfo(sendData.get(0)));\n                        }\n                        else {\n                            sendData.clear();\n                            sendData.add(dataBuffer);\n                        }\n\n                        for (byte[] bytes : sendData) {\n                            // send data to remote socket\n                            if (!sendRemote(bytes, bytes.length)) {\n                                throw new IOException(\"Remote socket closed (Write)!\");\n                            }\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n                }\n                close();\n                logger.fine(String.format(\"localWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }",
                                              "identifiers": "Override run stream dataBuffer Constant BUFFER_SIZE buffer readCount sendData stream _local getInputStream e logger info e toString readCount stream read dataBuffer readCount _proxy isReady temp buffer readCount System arraycopy dataBuffer buffer readCount temp _proxy getResponse buffer temp _sendLocal temp temp length sendData _proxy getRemoteResponse buffer sendData logger info Util getRequestedHostInfo sendData get sendData clear sendData add dataBuffer bytes sendData sendRemote bytes bytes length e e logger fine e toString close logger fine String format _local _remote",
                                              "signature": "    private Runnable getLocalWorker()",
                                              "signature_woname": "    private Runnable ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                6434,
                                                8002
                                              ],
                                              "original_string": "    private Runnable getRemoteWorker() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                int readCount;\n                byte[] dataBuffer = new byte[4096];\n\n                // prepare remote stream\n                try {\n                    //stream = _remote.getInputStream();\n                    stream = new BufferedInputStream (_remote.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from remote socket\n                while (true) {\n                    try {\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Remote socket closed (Read)!\");\n                        }\n\n                        // send data to local socket\n                        if (!sendLocal(dataBuffer, readCount)) {\n                            throw new IOException(\"Local socket closed (Write)!\");\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n\n                }\n                close();\n                logger.fine(String.format(\"remoteWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "Runnable",
                                                "classes": []
                                              },
                                              "name": "getRemoteWorker",
                                              "body": "                                       {\n        return new Runnable() {\n            @Override\n            public void run() {\n                BufferedInputStream stream;\n                int readCount;\n                byte[] dataBuffer = new byte[4096];\n\n                // prepare remote stream\n                try {\n                    //stream = _remote.getInputStream();\n                    stream = new BufferedInputStream (_remote.getInputStream());\n                } catch (IOException e) {\n                    logger.info(e.toString());\n                    return;\n                }\n\n                // start to process data from remote socket\n                while (true) {\n                    try {\n                        readCount = stream.read(dataBuffer);\n                        if (readCount == -1) {\n                            throw new IOException(\"Remote socket closed (Read)!\");\n                        }\n\n                        // send data to local socket\n                        if (!sendLocal(dataBuffer, readCount)) {\n                            throw new IOException(\"Local socket closed (Write)!\");\n                        }\n                    } catch (SocketTimeoutException e) {\n                        continue;\n                    } catch (IOException e) {\n                        logger.fine(e.toString());\n                        break;\n                    }\n\n                }\n                close();\n                logger.fine(String.format(\"remoteWorker exit, Local=%s, Remote=%s\", _local, _remote));\n            }\n        };\n    }",
                                              "identifiers": "Override run stream readCount dataBuffer stream _remote getInputStream e logger info e toString readCount stream read dataBuffer readCount sendLocal dataBuffer readCount e e logger fine e toString close logger fine String format _local _remote",
                                              "signature": "    private Runnable getRemoteWorker()",
                                              "signature_woname": "    private Runnable ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                8008,
                                                8670
                                              ],
                                              "original_string": "    public void close() {\n        if (_isClosed) {\n            return;\n        }\n        _isClosed = true;\n\n        try {\n            _local.shutdownInput();\n            _local.shutdownOutput();\n            _local.close();\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close local socket (I/O exception)!\");\n        }\n        try {\n            if (_remote != null) {\n                _remote.shutdownInput();\n                _remote.shutdownOutput();\n                _remote.close();\n            }\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close remote socket (I/O exception)!\");\n        }\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "close",
                                              "body": "                        {\n        if (_isClosed) {\n            return;\n        }\n        _isClosed = true;\n\n        try {\n            _local.shutdownInput();\n            _local.shutdownOutput();\n            _local.close();\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close local socket (I/O exception)!\");\n        }\n        try {\n            if (_remote != null) {\n                _remote.shutdownInput();\n                _remote.shutdownOutput();\n                _remote.close();\n            }\n        } catch (IOException e) {\n            logger.fine(\"PipeSocket failed to close remote socket (I/O exception)!\");\n        }\n    }",
                                              "identifiers": "_isClosed _isClosed _local shutdownInput _local shutdownOutput _local close e logger fine _remote _remote shutdownInput _remote shutdownOutput _remote close e logger fine",
                                              "signature": "    public void close()",
                                              "signature_woname": "    public void ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                8676,
                                                8905
                                              ],
                                              "original_string": "    private boolean sendRemote(byte[] data, int length) {\n        _crypt.encrypt(data, length, _remoteOutStream);\n        byte[] sendData = _remoteOutStream.toByteArray();\n\n        return _sendRemote(sendData, sendData.length);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "sendRemote",
                                              "body": "                                                        {\n        _crypt.encrypt(data, length, _remoteOutStream);\n        byte[] sendData = _remoteOutStream.toByteArray();\n\n        return _sendRemote(sendData, sendData.length);\n    }",
                                              "identifiers": "_crypt encrypt data length _remoteOutStream sendData _remoteOutStream toByteArray _sendRemote sendData sendData length",
                                              "signature": "    private boolean sendRemote(byte[] data, int length)",
                                              "signature_woname": "    private boolean (byte[] data, int length)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                8911,
                                                9379
                                              ],
                                              "original_string": "    private boolean _sendRemote(byte[] data, int length) {\n        try {\n            if (length > 0) {\n                OutputStream outStream = _remote.getOutputStream();\n                outStream.write(data, 0, length);\n            }\n            else {\n                logger.info(\"Nothing to sendRemote!\\n\");\n            }\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n\n        return true;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "_sendRemote",
                                              "body": "                                                         {\n        try {\n            if (length > 0) {\n                OutputStream outStream = _remote.getOutputStream();\n                outStream.write(data, 0, length);\n            }\n            else {\n                logger.info(\"Nothing to sendRemote!\\n\");\n            }\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n\n        return true;\n    }",
                                              "identifiers": "length outStream _remote getOutputStream outStream write data length logger info e logger info Util getErrorMessage e",
                                              "signature": "    private boolean _sendRemote(byte[] data, int length)",
                                              "signature_woname": "    private boolean (byte[] data, int length)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                9385,
                                                9610
                                              ],
                                              "original_string": "    private boolean sendLocal(byte[] data, int length) {\n        _crypt.decrypt(data, length, _localOutStream);\n        byte[] sendData = _localOutStream.toByteArray();\n\n        return _sendLocal(sendData, sendData.length);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "sendLocal",
                                              "body": "                                                       {\n        _crypt.decrypt(data, length, _localOutStream);\n        byte[] sendData = _localOutStream.toByteArray();\n\n        return _sendLocal(sendData, sendData.length);\n    }",
                                              "identifiers": "_crypt decrypt data length _localOutStream sendData _localOutStream toByteArray _sendLocal sendData sendData length",
                                              "signature": "    private boolean sendLocal(byte[] data, int length)",
                                              "signature_woname": "    private boolean (byte[] data, int length)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                9616,
                                                9939
                                              ],
                                              "original_string": "    private boolean _sendLocal(byte[] data, int length) {\n        try {\n            OutputStream outStream = _local.getOutputStream();\n            outStream.write(data, 0, length);\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n        return true;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "_sendLocal",
                                              "body": "                                                        {\n        try {\n            OutputStream outStream = _local.getOutputStream();\n            outStream.write(data, 0, length);\n        } catch (IOException e) {\n            logger.info(Util.getErrorMessage(e));\n            return false;\n        }\n        return true;\n    }",
                                              "identifiers": "outStream _local getOutputStream outStream write data length e logger info Util getErrorMessage e",
                                              "signature": "    private boolean _sendLocal(byte[] data, int length)",
                                              "signature_woname": "    private boolean (byte[] data, int length)"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "imports": [
                                      {
                                        "original_string": "public class Config {\n    private String _ipAddr;\n    private int _port;\n    private String _localIpAddr;\n    private int _localPort;\n    private String _method;\n    private String _password;\n    private String _logLevel;\n    private IProxy.TYPE _proxyType;\n\n    public Config() {\n        loadFromJson(\"\");\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }\n\n    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }\n\n    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }\n\n    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }\n\n    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }\n\n    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }\n\n    public void setRemotePort(int value) {\n        _port = value;\n    }\n\n    public int getRemotePort() {\n        return _port;\n    }\n\n    public void setLocalPort(int value) {\n        _localPort = value;\n    }\n\n    public int getLocalPort() {\n        return _localPort;\n    }\n\n    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }\n\n    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }\n    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }\n\n    public void setMethod(String value) {\n        _method = value;\n    }\n\n    public String getMethod() {\n        return _method;\n    }\n\n    public void setPassword(String value) {\n        _password = value;\n    }\n\n    public String getPassword() {\n        return _password;\n    }\n\n    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }\n\n    public String getLogLevel() {\n        return _logLevel;\n    }\n\n    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }\n\n    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }\n}",
                                        "definition": "public class Config",
                                        "byte_span": [
                                          1735,
                                          5565
                                        ],
                                        "start_point": [
                                          41,
                                          0
                                        ],
                                        "end_point": [
                                          175,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Config",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    private String _ipAddr;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_ipAddr",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private int _port;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "_port",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _localIpAddr;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_localIpAddr",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private int _localPort;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "_localPort",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _method;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_method",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _password;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_password",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private String _logLevel;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "_logLevel",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private IProxy.TYPE _proxyType;",
                                              "docstring": "",
                                              "modifiers": "private",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private"
                                              ],
                                              "comments": [],
                                              "type": "IProxy.TYPE",
                                              "name": "_proxyType",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              1998,
                                              2047
                                            ],
                                            "original_string": "    public Config() {\n        loadFromJson(\"\");\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                    {\n        loadFromJson(\"\");\n    }",
                                            "identifiers": "loadFromJson",
                                            "signature": "    public Config()",
                                            "signature_woname": "    public ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2053,
                                              2393
                                            ],
                                            "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password) {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                                                                                                              {\n        this();\n        _ipAddr = ipAddr;\n        _port = port;\n        _localIpAddr = localIpAddr;\n        _localPort = localPort;\n        _method = method;\n        _password = password;\n        _proxyType = IProxy.TYPE.AUTO;\n    }",
                                            "identifiers": "_ipAddr ipAddr _port port _localIpAddr localIpAddr _localPort localPort _method method _password password _proxyType IProxy TYPE AUTO",
                                            "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password)",
                                            "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2399,
                                              2627
                                            ],
                                            "original_string": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type) {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "",
                                              "classes": []
                                            },
                                            "name": "Config",
                                            "body": "                                                                                                                                {\n        this(ipAddr, port, localIpAddr, localPort, method, password);\n        _proxyType = type;\n    }",
                                            "identifiers": "ipAddr port localIpAddr localPort method password _proxyType type",
                                            "signature": "    public Config(String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)",
                                            "signature_woname": "    public (String ipAddr, int port, String localIpAddr, int localPort, String method, String password, IProxy.TYPE type)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2633,
                                              2710
                                            ],
                                            "original_string": "    public void setRemoteIpAddress(String value) {\n        _ipAddr = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setRemoteIpAddress",
                                            "body": "                                                 {\n        _ipAddr = value;\n    }",
                                            "identifiers": "_ipAddr value",
                                            "signature": "    public void setRemoteIpAddress(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2716,
                                              2782
                                            ],
                                            "original_string": "    public String getRemoteIpAddress() {\n        return _ipAddr;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getRemoteIpAddress",
                                            "body": "                                       {\n        return _ipAddr;\n    }",
                                            "identifiers": "_ipAddr",
                                            "signature": "    public String getRemoteIpAddress()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2788,
                                              2869
                                            ],
                                            "original_string": "    public void setLocalIpAddress(String value) {\n        _localIpAddr = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLocalIpAddress",
                                            "body": "                                                {\n        _localIpAddr = value;\n    }",
                                            "identifiers": "_localIpAddr value",
                                            "signature": "    public void setLocalIpAddress(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2875,
                                              2945
                                            ],
                                            "original_string": "    public String getLocalIpAddress() {\n        return _localIpAddr;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getLocalIpAddress",
                                            "body": "                                      {\n        return _localIpAddr;\n    }",
                                            "identifiers": "_localIpAddr",
                                            "signature": "    public String getLocalIpAddress()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2951,
                                              3018
                                            ],
                                            "original_string": "    public void setRemotePort(int value) {\n        _port = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setRemotePort",
                                            "body": "                                         {\n        _port = value;\n    }",
                                            "identifiers": "_port value",
                                            "signature": "    public void setRemotePort(int value)",
                                            "signature_woname": "    public void (int value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3024,
                                              3080
                                            ],
                                            "original_string": "    public int getRemotePort() {\n        return _port;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getRemotePort",
                                            "body": "                               {\n        return _port;\n    }",
                                            "identifiers": "_port",
                                            "signature": "    public int getRemotePort()",
                                            "signature_woname": "    public int ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3086,
                                              3157
                                            ],
                                            "original_string": "    public void setLocalPort(int value) {\n        _localPort = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLocalPort",
                                            "body": "                                        {\n        _localPort = value;\n    }",
                                            "identifiers": "_localPort value",
                                            "signature": "    public void setLocalPort(int value)",
                                            "signature_woname": "    public void (int value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3163,
                                              3223
                                            ],
                                            "original_string": "    public int getLocalPort() {\n        return _localPort;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getLocalPort",
                                            "body": "                              {\n        return _localPort;\n    }",
                                            "identifiers": "_localPort",
                                            "signature": "    public int getLocalPort()",
                                            "signature_woname": "    public int ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3229,
                                              3599
                                            ],
                                            "original_string": "    public void setProxyType(String value) {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setProxyType",
                                            "body": "                                           {\n        _proxyType = IProxy.TYPE.AUTO;\n        if (value.toLowerCase().equals(IProxy.TYPE.HTTP.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.HTTP;\n        }\n        else if (value.toLowerCase().equals(IProxy.TYPE.SOCKS5.toString().toLowerCase())) {\n            _proxyType = IProxy.TYPE.SOCKS5;\n        }\n    }",
                                            "identifiers": "_proxyType IProxy TYPE AUTO value toLowerCase equals IProxy TYPE HTTP toString toLowerCase _proxyType IProxy TYPE HTTP value toLowerCase equals IProxy TYPE SOCKS5 toString toLowerCase _proxyType IProxy TYPE SOCKS5",
                                            "signature": "    public void setProxyType(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3605,
                                              3684
                                            ],
                                            "original_string": "    public void setProxyType(IProxy.TYPE value) {\n        _proxyType = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setProxyType",
                                            "body": "                                                {\n        _proxyType = value;\n    }",
                                            "identifiers": "_proxyType value",
                                            "signature": "    public void setProxyType(IProxy.TYPE value)",
                                            "signature_woname": "    public void (IProxy.TYPE value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3689,
                                              3757
                                            ],
                                            "original_string": "    public IProxy.TYPE getProxyType() {\n        return _proxyType;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "IProxy.TYPE",
                                              "classes": []
                                            },
                                            "name": "getProxyType",
                                            "body": "                                      {\n        return _proxyType;\n    }",
                                            "identifiers": "_proxyType",
                                            "signature": "    public IProxy.TYPE getProxyType()",
                                            "signature_woname": "    public IProxy.TYPE ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3763,
                                              3831
                                            ],
                                            "original_string": "    public void setMethod(String value) {\n        _method = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setMethod",
                                            "body": "                                        {\n        _method = value;\n    }",
                                            "identifiers": "_method value",
                                            "signature": "    public void setMethod(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3837,
                                              3894
                                            ],
                                            "original_string": "    public String getMethod() {\n        return _method;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getMethod",
                                            "body": "                              {\n        return _method;\n    }",
                                            "identifiers": "_method",
                                            "signature": "    public String getMethod()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3900,
                                              3972
                                            ],
                                            "original_string": "    public void setPassword(String value) {\n        _password = value;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setPassword",
                                            "body": "                                          {\n        _password = value;\n    }",
                                            "identifiers": "_password value",
                                            "signature": "    public void setPassword(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              3978,
                                              4039
                                            ],
                                            "original_string": "    public String getPassword() {\n        return _password;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getPassword",
                                            "body": "                                {\n        return _password;\n    }",
                                            "identifiers": "_password",
                                            "signature": "    public String getPassword()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4045,
                                              4150
                                            ],
                                            "original_string": "    public void setLogLevel(String value) {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "setLogLevel",
                                            "body": "                                          {\n        _logLevel = value;\n        Log.init(getLogLevel());\n    }",
                                            "identifiers": "_logLevel value Log init getLogLevel",
                                            "signature": "    public void setLogLevel(String value)",
                                            "signature_woname": "    public void (String value)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4156,
                                              4217
                                            ],
                                            "original_string": "    public String getLogLevel() {\n        return _logLevel;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getLogLevel",
                                            "body": "                                {\n        return _logLevel;\n    }",
                                            "identifiers": "_logLevel",
                                            "signature": "    public String getLogLevel()",
                                            "signature_woname": "    public String ()"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4223,
                                              5070
                                            ],
                                            "original_string": "    public void loadFromJson(String jsonStr) {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "void",
                                              "classes": []
                                            },
                                            "name": "loadFromJson",
                                            "body": "                                             {\n        if (jsonStr.length() == 0) {\n            jsonStr = \"{}\";\n        }\n\n        JSONObject jObj = (JSONObject)JSONValue.parse(jsonStr);\n        _ipAddr = (String)jObj.getOrDefault(\"remoteIpAddress\", \"\");\n        _port = ((Number)jObj.getOrDefault(\"remotePort\", 1080)).intValue();\n        _localIpAddr = (String)jObj.getOrDefault(\"localIpAddress\", \"127.0.0.1\");\n        _localPort = ((Number)jObj.getOrDefault(\"localPort\", 1080)).intValue();\n        _method = (String)jObj.getOrDefault(\"method\", AesCrypt.CIPHER_AES_256_CFB);\n        _password = (String)jObj.getOrDefault(\"password\", \"\");\n        _logLevel = (String)jObj.getOrDefault(\"logLevel\", \"INFO\");\n        setProxyType((String) jObj.getOrDefault(\"proxyType\", IProxy.TYPE.SOCKS5.toString().toLowerCase()));\n        setLogLevel(_logLevel);\n    }",
                                            "identifiers": "jsonStr length jsonStr jObj JSONValue parse jsonStr _ipAddr jObj getOrDefault _port jObj getOrDefault intValue _localIpAddr jObj getOrDefault _localPort jObj getOrDefault intValue _method jObj getOrDefault AesCrypt CIPHER_AES_256_CFB _password jObj getOrDefault _logLevel jObj getOrDefault setProxyType jObj getOrDefault IProxy TYPE SOCKS5 toString toLowerCase setLogLevel _logLevel",
                                            "signature": "    public void loadFromJson(String jsonStr)",
                                            "signature_woname": "    public void (String jsonStr)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              5076,
                                              5563
                                            ],
                                            "original_string": "    public String saveToJson() {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "saveToJson",
                                            "body": "                               {\n        JSONObject jObj = new JSONObject();\n        jObj.put(\"remoteIpAddress\", _ipAddr);\n        jObj.put(\"remotePort\", _port);\n        jObj.put(\"localIpAddress\", _localIpAddr);\n        jObj.put(\"localPort\", _localPort);\n        jObj.put(\"method\", _method);\n        jObj.put(\"password\", _password);\n        jObj.put(\"proxyType\", _proxyType.toString().toLowerCase());\n        jObj.put(\"logLevel\", _logLevel);\n\n        return Util.prettyPrintJson(jObj);\n    }",
                                            "identifiers": "jObj jObj put _ipAddr jObj put _port jObj put _localIpAddr jObj put _localPort jObj put _method jObj put _password jObj put _proxyType toString toLowerCase jObj put _logLevel Util prettyPrintJson jObj",
                                            "signature": "    public String saveToJson()",
                                            "signature_woname": "    public String ()"
                                          }
                                        ]
                                      },
                                      {
                                        "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                        "definition": "public class Util",
                                        "byte_span": [
                                          1779,
                                          7484
                                        ],
                                        "start_point": [
                                          45,
                                          0
                                        ],
                                        "end_point": [
                                          219,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Util",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              1803,
                                              2018
                                            ],
                                            "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "dumpBytes",
                                            "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                            "identifiers": "sb a length b a sb append String format b sb toString",
                                            "signature": "    public static String dumpBytes(byte[] a)",
                                            "signature_woname": "    public static String (byte[] a)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2024,
                                              2180
                                            ],
                                            "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "byte[]",
                                              "classes": []
                                            },
                                            "name": "randomBytes",
                                            "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                            "identifiers": "bytes size nextBytes bytes bytes",
                                            "signature": "    public static byte[] randomBytes(int size)",
                                            "signature_woname": "    public static byte[] (int size)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2186,
                                              2412
                                            ],
                                            "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getErrorMessage",
                                            "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                            "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                            "signature": "    public static String getErrorMessage(Throwable e)",
                                            "signature_woname": "    public static String (Throwable e)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2418,
                                              4165
                                            ],
                                            "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "prettyPrintJson",
                                            "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                            "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                            "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                            "signature_woname": "    public static String (JSONObject jObj)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4171,
                                              5829
                                            ],
                                            "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getRequestedHostInfo",
                                            "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                            "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                            "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                            "signature_woname": "    public static String (byte[] data)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              5835,
                                              6128
                                            ],
                                            "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "bytesToString",
                                            "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                            "identifiers": "str str data start length e e printStackTrace str",
                                            "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                            "signature_woname": "    public static String (byte[] data, int start, int length)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6134,
                                              6648
                                            ],
                                            "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "byte[]",
                                              "classes": []
                                            },
                                            "name": "composeSSHeader",
                                            "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                            "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                            "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                            "signature_woname": "    public static byte[] (String host, int port)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6654,
                                              6969
                                            ],
                                            "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "boolean",
                                              "classes": []
                                            },
                                            "name": "saveFile",
                                            "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                            "identifiers": "writer writer fn writer println content writer close e",
                                            "signature": "    public static boolean saveFile(String fn, String content)",
                                            "signature_woname": "    public static boolean (String fn, String content)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6975,
                                              7262
                                            ],
                                            "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getFileContent",
                                            "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                            "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                            "signature": "    public static String getFileContent(String fn)",
                                            "signature_woname": "    public static String (String fn)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              7268,
                                              7357
                                            ],
                                            "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "short",
                                              "classes": []
                                            },
                                            "name": "byteToUnsignedByte",
                                            "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                            "identifiers": "b",
                                            "signature": "    private static short byteToUnsignedByte(byte b)",
                                            "signature_woname": "    private static short (byte b)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              7363,
                                              7482
                                            ],
                                            "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getPort",
                                            "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                            "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                            "signature": "    private static int getPort(byte b, byte b1)",
                                            "signature_woname": "    private static int (byte b, byte b1)"
                                          }
                                        ]
                                      },
                                      {
                                        "original_string": "public class Constant {\n    public static final String PROG_NAME = \"shadowsocks-java\";\n    public static final String VERSION = \"0.2\";\n    public static final int BUFFER_SIZE = 16384;\n    public static final String CONF_FILE = \"config.json\";\n    public static final Locale LOCALE = Locale.getDefault();\n}",
                                        "definition": "public class Constant",
                                        "byte_span": [
                                          45,
                                          349
                                        ],
                                        "start_point": [
                                          4,
                                          0
                                        ],
                                        "end_point": [
                                          10,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Constant",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    public static final String PROG_NAME = \"shadowsocks-java\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "PROG_NAME = \"shadowsocks-java\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final String VERSION = \"0.2\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "VERSION = \"0.2\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final int BUFFER_SIZE = 16384;",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "BUFFER_SIZE = 16384",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final String CONF_FILE = \"config.json\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "CONF_FILE = \"config.json\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final Locale LOCALE = Locale.getDefault();",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "Locale",
                                              "name": "LOCALE = Locale.getDefault()",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": []
                                      },
                                      {
                                        "original_string": "public class ProxyFactory {\n    public static final Map<IProxy.TYPE, String> proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }};\n    private static Logger logger = Logger.getLogger(ProxyFactory.class.getName());\n\n    public static boolean isProxyTypeExisted(String name) {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }\n\n    public static IProxy get(IProxy.TYPE type) {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<IProxy.TYPE> getSupportedProxyTypes() {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                        "definition": "public class ProxyFactory",
                                        "byte_span": [
                                          1660,
                                          2707
                                        ],
                                        "start_point": [
                                          40,
                                          0
                                        ],
                                        "end_point": [
                                          70,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "ProxyFactory",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    public static final Map<IProxy.TYPE, String> proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }};",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "Map<IProxy.TYPE, String>",
                                              "name": "proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }}",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private static Logger logger = Logger.getLogger(ProxyFactory.class.getName());",
                                              "docstring": "",
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "type": "Logger",
                                              "name": "logger = Logger.getLogger(ProxyFactory.class.getName())",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2059,
                                              2218
                                            ],
                                            "original_string": "    public static boolean isProxyTypeExisted(String name) {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "boolean",
                                              "classes": []
                                            },
                                            "name": "isProxyTypeExisted",
                                            "body": "                                                          {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }",
                                            "identifiers": "type IProxy TYPE valueOf name proxies get type",
                                            "signature": "    public static boolean isProxyTypeExisted(String name)",
                                            "signature_woname": "    public static boolean (String name)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2224,
                                              2509
                                            ],
                                            "original_string": "    public static IProxy get(IProxy.TYPE type) {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "IProxy",
                                              "classes": []
                                            },
                                            "name": "get",
                                            "body": "                                               {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                            "identifiers": "obj Reflection get proxies get type obj e logger info com stfl misc Util getErrorMessage e",
                                            "signature": "    public static IProxy get(IProxy.TYPE type)",
                                            "signature_woname": "    public static IProxy (IProxy.TYPE type)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2515,
                                              2705
                                            ],
                                            "original_string": "    public static List<IProxy.TYPE> getSupportedProxyTypes() {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "List<IProxy.TYPE>",
                                              "classes": []
                                            },
                                            "name": "getSupportedProxyTypes",
                                            "body": "                                                             {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                            "identifiers": "sortedKeys proxies keySet Collections sort sortedKeys sortedKeys",
                                            "signature": "    public static List<IProxy.TYPE> getSupportedProxyTypes()",
                                            "signature_woname": "    public static List<IProxy.TYPE> ()"
                                          }
                                        ]
                                      },
                                      {
                                        "original_string": "public class CryptFactory {\n    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};\n    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());\n\n    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }\n\n    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                        "definition": "public class CryptFactory",
                                        "byte_span": [
                                          1649,
                                          2693
                                        ],
                                        "start_point": [
                                          40,
                                          0
                                        ],
                                        "end_point": [
                                          71,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "CryptFactory",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    private static final Map<String, String> crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }};",
                                              "docstring": "",
                                              "modifiers": "private static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "Map<String, String>",
                                              "name": "crypts = new HashMap<String, String>() {{\n        putAll(AesCrypt.getCiphers());\n        putAll(CamelliaCrypt.getCiphers());\n        putAll(BlowFishCrypt.getCiphers());\n        putAll(SeedCrypt.getCiphers());\n        // TODO: other crypts\n    }}",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    private static Logger logger = Logger.getLogger(CryptFactory.class.getName());",
                                              "docstring": "",
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "type": "Logger",
                                              "name": "logger = Logger.getLogger(CryptFactory.class.getName())",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2057,
                                              2158
                                            ],
                                            "original_string": "    public static boolean isCipherExisted(String name) {\n        return (crypts.get(name) != null);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "boolean",
                                              "classes": []
                                            },
                                            "name": "isCipherExisted",
                                            "body": "                                                       {\n        return (crypts.get(name) != null);\n    }",
                                            "identifiers": "crypts get name",
                                            "signature": "    public static boolean isCipherExisted(String name)",
                                            "signature_woname": "    public static boolean (String name)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2164,
                                              2504
                                            ],
                                            "original_string": "    public static ICrypt get(String name, String password) {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "ICrypt",
                                              "classes": []
                                            },
                                            "name": "get",
                                            "body": "                                                           {\n        try {\n            Object obj = Reflection.get(crypts.get(name), String.class, name, String.class, password);\n            return (ICrypt)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                            "identifiers": "obj Reflection get crypts get name name password obj e logger info com stfl misc Util getErrorMessage e",
                                            "signature": "    public static ICrypt get(String name, String password)",
                                            "signature_woname": "    public static ICrypt (String name, String password)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2510,
                                              2691
                                            ],
                                            "original_string": "    public static List<String> getSupportedCiphers() {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "List<String>",
                                              "classes": []
                                            },
                                            "name": "getSupportedCiphers",
                                            "body": "                                                     {\n        List sortedKeys = new ArrayList<>(crypts.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                            "identifiers": "sortedKeys crypts keySet Collections sort sortedKeys sortedKeys",
                                            "signature": "    public static List<String> getSupportedCiphers()",
                                            "signature_woname": "    public static List<String> ()"
                                          }
                                        ]
                                      }
                                    ]
                                  }
                                ],
                                "subdirs": []
                              },
                              {
                                "dir": "proxy",
                                "files": [
                                  {
                                    "name": "Socks5Proxy.java",
                                    "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network.proxy;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\n\n/**\n * Provide local socks5 statue and required response\n */\npublic class Socks5Proxy implements IProxy {\n    public final static int ATYP_IP_V4 = 0x1;\n    public final static int ATYP_DOMAIN_NAME = 0x3;\n    public final static int ATYP_IP_V6 = 0x4;\n\n    private Logger logger = Logger.getLogger(Socks5Proxy.class.getName());\n    private enum STAGE {SOCK5_HELLO, SOCKS_ACK, SOCKS_READY}\n    private STAGE _stage;\n\n    public Socks5Proxy() {\n        _stage = STAGE.SOCK5_HELLO;\n    }\n\n    public TYPE getType() {\n        return TYPE.SOCKS5;\n    }\n\n    public boolean isReady() {\n        return (_stage == STAGE.SOCKS_READY);\n    }\n\n    public byte[] getResponse(byte[] data) {\n        byte[] respData = null;\n\n        switch (_stage) {\n            case SOCK5_HELLO:\n                if (isMine(data)) {\n                    respData = new byte[] {5, 0};\n                }\n                else {\n                    respData = new byte[] {0, 91};\n                }\n                _stage = STAGE.SOCKS_ACK;\n                break;\n            case SOCKS_ACK:\n                respData = new byte[] {5, 0, 0, 1, 0, 0, 0, 0, 0, 0};\n                _stage = STAGE.SOCKS_READY;\n                break;\n            default:\n                // TODO: exception\n                break;\n\n        }\n\n        return respData;\n    }\n\n    public List<byte[]> getRemoteResponse(byte[] data) {\n        List<byte[]> respData = null;\n        int dataLength = data.length;\n\n        /*\n        There are two stage of establish Sock5:\n            1. HELLO (3 bytes)\n            2. ACK (3 bytes + dst info)\n        as Client sending ACK, it might contain dst info.\n        In this case, server needs to send back ACK response to client and start the remote socket right away,\n        otherwise, client will wait until timeout.\n         */\n        if (_stage == STAGE.SOCKS_READY) {\n            respData = new ArrayList<>(1);\n            // remove socks5 header (partial)\n            if (dataLength > 3) {\n                dataLength -= 3;\n                byte[] temp = new byte[dataLength];\n                System.arraycopy(data, 3, temp, 0, dataLength);\n                respData.add(temp);\n            }\n        }\n\n        return respData;\n    }\n\n    @Override\n    public boolean isMine(byte[] data) {\n        if (data[0] == 0x5) {\n            return true;\n        }\n\n        return false;\n    }\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.proxy;",
                                        "import java.util.ArrayList;",
                                        "import java.util.List;",
                                        "import java.util.logging.Logger;"
                                      ],
                                      "methods": [],
                                      "classes": [
                                        {
                                          "original_string": "public class Socks5Proxy implements IProxy {\n    public final static int ATYP_IP_V4 = 0x1;\n    public final static int ATYP_DOMAIN_NAME = 0x3;\n    public final static int ATYP_IP_V6 = 0x4;\n\n    private Logger logger = Logger.getLogger(Socks5Proxy.class.getName());\n    private enum STAGE {SOCK5_HELLO, SOCKS_ACK, SOCKS_READY}\n    private STAGE _stage;\n\n    public Socks5Proxy() {\n        _stage = STAGE.SOCK5_HELLO;\n    }\n\n    public TYPE getType() {\n        return TYPE.SOCKS5;\n    }\n\n    public boolean isReady() {\n        return (_stage == STAGE.SOCKS_READY);\n    }\n\n    public byte[] getResponse(byte[] data) {\n        byte[] respData = null;\n\n        switch (_stage) {\n            case SOCK5_HELLO:\n                if (isMine(data)) {\n                    respData = new byte[] {5, 0};\n                }\n                else {\n                    respData = new byte[] {0, 91};\n                }\n                _stage = STAGE.SOCKS_ACK;\n                break;\n            case SOCKS_ACK:\n                respData = new byte[] {5, 0, 0, 1, 0, 0, 0, 0, 0, 0};\n                _stage = STAGE.SOCKS_READY;\n                break;\n            default:\n                // TODO: exception\n                break;\n\n        }\n\n        return respData;\n    }\n\n    public List<byte[]> getRemoteResponse(byte[] data) {\n        List<byte[]> respData = null;\n        int dataLength = data.length;\n\n        /*\n        There are two stage of establish Sock5:\n            1. HELLO (3 bytes)\n            2. ACK (3 bytes + dst info)\n        as Client sending ACK, it might contain dst info.\n        In this case, server needs to send back ACK response to client and start the remote socket right away,\n        otherwise, client will wait until timeout.\n         */\n        if (_stage == STAGE.SOCKS_READY) {\n            respData = new ArrayList<>(1);\n            // remove socks5 header (partial)\n            if (dataLength > 3) {\n                dataLength -= 3;\n                byte[] temp = new byte[dataLength];\n                System.arraycopy(data, 3, temp, 0, dataLength);\n                respData.add(temp);\n            }\n        }\n\n        return respData;\n    }\n\n    @Override\n    public boolean isMine(byte[] data) {\n        if (data[0] == 0x5) {\n            return true;\n        }\n\n        return false;\n    }\n}",
                                          "definition": "public class Socks5Proxy implements IProxy",
                                          "byte_span": [
                                            1694,
                                            4001
                                          ],
                                          "start_point": [
                                            40,
                                            0
                                          ],
                                          "end_point": [
                                            121,
                                            1
                                          ],
                                          "class_docstring": "",
                                          "name": "Socks5Proxy",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "fields": [
                                              {
                                                "attribute_expression": "    public final static int ATYP_IP_V4 = 0x1;",
                                                "docstring": "",
                                                "modifiers": "public final static",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public",
                                                  "final",
                                                  "static"
                                                ],
                                                "comments": [],
                                                "type": "int",
                                                "name": "ATYP_IP_V4 = 0x1",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    public final static int ATYP_DOMAIN_NAME = 0x3;",
                                                "docstring": "",
                                                "modifiers": "public final static",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public",
                                                  "final",
                                                  "static"
                                                ],
                                                "comments": [],
                                                "type": "int",
                                                "name": "ATYP_DOMAIN_NAME = 0x3",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    public final static int ATYP_IP_V6 = 0x4;",
                                                "docstring": "",
                                                "modifiers": "public final static",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public",
                                                  "final",
                                                  "static"
                                                ],
                                                "comments": [],
                                                "type": "int",
                                                "name": "ATYP_IP_V6 = 0x4",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private Logger logger = Logger.getLogger(Socks5Proxy.class.getName());",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Logger",
                                                "name": "logger = Logger.getLogger(Socks5Proxy.class.getName())",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private STAGE _stage;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "STAGE",
                                                "name": "_stage",
                                                "syntax_pass": true
                                              }
                                            ],
                                            "classes": []
                                          },
                                          "syntax_pass": true,
                                          "methods": [
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2051,
                                                2115
                                              ],
                                              "original_string": "    public Socks5Proxy() {\n        _stage = STAGE.SOCK5_HELLO;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "",
                                                "classes": []
                                              },
                                              "name": "Socks5Proxy",
                                              "body": "                         {\n        _stage = STAGE.SOCK5_HELLO;\n    }",
                                              "identifiers": "_stage STAGE SOCK5_HELLO",
                                              "signature": "    public Socks5Proxy()",
                                              "signature_woname": "    public ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2121,
                                                2178
                                              ],
                                              "original_string": "    public TYPE getType() {\n        return TYPE.SOCKS5;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "TYPE",
                                                "classes": []
                                              },
                                              "name": "getType",
                                              "body": "                          {\n        return TYPE.SOCKS5;\n    }",
                                              "identifiers": "TYPE SOCKS5",
                                              "signature": "    public TYPE getType()",
                                              "signature_woname": "    public TYPE ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2184,
                                                2262
                                              ],
                                              "original_string": "    public boolean isReady() {\n        return (_stage == STAGE.SOCKS_READY);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "isReady",
                                              "body": "                             {\n        return (_stage == STAGE.SOCKS_READY);\n    }",
                                              "identifiers": "_stage STAGE SOCKS_READY",
                                              "signature": "    public boolean isReady()",
                                              "signature_woname": "    public boolean ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2268,
                                                2945
                                              ],
                                              "original_string": "    public byte[] getResponse(byte[] data) {\n        byte[] respData = null;\n\n        switch (_stage) {\n            case SOCK5_HELLO:\n                if (isMine(data)) {\n                    respData = new byte[] {5, 0};\n                }\n                else {\n                    respData = new byte[] {0, 91};\n                }\n                _stage = STAGE.SOCKS_ACK;\n                break;\n            case SOCKS_ACK:\n                respData = new byte[] {5, 0, 0, 1, 0, 0, 0, 0, 0, 0};\n                _stage = STAGE.SOCKS_READY;\n                break;\n            default:\n                // TODO: exception\n                break;\n\n        }\n\n        return respData;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "byte[]",
                                                "classes": []
                                              },
                                              "name": "getResponse",
                                              "body": "                                           {\n        byte[] respData = null;\n\n        switch (_stage) {\n            case SOCK5_HELLO:\n                if (isMine(data)) {\n                    respData = new byte[] {5, 0};\n                }\n                else {\n                    respData = new byte[] {0, 91};\n                }\n                _stage = STAGE.SOCKS_ACK;\n                break;\n            case SOCKS_ACK:\n                respData = new byte[] {5, 0, 0, 1, 0, 0, 0, 0, 0, 0};\n                _stage = STAGE.SOCKS_READY;\n                break;\n            default:\n                // TODO: exception\n                break;\n\n        }\n\n        return respData;\n    }",
                                              "identifiers": "respData _stage SOCK5_HELLO isMine data respData respData _stage STAGE SOCKS_ACK SOCKS_ACK respData _stage STAGE SOCKS_READY respData",
                                              "signature": "    public byte[] getResponse(byte[] data)",
                                              "signature_woname": "    public byte[] (byte[] data)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2951,
                                                3849
                                              ],
                                              "original_string": "    public List<byte[]> getRemoteResponse(byte[] data) {\n        List<byte[]> respData = null;\n        int dataLength = data.length;\n\n        /*\n        There are two stage of establish Sock5:\n            1. HELLO (3 bytes)\n            2. ACK (3 bytes + dst info)\n        as Client sending ACK, it might contain dst info.\n        In this case, server needs to send back ACK response to client and start the remote socket right away,\n        otherwise, client will wait until timeout.\n         */\n        if (_stage == STAGE.SOCKS_READY) {\n            respData = new ArrayList<>(1);\n            // remove socks5 header (partial)\n            if (dataLength > 3) {\n                dataLength -= 3;\n                byte[] temp = new byte[dataLength];\n                System.arraycopy(data, 3, temp, 0, dataLength);\n                respData.add(temp);\n            }\n        }\n\n        return respData;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "List<byte[]>",
                                                "classes": []
                                              },
                                              "name": "getRemoteResponse",
                                              "body": "                                                       {\n        List<byte[]> respData = null;\n        int dataLength = data.length;\n\n        /*\n        There are two stage of establish Sock5:\n            1. HELLO (3 bytes)\n            2. ACK (3 bytes + dst info)\n        as Client sending ACK, it might contain dst info.\n        In this case, server needs to send back ACK response to client and start the remote socket right away,\n        otherwise, client will wait until timeout.\n         */\n        if (_stage == STAGE.SOCKS_READY) {\n            respData = new ArrayList<>(1);\n            // remove socks5 header (partial)\n            if (dataLength > 3) {\n                dataLength -= 3;\n                byte[] temp = new byte[dataLength];\n                System.arraycopy(data, 3, temp, 0, dataLength);\n                respData.add(temp);\n            }\n        }\n\n        return respData;\n    }",
                                              "identifiers": "respData dataLength data length _stage STAGE SOCKS_READY respData dataLength dataLength temp dataLength System arraycopy data temp dataLength respData add temp respData",
                                              "signature": "    public List<byte[]> getRemoteResponse(byte[] data)",
                                              "signature_woname": "    public List<byte[]> (byte[] data)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                3855,
                                                3999
                                              ],
                                              "original_string": "    @Override\n    public boolean isMine(byte[] data) {\n        if (data[0] == 0x5) {\n            return true;\n        }\n\n        return false;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "isMine",
                                              "body": "                                       {\n        if (data[0] == 0x5) {\n            return true;\n        }\n\n        return false;\n    }",
                                              "identifiers": "data",
                                              "signature": "    @Override\n    public boolean isMine(byte[] data)",
                                              "signature_woname": "    @Override\n    public boolean (byte[] data)"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "imports": []
                                  },
                                  {
                                    "name": "AutoProxy.java",
                                    "content": "package com.stfl.network.proxy;\n\nimport com.stfl.misc.Reflection;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\n/**\n * Decides proxy type automatically (as soon as socket established).\n * Proxy class for Socks5 and Http\n */\npublic class AutoProxy implements IProxy {\n    private Logger logger = Logger.getLogger(AutoProxy.class.getName());\n    private IProxy _proxy;\n    private volatile boolean isInitialized;\n\n    public AutoProxy() {\n        isInitialized = false;\n    }\n\n    @Override\n    public boolean isReady() {\n        return (isInitialized && _proxy.isReady());\n    }\n\n    @Override\n    public TYPE getType() {\n        return TYPE.AUTO;\n    }\n\n    @Override\n    public byte[] getResponse(byte[] data) {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.getResponse(data);\n    }\n\n    @Override\n    public List<byte[]> getRemoteResponse(byte[] data) {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.getRemoteResponse(data);\n    }\n\n    @Override\n    public boolean isMine(byte[] data) {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.isMine(data);\n    }\n\n    private void init(byte[] data) {\n        Object obj;\n        IProxy proxy;\n        for (Map.Entry<IProxy.TYPE, String> entry : ProxyFactory.proxies.entrySet()) {\n            if (entry.getKey() == this.getType()) continue;\n\n            obj = Reflection.get(entry.getValue());\n            proxy = (IProxy)obj;\n            if (proxy.isMine(data)) {\n                logger.fine(\"ProxyType (Auto): \" + proxy.getType());\n                _proxy = proxy;\n                isInitialized = true;\n                return;\n            }\n        }\n        logger.severe(\"Unable to determine proxy type!\");\n    }\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.proxy;",
                                        "import com.stfl.misc.Reflection;",
                                        "import java.util.List;",
                                        "import java.util.Map;",
                                        "import java.util.logging.Logger;"
                                      ],
                                      "methods": [],
                                      "classes": [
                                        {
                                          "original_string": "public class AutoProxy implements IProxy {\n    private Logger logger = Logger.getLogger(AutoProxy.class.getName());\n    private IProxy _proxy;\n    private volatile boolean isInitialized;\n\n    public AutoProxy() {\n        isInitialized = false;\n    }\n\n    @Override\n    public boolean isReady() {\n        return (isInitialized && _proxy.isReady());\n    }\n\n    @Override\n    public TYPE getType() {\n        return TYPE.AUTO;\n    }\n\n    @Override\n    public byte[] getResponse(byte[] data) {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.getResponse(data);\n    }\n\n    @Override\n    public List<byte[]> getRemoteResponse(byte[] data) {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.getRemoteResponse(data);\n    }\n\n    @Override\n    public boolean isMine(byte[] data) {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.isMine(data);\n    }\n\n    private void init(byte[] data) {\n        Object obj;\n        IProxy proxy;\n        for (Map.Entry<IProxy.TYPE, String> entry : ProxyFactory.proxies.entrySet()) {\n            if (entry.getKey() == this.getType()) continue;\n\n            obj = Reflection.get(entry.getValue());\n            proxy = (IProxy)obj;\n            if (proxy.isMine(data)) {\n                logger.fine(\"ProxyType (Auto): \" + proxy.getType());\n                _proxy = proxy;\n                isInitialized = true;\n                return;\n            }\n        }\n        logger.severe(\"Unable to determine proxy type!\");\n    }\n}",
                                          "definition": "public class AutoProxy implements IProxy",
                                          "byte_span": [
                                            258,
                                            1812
                                          ],
                                          "start_point": [
                                            12,
                                            0
                                          ],
                                          "end_point": [
                                            72,
                                            1
                                          ],
                                          "class_docstring": "",
                                          "name": "AutoProxy",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "fields": [
                                              {
                                                "attribute_expression": "    private Logger logger = Logger.getLogger(AutoProxy.class.getName());",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Logger",
                                                "name": "logger = Logger.getLogger(AutoProxy.class.getName())",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private IProxy _proxy;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "IProxy",
                                                "name": "_proxy",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private volatile boolean isInitialized;",
                                                "docstring": "",
                                                "modifiers": "private volatile",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private",
                                                  "volatile"
                                                ],
                                                "comments": [],
                                                "type": "boolean",
                                                "name": "isInitialized",
                                                "syntax_pass": true
                                              }
                                            ],
                                            "classes": []
                                          },
                                          "syntax_pass": true,
                                          "methods": [
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                450,
                                                507
                                              ],
                                              "original_string": "    public AutoProxy() {\n        isInitialized = false;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "",
                                                "classes": []
                                              },
                                              "name": "AutoProxy",
                                              "body": "                       {\n        isInitialized = false;\n    }",
                                              "identifiers": "isInitialized",
                                              "signature": "    public AutoProxy()",
                                              "signature_woname": "    public ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                513,
                                                611
                                              ],
                                              "original_string": "    @Override\n    public boolean isReady() {\n        return (isInitialized && _proxy.isReady());\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "isReady",
                                              "body": "                             {\n        return (isInitialized && _proxy.isReady());\n    }",
                                              "identifiers": "isInitialized _proxy isReady",
                                              "signature": "    @Override\n    public boolean isReady()",
                                              "signature_woname": "    @Override\n    public boolean ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                617,
                                                686
                                              ],
                                              "original_string": "    @Override\n    public TYPE getType() {\n        return TYPE.AUTO;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "TYPE",
                                                "classes": []
                                              },
                                              "name": "getType",
                                              "body": "                          {\n        return TYPE.AUTO;\n    }",
                                              "identifiers": "TYPE AUTO",
                                              "signature": "    @Override\n    public TYPE getType()",
                                              "signature_woname": "    @Override\n    public TYPE ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                692,
                                                857
                                              ],
                                              "original_string": "    @Override\n    public byte[] getResponse(byte[] data) {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.getResponse(data);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "byte[]",
                                                "classes": []
                                              },
                                              "name": "getResponse",
                                              "body": "                                           {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.getResponse(data);\n    }",
                                              "identifiers": "isInitialized init data _proxy getResponse data",
                                              "signature": "    @Override\n    public byte[] getResponse(byte[] data)",
                                              "signature_woname": "    @Override\n    public byte[] (byte[] data)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                863,
                                                1046
                                              ],
                                              "original_string": "    @Override\n    public List<byte[]> getRemoteResponse(byte[] data) {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.getRemoteResponse(data);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "List<byte[]>",
                                                "classes": []
                                              },
                                              "name": "getRemoteResponse",
                                              "body": "                                                       {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.getRemoteResponse(data);\n    }",
                                              "identifiers": "isInitialized init data _proxy getRemoteResponse data",
                                              "signature": "    @Override\n    public List<byte[]> getRemoteResponse(byte[] data)",
                                              "signature_woname": "    @Override\n    public List<byte[]> (byte[] data)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                1052,
                                                1208
                                              ],
                                              "original_string": "    @Override\n    public boolean isMine(byte[] data) {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.isMine(data);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "isMine",
                                              "body": "                                       {\n        if (!isInitialized) {\n            init(data);\n        }\n        return _proxy.isMine(data);\n    }",
                                              "identifiers": "isInitialized init data _proxy isMine data",
                                              "signature": "    @Override\n    public boolean isMine(byte[] data)",
                                              "signature_woname": "    @Override\n    public boolean (byte[] data)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                1214,
                                                1810
                                              ],
                                              "original_string": "    private void init(byte[] data) {\n        Object obj;\n        IProxy proxy;\n        for (Map.Entry<IProxy.TYPE, String> entry : ProxyFactory.proxies.entrySet()) {\n            if (entry.getKey() == this.getType()) continue;\n\n            obj = Reflection.get(entry.getValue());\n            proxy = (IProxy)obj;\n            if (proxy.isMine(data)) {\n                logger.fine(\"ProxyType (Auto): \" + proxy.getType());\n                _proxy = proxy;\n                isInitialized = true;\n                return;\n            }\n        }\n        logger.severe(\"Unable to determine proxy type!\");\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "init",
                                              "body": "                                   {\n        Object obj;\n        IProxy proxy;\n        for (Map.Entry<IProxy.TYPE, String> entry : ProxyFactory.proxies.entrySet()) {\n            if (entry.getKey() == this.getType()) continue;\n\n            obj = Reflection.get(entry.getValue());\n            proxy = (IProxy)obj;\n            if (proxy.isMine(data)) {\n                logger.fine(\"ProxyType (Auto): \" + proxy.getType());\n                _proxy = proxy;\n                isInitialized = true;\n                return;\n            }\n        }\n        logger.severe(\"Unable to determine proxy type!\");\n    }",
                                              "identifiers": "obj proxy entry ProxyFactory proxies entrySet entry getKey getType obj Reflection get entry getValue proxy obj proxy isMine data logger fine proxy getType _proxy proxy isInitialized logger severe",
                                              "signature": "    private void init(byte[] data)",
                                              "signature_woname": "    private void (byte[] data)"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "imports": [
                                      {
                                        "original_string": "public class Reflection {\n    public static Object get(String className, Object... args) {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }\n}",
                                        "definition": "public class Reflection",
                                        "byte_span": [
                                          63,
                                          1202
                                        ],
                                        "start_point": [
                                          4,
                                          0
                                        ],
                                        "end_point": [
                                          33,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Reflection",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              93,
                                              1200
                                            ],
                                            "original_string": "    public static Object get(String className, Object... args) {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "Object",
                                              "classes": []
                                            },
                                            "name": "get",
                                            "body": "                                                               {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }",
                                            "identifiers": "retValue c Class forName className args length retValue c newInstance args length oParam args length arg_i i arg_i args length arg_i i oParam i args arg_i constructor c getConstructor oParam paramObjs args length arg_i i arg_i args length arg_i i paramObjs i args arg_i retValue constructor newInstance paramObjs e e printStackTrace retValue",
                                            "signature": "    public static Object get(String className, Object... args)",
                                            "signature_woname": "    public static Object (String className, Object... args)"
                                          }
                                        ]
                                      }
                                    ]
                                  },
                                  {
                                    "name": "IProxy.java",
                                    "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network.proxy;\n\nimport java.util.List;\n\npublic interface IProxy {\n    enum TYPE {SOCKS5, HTTP, AUTO}\n\n    boolean isReady();\n    TYPE getType();\n    byte[] getResponse(byte[] data);\n    List<byte[]> getRemoteResponse(byte[] data);\n    boolean isMine(byte[] data);\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.proxy;",
                                        "import java.util.List;"
                                      ],
                                      "methods": [],
                                      "classes": []
                                    },
                                    "imports": []
                                  },
                                  {
                                    "name": "ProxyFactory.java",
                                    "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network.proxy;\n\nimport com.stfl.misc.Reflection;\nimport java.util.*;\nimport java.util.logging.Logger;\n\n/**\n * Proxy factory\n */\npublic class ProxyFactory {\n    public static final Map<IProxy.TYPE, String> proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }};\n    private static Logger logger = Logger.getLogger(ProxyFactory.class.getName());\n\n    public static boolean isProxyTypeExisted(String name) {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }\n\n    public static IProxy get(IProxy.TYPE type) {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<IProxy.TYPE> getSupportedProxyTypes() {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.proxy;",
                                        "import com.stfl.misc.Reflection;",
                                        "import java.util.*;",
                                        "import java.util.logging.Logger;"
                                      ],
                                      "methods": [],
                                      "classes": [
                                        {
                                          "original_string": "public class ProxyFactory {\n    public static final Map<IProxy.TYPE, String> proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }};\n    private static Logger logger = Logger.getLogger(ProxyFactory.class.getName());\n\n    public static boolean isProxyTypeExisted(String name) {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }\n\n    public static IProxy get(IProxy.TYPE type) {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }\n\n    public static List<IProxy.TYPE> getSupportedProxyTypes() {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }\n}",
                                          "definition": "public class ProxyFactory",
                                          "byte_span": [
                                            1660,
                                            2707
                                          ],
                                          "start_point": [
                                            40,
                                            0
                                          ],
                                          "end_point": [
                                            70,
                                            1
                                          ],
                                          "class_docstring": "",
                                          "name": "ProxyFactory",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "fields": [
                                              {
                                                "attribute_expression": "    public static final Map<IProxy.TYPE, String> proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }};",
                                                "docstring": "",
                                                "modifiers": "public static final",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public",
                                                  "static",
                                                  "final"
                                                ],
                                                "comments": [],
                                                "type": "Map<IProxy.TYPE, String>",
                                                "name": "proxies = new HashMap<IProxy.TYPE, String>() {{\n        put(IProxy.TYPE.HTTP, HttpProxy.class.getName());\n        put(IProxy.TYPE.SOCKS5, Socks5Proxy.class.getName());\n        put(IProxy.TYPE.AUTO, AutoProxy.class.getName());\n    }}",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private static Logger logger = Logger.getLogger(ProxyFactory.class.getName());",
                                                "docstring": "",
                                                "modifiers": "private static",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private",
                                                  "static"
                                                ],
                                                "comments": [],
                                                "type": "Logger",
                                                "name": "logger = Logger.getLogger(ProxyFactory.class.getName())",
                                                "syntax_pass": true
                                              }
                                            ],
                                            "classes": []
                                          },
                                          "syntax_pass": true,
                                          "methods": [
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2059,
                                                2218
                                              ],
                                              "original_string": "    public static boolean isProxyTypeExisted(String name) {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public static",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public",
                                                  "static"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "isProxyTypeExisted",
                                              "body": "                                                          {\n        IProxy.TYPE type = IProxy.TYPE.valueOf(name);\n        return (proxies.get(type) != null);\n    }",
                                              "identifiers": "type IProxy TYPE valueOf name proxies get type",
                                              "signature": "    public static boolean isProxyTypeExisted(String name)",
                                              "signature_woname": "    public static boolean (String name)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2224,
                                                2509
                                              ],
                                              "original_string": "    public static IProxy get(IProxy.TYPE type) {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public static",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public",
                                                  "static"
                                                ],
                                                "comments": [],
                                                "return_type": "IProxy",
                                                "classes": []
                                              },
                                              "name": "get",
                                              "body": "                                               {\n        try {\n            Object obj = Reflection.get(proxies.get(type));\n            return (IProxy)obj;\n\n        } catch (Exception e) {\n            logger.info(com.stfl.misc.Util.getErrorMessage(e));\n        }\n\n        return null;\n    }",
                                              "identifiers": "obj Reflection get proxies get type obj e logger info com stfl misc Util getErrorMessage e",
                                              "signature": "    public static IProxy get(IProxy.TYPE type)",
                                              "signature_woname": "    public static IProxy (IProxy.TYPE type)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2515,
                                                2705
                                              ],
                                              "original_string": "    public static List<IProxy.TYPE> getSupportedProxyTypes() {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public static",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public",
                                                  "static"
                                                ],
                                                "comments": [],
                                                "return_type": "List<IProxy.TYPE>",
                                                "classes": []
                                              },
                                              "name": "getSupportedProxyTypes",
                                              "body": "                                                             {\n        List sortedKeys = new ArrayList<>(proxies.keySet());\n        Collections.sort(sortedKeys);\n        return sortedKeys;\n    }",
                                              "identifiers": "sortedKeys proxies keySet Collections sort sortedKeys sortedKeys",
                                              "signature": "    public static List<IProxy.TYPE> getSupportedProxyTypes()",
                                              "signature_woname": "    public static List<IProxy.TYPE> ()"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "imports": [
                                      {
                                        "original_string": "public class Reflection {\n    public static Object get(String className, Object... args) {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }\n}",
                                        "definition": "public class Reflection",
                                        "byte_span": [
                                          63,
                                          1202
                                        ],
                                        "start_point": [
                                          4,
                                          0
                                        ],
                                        "end_point": [
                                          33,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Reflection",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              93,
                                              1200
                                            ],
                                            "original_string": "    public static Object get(String className, Object... args) {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "Object",
                                              "classes": []
                                            },
                                            "name": "get",
                                            "body": "                                                               {\n        Object retValue = null;\n        try {\n            Class c = Class.forName(className);\n            if (args.length == 0) {\n                retValue = c.newInstance();\n            }\n            else if ((args.length & 1) == 0) {\n                // args should come with pairs, for example\n                // String.class, \"arg1_value\", String.class, \"arg2_value\"\n                Class[] oParam = new Class[args.length / 2];\n                for (int arg_i = 0, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    oParam[i] = (Class)args[arg_i];\n                }\n\n                Constructor constructor = c.getConstructor(oParam);\n                Object[] paramObjs = new Object[args.length / 2];\n                for (int arg_i = 1, i = 0; arg_i < args.length; arg_i+=2, i++) {\n                    paramObjs[i] = args[arg_i];\n                }\n                retValue = constructor.newInstance(paramObjs);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return retValue;\n    }",
                                            "identifiers": "retValue c Class forName className args length retValue c newInstance args length oParam args length arg_i i arg_i args length arg_i i oParam i args arg_i constructor c getConstructor oParam paramObjs args length arg_i i arg_i args length arg_i i paramObjs i args arg_i retValue constructor newInstance paramObjs e e printStackTrace retValue",
                                            "signature": "    public static Object get(String className, Object... args)",
                                            "signature_woname": "    public static Object (String className, Object... args)"
                                          }
                                        ]
                                      }
                                    ]
                                  },
                                  {
                                    "name": "HttpProxy.java",
                                    "content": "/*\n * Copyright (c) 2015, Blake\n * All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name of the author may not be used to endorse or promote\n * products derived from this software without specific prior\n * written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.stfl.network.proxy;\n\nimport com.stfl.Constant;\nimport com.stfl.misc.Util;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Provide local HTTP proxy statue and required response\n */\npublic class HttpProxy implements IProxy {\n    private static final String[] HTTP_METHODS =\n            new String[] {\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"TRACE\", \"CONNECT\"};\n\n    private Logger logger = Logger.getLogger(HttpProxy.class.getName());\n    private boolean _isReady;\n    private boolean _isHttpConnect;\n    private Map<String, String> methodCache;\n\n    public HttpProxy() {\n        _isReady = false;\n        _isHttpConnect = false;\n    }\n\n    public TYPE getType() {\n        return TYPE.HTTP;\n    }\n\n    public boolean isReady() {\n        return _isReady;\n    }\n\n    public byte[] getResponse(byte[] data) {\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        setHttpMethod(methodCache);\n\n        if (_isHttpConnect)\n            return String.format(\"HTTP/1.0 200\\r\\nProxy-agent: %s/%s\\r\\n\\r\\n\",\n                    Constant.PROG_NAME, Constant.VERSION).getBytes();\n\n        return null;\n    }\n\n    public List<byte[]> getRemoteResponse(byte[] data) {\n        List<byte[]> respData = new ArrayList<>(2);\n        String host;\n        int port = 80; // HTTP port\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        String[] hostInfo = methodCache.get(\"host\").split(\":\");\n\n        // get hostname and port\n        host = hostInfo[0];\n        if (hostInfo.length > 1) {\n            port = Integer.parseInt(hostInfo[1]);\n        }\n\n        byte[] ssHeader = Util.composeSSHeader(host, port);\n        respData.add(ssHeader);\n        if (!_isHttpConnect) {\n            byte[] httpHeader = reconstructHttpHeader(methodCache, data);\n            respData.add(httpHeader);\n        }\n\n        _isReady = true;\n        return respData;\n    }\n\n    @Override\n    public boolean isMine(byte[] data) {\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        String method = methodCache.get(\"method\");\n\n        if (method != null) {\n            for (String s : HTTP_METHODS) {\n                if (s.equals(method)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private Map<String, String> getHttpMethod(byte[] data) {\n        String httpRequest = Util.bytesToString(data, 0, data.length);\n        String[] httpHeaders = httpRequest.split(\"\\\\r?\\\\n\");\n        boolean isHostFound = true;\n        //Pattern pattern = Pattern.compile(\"^([a-zA-Z]*) [hHtTpP]{0,4}[:\\\\/]{0,3}(\\\\S[^/ ]*)\");\n        Pattern pattern = Pattern.compile(\"^([a-zA-Z]*) [htps]{0,4}[:/]{0,3}(\\\\S[^/]*)(\\\\S*) (\\\\S*)\");\n        Map<String, String> header = new HashMap<>();\n        if (httpHeaders.length > 0) {\n            logger.fine(\"HTTP Header: \" + httpHeaders[0]);\n            Matcher matcher = pattern.matcher(httpHeaders[0]);\n            if (matcher.find()) {\n                header.put(\"method\", matcher.group(1));\n                if (matcher.group(2).startsWith(\"/\")) {\n                    header.put(\"url\", \"/\");\n                    isHostFound = false;\n                }\n                else {\n                    header.put(\"host\", matcher.group(2));\n                    header.put(\"url\", matcher.group(3));\n                }\n                header.put(\"version\", matcher.group(4));\n            }\n        }\n\n        if (!isHostFound) {\n            for (String line : httpHeaders) {\n                if (line.toLowerCase().contains(\"host\")) {\n                    String info = line.split(\":\")[1].trim();\n                    header.put(\"host\", info);\n                    break;\n                }\n            }\n        }\n        return header;\n    }\n\n    private byte[] reconstructHttpHeader(Map<String, String> method, byte[] data) {\n        String httpRequest = Util.bytesToString(data, 0, data.length);\n        String[] httpHeaders = httpRequest.split(\"\\\\r?\\\\n\");\n        StringBuilder sb = new StringBuilder();\n        boolean isFirstLine = true;\n\n        //logger.info(\"original HttpHeader:\" + httpRequest);\n        for (String line : httpHeaders) {\n            if (isFirstLine && _isHttpConnect) {\n                sb.append(method.get(\"method\"));\n                sb.append(\" \");\n                sb.append(method.get(\"host\"));\n                sb.append(\" \");\n                sb.append(method.get(\"version\"));\n                sb.append(\"\\r\\n\");\n                sb.append(\"User-Agent: test/0.1\\r\\n\");\n                break;\n            }\n            else if (isFirstLine) {\n                sb.append(method.get(\"method\"));\n                sb.append(\" \");\n                sb.append(method.get(\"url\"));\n                sb.append(\" \");\n                sb.append(method.get(\"version\"));\n                isFirstLine = false;\n            }\n            else if (line.toLowerCase().contains(\"cache-control\")) {\n                sb.append(\"Pragma: no-cache\\r\\n\");\n                sb.append(\"Cache-Control: no-cache\");\n            }\n            else if (line.toLowerCase().contains(\"proxy-connection\")) {\n                //Proxy-Connection\n                String[] fields = line.split(\":\");\n                sb.append(\"Connection: \");\n                sb.append(fields[1].trim());\n            }\n            else if (line.toLowerCase().contains(\"if-none-match\")) {\n                continue;\n            }\n            else if (line.toLowerCase().contains(\"if-modified-since\")) {\n                continue;\n            }\n            else {\n                sb.append(line);\n            }\n            sb.append(\"\\r\\n\");\n        }\n\n        sb.append(\"\\r\\n\");\n        //logger.info(\"reconstructHttpHeader:\" + sb.toString());\n        return sb.toString().getBytes();\n    }\n\n    private void setHttpMethod(Map<String, String> header) {\n        String method = header.get(\"method\");\n\n        if (method != null) {\n            if (method.toUpperCase().equals(\"CONNECT\")) {\n                _isHttpConnect = true;\n            }\n            else {\n                _isHttpConnect = false;\n            }\n        }\n    }\n\n}\n",
                                    "schema": {
                                      "file_docstring": "",
                                      "contexts": [
                                        "package com.stfl.network.proxy;",
                                        "import com.stfl.Constant;",
                                        "import com.stfl.misc.Util;",
                                        "import java.util.ArrayList;",
                                        "import java.util.HashMap;",
                                        "import java.util.List;",
                                        "import java.util.Map;",
                                        "import java.util.logging.Logger;",
                                        "import java.util.regex.Matcher;",
                                        "import java.util.regex.Pattern;"
                                      ],
                                      "methods": [],
                                      "classes": [
                                        {
                                          "original_string": "public class HttpProxy implements IProxy {\n    private static final String[] HTTP_METHODS =\n            new String[] {\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"TRACE\", \"CONNECT\"};\n\n    private Logger logger = Logger.getLogger(HttpProxy.class.getName());\n    private boolean _isReady;\n    private boolean _isHttpConnect;\n    private Map<String, String> methodCache;\n\n    public HttpProxy() {\n        _isReady = false;\n        _isHttpConnect = false;\n    }\n\n    public TYPE getType() {\n        return TYPE.HTTP;\n    }\n\n    public boolean isReady() {\n        return _isReady;\n    }\n\n    public byte[] getResponse(byte[] data) {\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        setHttpMethod(methodCache);\n\n        if (_isHttpConnect)\n            return String.format(\"HTTP/1.0 200\\r\\nProxy-agent: %s/%s\\r\\n\\r\\n\",\n                    Constant.PROG_NAME, Constant.VERSION).getBytes();\n\n        return null;\n    }\n\n    public List<byte[]> getRemoteResponse(byte[] data) {\n        List<byte[]> respData = new ArrayList<>(2);\n        String host;\n        int port = 80; // HTTP port\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        String[] hostInfo = methodCache.get(\"host\").split(\":\");\n\n        // get hostname and port\n        host = hostInfo[0];\n        if (hostInfo.length > 1) {\n            port = Integer.parseInt(hostInfo[1]);\n        }\n\n        byte[] ssHeader = Util.composeSSHeader(host, port);\n        respData.add(ssHeader);\n        if (!_isHttpConnect) {\n            byte[] httpHeader = reconstructHttpHeader(methodCache, data);\n            respData.add(httpHeader);\n        }\n\n        _isReady = true;\n        return respData;\n    }\n\n    @Override\n    public boolean isMine(byte[] data) {\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        String method = methodCache.get(\"method\");\n\n        if (method != null) {\n            for (String s : HTTP_METHODS) {\n                if (s.equals(method)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private Map<String, String> getHttpMethod(byte[] data) {\n        String httpRequest = Util.bytesToString(data, 0, data.length);\n        String[] httpHeaders = httpRequest.split(\"\\\\r?\\\\n\");\n        boolean isHostFound = true;\n        //Pattern pattern = Pattern.compile(\"^([a-zA-Z]*) [hHtTpP]{0,4}[:\\\\/]{0,3}(\\\\S[^/ ]*)\");\n        Pattern pattern = Pattern.compile(\"^([a-zA-Z]*) [htps]{0,4}[:/]{0,3}(\\\\S[^/]*)(\\\\S*) (\\\\S*)\");\n        Map<String, String> header = new HashMap<>();\n        if (httpHeaders.length > 0) {\n            logger.fine(\"HTTP Header: \" + httpHeaders[0]);\n            Matcher matcher = pattern.matcher(httpHeaders[0]);\n            if (matcher.find()) {\n                header.put(\"method\", matcher.group(1));\n                if (matcher.group(2).startsWith(\"/\")) {\n                    header.put(\"url\", \"/\");\n                    isHostFound = false;\n                }\n                else {\n                    header.put(\"host\", matcher.group(2));\n                    header.put(\"url\", matcher.group(3));\n                }\n                header.put(\"version\", matcher.group(4));\n            }\n        }\n\n        if (!isHostFound) {\n            for (String line : httpHeaders) {\n                if (line.toLowerCase().contains(\"host\")) {\n                    String info = line.split(\":\")[1].trim();\n                    header.put(\"host\", info);\n                    break;\n                }\n            }\n        }\n        return header;\n    }\n\n    private byte[] reconstructHttpHeader(Map<String, String> method, byte[] data) {\n        String httpRequest = Util.bytesToString(data, 0, data.length);\n        String[] httpHeaders = httpRequest.split(\"\\\\r?\\\\n\");\n        StringBuilder sb = new StringBuilder();\n        boolean isFirstLine = true;\n\n        //logger.info(\"original HttpHeader:\" + httpRequest);\n        for (String line : httpHeaders) {\n            if (isFirstLine && _isHttpConnect) {\n                sb.append(method.get(\"method\"));\n                sb.append(\" \");\n                sb.append(method.get(\"host\"));\n                sb.append(\" \");\n                sb.append(method.get(\"version\"));\n                sb.append(\"\\r\\n\");\n                sb.append(\"User-Agent: test/0.1\\r\\n\");\n                break;\n            }\n            else if (isFirstLine) {\n                sb.append(method.get(\"method\"));\n                sb.append(\" \");\n                sb.append(method.get(\"url\"));\n                sb.append(\" \");\n                sb.append(method.get(\"version\"));\n                isFirstLine = false;\n            }\n            else if (line.toLowerCase().contains(\"cache-control\")) {\n                sb.append(\"Pragma: no-cache\\r\\n\");\n                sb.append(\"Cache-Control: no-cache\");\n            }\n            else if (line.toLowerCase().contains(\"proxy-connection\")) {\n                //Proxy-Connection\n                String[] fields = line.split(\":\");\n                sb.append(\"Connection: \");\n                sb.append(fields[1].trim());\n            }\n            else if (line.toLowerCase().contains(\"if-none-match\")) {\n                continue;\n            }\n            else if (line.toLowerCase().contains(\"if-modified-since\")) {\n                continue;\n            }\n            else {\n                sb.append(line);\n            }\n            sb.append(\"\\r\\n\");\n        }\n\n        sb.append(\"\\r\\n\");\n        //logger.info(\"reconstructHttpHeader:\" + sb.toString());\n        return sb.toString().getBytes();\n    }\n\n    private void setHttpMethod(Map<String, String> header) {\n        String method = header.get(\"method\");\n\n        if (method != null) {\n            if (method.toUpperCase().equals(\"CONNECT\")) {\n                _isHttpConnect = true;\n            }\n            else {\n                _isHttpConnect = false;\n            }\n        }\n    }\n\n}",
                                          "definition": "public class HttpProxy implements IProxy",
                                          "byte_span": [
                                            1864,
                                            7848
                                          ],
                                          "start_point": [
                                            47,
                                            0
                                          ],
                                          "end_point": [
                                            228,
                                            1
                                          ],
                                          "class_docstring": "",
                                          "name": "HttpProxy",
                                          "attributes": {
                                            "modifiers": "public",
                                            "marker_annotations": [],
                                            "non_marker_annotations": [
                                              "public"
                                            ],
                                            "comments": [],
                                            "fields": [
                                              {
                                                "attribute_expression": "    private static final String[] HTTP_METHODS =\n            new String[] {\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"TRACE\", \"CONNECT\"};",
                                                "docstring": "",
                                                "modifiers": "private static final",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private",
                                                  "static",
                                                  "final"
                                                ],
                                                "comments": [],
                                                "type": "String[]",
                                                "name": "HTTP_METHODS =\n            new String[] {\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"TRACE\", \"CONNECT\"}",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private Logger logger = Logger.getLogger(HttpProxy.class.getName());",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Logger",
                                                "name": "logger = Logger.getLogger(HttpProxy.class.getName())",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private boolean _isReady;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "boolean",
                                                "name": "_isReady",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private boolean _isHttpConnect;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "boolean",
                                                "name": "_isHttpConnect",
                                                "syntax_pass": true
                                              },
                                              {
                                                "attribute_expression": "    private Map<String, String> methodCache;",
                                                "docstring": "",
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "type": "Map<String, String>",
                                                "name": "methodCache",
                                                "syntax_pass": true
                                              }
                                            ],
                                            "classes": []
                                          },
                                          "syntax_pass": true,
                                          "methods": [
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2244,
                                                2328
                                              ],
                                              "original_string": "    public HttpProxy() {\n        _isReady = false;\n        _isHttpConnect = false;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "",
                                                "classes": []
                                              },
                                              "name": "HttpProxy",
                                              "body": "                       {\n        _isReady = false;\n        _isHttpConnect = false;\n    }",
                                              "identifiers": "_isReady _isHttpConnect",
                                              "signature": "    public HttpProxy()",
                                              "signature_woname": "    public ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2334,
                                                2389
                                              ],
                                              "original_string": "    public TYPE getType() {\n        return TYPE.HTTP;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "TYPE",
                                                "classes": []
                                              },
                                              "name": "getType",
                                              "body": "                          {\n        return TYPE.HTTP;\n    }",
                                              "identifiers": "TYPE HTTP",
                                              "signature": "    public TYPE getType()",
                                              "signature_woname": "    public TYPE ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2395,
                                                2452
                                              ],
                                              "original_string": "    public boolean isReady() {\n        return _isReady;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "isReady",
                                              "body": "                             {\n        return _isReady;\n    }",
                                              "identifiers": "_isReady",
                                              "signature": "    public boolean isReady()",
                                              "signature_woname": "    public boolean ()"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2458,
                                                2832
                                              ],
                                              "original_string": "    public byte[] getResponse(byte[] data) {\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        setHttpMethod(methodCache);\n\n        if (_isHttpConnect)\n            return String.format(\"HTTP/1.0 200\\r\\nProxy-agent: %s/%s\\r\\n\\r\\n\",\n                    Constant.PROG_NAME, Constant.VERSION).getBytes();\n\n        return null;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "byte[]",
                                                "classes": []
                                              },
                                              "name": "getResponse",
                                              "body": "                                           {\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        setHttpMethod(methodCache);\n\n        if (_isHttpConnect)\n            return String.format(\"HTTP/1.0 200\\r\\nProxy-agent: %s/%s\\r\\n\\r\\n\",\n                    Constant.PROG_NAME, Constant.VERSION).getBytes();\n\n        return null;\n    }",
                                              "identifiers": "methodCache methodCache getHttpMethod data setHttpMethod methodCache _isHttpConnect String format Constant PROG_NAME Constant VERSION getBytes",
                                              "signature": "    public byte[] getResponse(byte[] data)",
                                              "signature_woname": "    public byte[] (byte[] data)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                2838,
                                                3615
                                              ],
                                              "original_string": "    public List<byte[]> getRemoteResponse(byte[] data) {\n        List<byte[]> respData = new ArrayList<>(2);\n        String host;\n        int port = 80; // HTTP port\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        String[] hostInfo = methodCache.get(\"host\").split(\":\");\n\n        // get hostname and port\n        host = hostInfo[0];\n        if (hostInfo.length > 1) {\n            port = Integer.parseInt(hostInfo[1]);\n        }\n\n        byte[] ssHeader = Util.composeSSHeader(host, port);\n        respData.add(ssHeader);\n        if (!_isHttpConnect) {\n            byte[] httpHeader = reconstructHttpHeader(methodCache, data);\n            respData.add(httpHeader);\n        }\n\n        _isReady = true;\n        return respData;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "public",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "List<byte[]>",
                                                "classes": []
                                              },
                                              "name": "getRemoteResponse",
                                              "body": "                                                       {\n        List<byte[]> respData = new ArrayList<>(2);\n        String host;\n        int port = 80; // HTTP port\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        String[] hostInfo = methodCache.get(\"host\").split(\":\");\n\n        // get hostname and port\n        host = hostInfo[0];\n        if (hostInfo.length > 1) {\n            port = Integer.parseInt(hostInfo[1]);\n        }\n\n        byte[] ssHeader = Util.composeSSHeader(host, port);\n        respData.add(ssHeader);\n        if (!_isHttpConnect) {\n            byte[] httpHeader = reconstructHttpHeader(methodCache, data);\n            respData.add(httpHeader);\n        }\n\n        _isReady = true;\n        return respData;\n    }",
                                              "identifiers": "respData host port methodCache methodCache getHttpMethod data hostInfo methodCache get split host hostInfo hostInfo length port Integer parseInt hostInfo ssHeader Util composeSSHeader host port respData add ssHeader _isHttpConnect httpHeader reconstructHttpHeader methodCache data respData add httpHeader _isReady respData",
                                              "signature": "    public List<byte[]> getRemoteResponse(byte[] data)",
                                              "signature_woname": "    public List<byte[]> (byte[] data)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                3621,
                                                4033
                                              ],
                                              "original_string": "    @Override\n    public boolean isMine(byte[] data) {\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        String method = methodCache.get(\"method\");\n\n        if (method != null) {\n            for (String s : HTTP_METHODS) {\n                if (s.equals(method)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "@Override\n    public",
                                                "marker_annotations": [
                                                  "@Override"
                                                ],
                                                "non_marker_annotations": [
                                                  "public"
                                                ],
                                                "comments": [],
                                                "return_type": "boolean",
                                                "classes": []
                                              },
                                              "name": "isMine",
                                              "body": "                                       {\n        if (methodCache == null) {\n            methodCache = getHttpMethod(data);\n        }\n        String method = methodCache.get(\"method\");\n\n        if (method != null) {\n            for (String s : HTTP_METHODS) {\n                if (s.equals(method)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }",
                                              "identifiers": "methodCache methodCache getHttpMethod data method methodCache get method s HTTP_METHODS s equals method",
                                              "signature": "    @Override\n    public boolean isMine(byte[] data)",
                                              "signature_woname": "    @Override\n    public boolean (byte[] data)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                4039,
                                                5502
                                              ],
                                              "original_string": "    private Map<String, String> getHttpMethod(byte[] data) {\n        String httpRequest = Util.bytesToString(data, 0, data.length);\n        String[] httpHeaders = httpRequest.split(\"\\\\r?\\\\n\");\n        boolean isHostFound = true;\n        //Pattern pattern = Pattern.compile(\"^([a-zA-Z]*) [hHtTpP]{0,4}[:\\\\/]{0,3}(\\\\S[^/ ]*)\");\n        Pattern pattern = Pattern.compile(\"^([a-zA-Z]*) [htps]{0,4}[:/]{0,3}(\\\\S[^/]*)(\\\\S*) (\\\\S*)\");\n        Map<String, String> header = new HashMap<>();\n        if (httpHeaders.length > 0) {\n            logger.fine(\"HTTP Header: \" + httpHeaders[0]);\n            Matcher matcher = pattern.matcher(httpHeaders[0]);\n            if (matcher.find()) {\n                header.put(\"method\", matcher.group(1));\n                if (matcher.group(2).startsWith(\"/\")) {\n                    header.put(\"url\", \"/\");\n                    isHostFound = false;\n                }\n                else {\n                    header.put(\"host\", matcher.group(2));\n                    header.put(\"url\", matcher.group(3));\n                }\n                header.put(\"version\", matcher.group(4));\n            }\n        }\n\n        if (!isHostFound) {\n            for (String line : httpHeaders) {\n                if (line.toLowerCase().contains(\"host\")) {\n                    String info = line.split(\":\")[1].trim();\n                    header.put(\"host\", info);\n                    break;\n                }\n            }\n        }\n        return header;\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "Map<String, String>",
                                                "classes": []
                                              },
                                              "name": "getHttpMethod",
                                              "body": "                                                           {\n        String httpRequest = Util.bytesToString(data, 0, data.length);\n        String[] httpHeaders = httpRequest.split(\"\\\\r?\\\\n\");\n        boolean isHostFound = true;\n        //Pattern pattern = Pattern.compile(\"^([a-zA-Z]*) [hHtTpP]{0,4}[:\\\\/]{0,3}(\\\\S[^/ ]*)\");\n        Pattern pattern = Pattern.compile(\"^([a-zA-Z]*) [htps]{0,4}[:/]{0,3}(\\\\S[^/]*)(\\\\S*) (\\\\S*)\");\n        Map<String, String> header = new HashMap<>();\n        if (httpHeaders.length > 0) {\n            logger.fine(\"HTTP Header: \" + httpHeaders[0]);\n            Matcher matcher = pattern.matcher(httpHeaders[0]);\n            if (matcher.find()) {\n                header.put(\"method\", matcher.group(1));\n                if (matcher.group(2).startsWith(\"/\")) {\n                    header.put(\"url\", \"/\");\n                    isHostFound = false;\n                }\n                else {\n                    header.put(\"host\", matcher.group(2));\n                    header.put(\"url\", matcher.group(3));\n                }\n                header.put(\"version\", matcher.group(4));\n            }\n        }\n\n        if (!isHostFound) {\n            for (String line : httpHeaders) {\n                if (line.toLowerCase().contains(\"host\")) {\n                    String info = line.split(\":\")[1].trim();\n                    header.put(\"host\", info);\n                    break;\n                }\n            }\n        }\n        return header;\n    }",
                                              "identifiers": "httpRequest Util bytesToString data data length httpHeaders httpRequest split isHostFound pattern Pattern compile header httpHeaders length logger fine httpHeaders matcher pattern matcher httpHeaders matcher find header put matcher group matcher group startsWith header put isHostFound header put matcher group header put matcher group header put matcher group isHostFound line httpHeaders line toLowerCase contains info line split trim header put info header",
                                              "signature": "    private Map<String, String> getHttpMethod(byte[] data)",
                                              "signature_woname": "    private Map<String, String> (byte[] data)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                5508,
                                                7506
                                              ],
                                              "original_string": "    private byte[] reconstructHttpHeader(Map<String, String> method, byte[] data) {\n        String httpRequest = Util.bytesToString(data, 0, data.length);\n        String[] httpHeaders = httpRequest.split(\"\\\\r?\\\\n\");\n        StringBuilder sb = new StringBuilder();\n        boolean isFirstLine = true;\n\n        //logger.info(\"original HttpHeader:\" + httpRequest);\n        for (String line : httpHeaders) {\n            if (isFirstLine && _isHttpConnect) {\n                sb.append(method.get(\"method\"));\n                sb.append(\" \");\n                sb.append(method.get(\"host\"));\n                sb.append(\" \");\n                sb.append(method.get(\"version\"));\n                sb.append(\"\\r\\n\");\n                sb.append(\"User-Agent: test/0.1\\r\\n\");\n                break;\n            }\n            else if (isFirstLine) {\n                sb.append(method.get(\"method\"));\n                sb.append(\" \");\n                sb.append(method.get(\"url\"));\n                sb.append(\" \");\n                sb.append(method.get(\"version\"));\n                isFirstLine = false;\n            }\n            else if (line.toLowerCase().contains(\"cache-control\")) {\n                sb.append(\"Pragma: no-cache\\r\\n\");\n                sb.append(\"Cache-Control: no-cache\");\n            }\n            else if (line.toLowerCase().contains(\"proxy-connection\")) {\n                //Proxy-Connection\n                String[] fields = line.split(\":\");\n                sb.append(\"Connection: \");\n                sb.append(fields[1].trim());\n            }\n            else if (line.toLowerCase().contains(\"if-none-match\")) {\n                continue;\n            }\n            else if (line.toLowerCase().contains(\"if-modified-since\")) {\n                continue;\n            }\n            else {\n                sb.append(line);\n            }\n            sb.append(\"\\r\\n\");\n        }\n\n        sb.append(\"\\r\\n\");\n        //logger.info(\"reconstructHttpHeader:\" + sb.toString());\n        return sb.toString().getBytes();\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "byte[]",
                                                "classes": []
                                              },
                                              "name": "reconstructHttpHeader",
                                              "body": "                                                                                  {\n        String httpRequest = Util.bytesToString(data, 0, data.length);\n        String[] httpHeaders = httpRequest.split(\"\\\\r?\\\\n\");\n        StringBuilder sb = new StringBuilder();\n        boolean isFirstLine = true;\n\n        //logger.info(\"original HttpHeader:\" + httpRequest);\n        for (String line : httpHeaders) {\n            if (isFirstLine && _isHttpConnect) {\n                sb.append(method.get(\"method\"));\n                sb.append(\" \");\n                sb.append(method.get(\"host\"));\n                sb.append(\" \");\n                sb.append(method.get(\"version\"));\n                sb.append(\"\\r\\n\");\n                sb.append(\"User-Agent: test/0.1\\r\\n\");\n                break;\n            }\n            else if (isFirstLine) {\n                sb.append(method.get(\"method\"));\n                sb.append(\" \");\n                sb.append(method.get(\"url\"));\n                sb.append(\" \");\n                sb.append(method.get(\"version\"));\n                isFirstLine = false;\n            }\n            else if (line.toLowerCase().contains(\"cache-control\")) {\n                sb.append(\"Pragma: no-cache\\r\\n\");\n                sb.append(\"Cache-Control: no-cache\");\n            }\n            else if (line.toLowerCase().contains(\"proxy-connection\")) {\n                //Proxy-Connection\n                String[] fields = line.split(\":\");\n                sb.append(\"Connection: \");\n                sb.append(fields[1].trim());\n            }\n            else if (line.toLowerCase().contains(\"if-none-match\")) {\n                continue;\n            }\n            else if (line.toLowerCase().contains(\"if-modified-since\")) {\n                continue;\n            }\n            else {\n                sb.append(line);\n            }\n            sb.append(\"\\r\\n\");\n        }\n\n        sb.append(\"\\r\\n\");\n        //logger.info(\"reconstructHttpHeader:\" + sb.toString());\n        return sb.toString().getBytes();\n    }",
                                              "identifiers": "httpRequest Util bytesToString data data length httpHeaders httpRequest split sb isFirstLine line httpHeaders isFirstLine _isHttpConnect sb append method get sb append sb append method get sb append sb append method get sb append sb append isFirstLine sb append method get sb append sb append method get sb append sb append method get isFirstLine line toLowerCase contains sb append sb append line toLowerCase contains fields line split sb append sb append fields trim line toLowerCase contains line toLowerCase contains sb append line sb append sb append sb toString getBytes",
                                              "signature": "    private byte[] reconstructHttpHeader(Map<String, String> method, byte[] data)",
                                              "signature_woname": "    private byte[] (Map<String, String> method, byte[] data)"
                                            },
                                            {
                                              "syntax_pass": true,
                                              "byte_span": [
                                                7512,
                                                7845
                                              ],
                                              "original_string": "    private void setHttpMethod(Map<String, String> header) {\n        String method = header.get(\"method\");\n\n        if (method != null) {\n            if (method.toUpperCase().equals(\"CONNECT\")) {\n                _isHttpConnect = true;\n            }\n            else {\n                _isHttpConnect = false;\n            }\n        }\n    }",
                                              "docstring": "",
                                              "attributes": {
                                                "modifiers": "private",
                                                "marker_annotations": [],
                                                "non_marker_annotations": [
                                                  "private"
                                                ],
                                                "comments": [],
                                                "return_type": "void",
                                                "classes": []
                                              },
                                              "name": "setHttpMethod",
                                              "body": "                                                           {\n        String method = header.get(\"method\");\n\n        if (method != null) {\n            if (method.toUpperCase().equals(\"CONNECT\")) {\n                _isHttpConnect = true;\n            }\n            else {\n                _isHttpConnect = false;\n            }\n        }\n    }",
                                              "identifiers": "method header get method method toUpperCase equals _isHttpConnect _isHttpConnect",
                                              "signature": "    private void setHttpMethod(Map<String, String> header)",
                                              "signature_woname": "    private void (Map<String, String> header)"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "imports": [
                                      {
                                        "original_string": "public class Constant {\n    public static final String PROG_NAME = \"shadowsocks-java\";\n    public static final String VERSION = \"0.2\";\n    public static final int BUFFER_SIZE = 16384;\n    public static final String CONF_FILE = \"config.json\";\n    public static final Locale LOCALE = Locale.getDefault();\n}",
                                        "definition": "public class Constant",
                                        "byte_span": [
                                          45,
                                          349
                                        ],
                                        "start_point": [
                                          4,
                                          0
                                        ],
                                        "end_point": [
                                          10,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Constant",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [
                                            {
                                              "attribute_expression": "    public static final String PROG_NAME = \"shadowsocks-java\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "PROG_NAME = \"shadowsocks-java\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final String VERSION = \"0.2\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "VERSION = \"0.2\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final int BUFFER_SIZE = 16384;",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "int",
                                              "name": "BUFFER_SIZE = 16384",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final String CONF_FILE = \"config.json\";",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "String",
                                              "name": "CONF_FILE = \"config.json\"",
                                              "syntax_pass": true
                                            },
                                            {
                                              "attribute_expression": "    public static final Locale LOCALE = Locale.getDefault();",
                                              "docstring": "",
                                              "modifiers": "public static final",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static",
                                                "final"
                                              ],
                                              "comments": [],
                                              "type": "Locale",
                                              "name": "LOCALE = Locale.getDefault()",
                                              "syntax_pass": true
                                            }
                                          ],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": []
                                      },
                                      {
                                        "original_string": "public class Util {\n    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }\n\n    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }\n\n    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }\n\n    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }\n\n    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }\n\n    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }\n\n    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }\n\n    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }\n\n    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }\n\n    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }\n}",
                                        "definition": "public class Util",
                                        "byte_span": [
                                          1779,
                                          7484
                                        ],
                                        "start_point": [
                                          45,
                                          0
                                        ],
                                        "end_point": [
                                          219,
                                          1
                                        ],
                                        "class_docstring": "",
                                        "name": "Util",
                                        "attributes": {
                                          "modifiers": "public",
                                          "marker_annotations": [],
                                          "non_marker_annotations": [
                                            "public"
                                          ],
                                          "comments": [],
                                          "fields": [],
                                          "classes": []
                                        },
                                        "syntax_pass": true,
                                        "methods": [
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              1803,
                                              2018
                                            ],
                                            "original_string": "    public static String dumpBytes(byte[] a) {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "dumpBytes",
                                            "body": "                                             {\n        StringBuilder sb = new StringBuilder(a.length * 2);\n        for(byte b: a)\n            sb.append(String.format(\"%x\", b & 0xff));\n        return sb.toString();\n    }",
                                            "identifiers": "sb a length b a sb append String format b sb toString",
                                            "signature": "    public static String dumpBytes(byte[] a)",
                                            "signature_woname": "    public static String (byte[] a)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2024,
                                              2180
                                            ],
                                            "original_string": "    public static byte[] randomBytes(int size) {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "byte[]",
                                              "classes": []
                                            },
                                            "name": "randomBytes",
                                            "body": "                                               {\n        byte[] bytes = new byte[size];\n        new SecureRandom().nextBytes(bytes);\n        return bytes;\n    }",
                                            "identifiers": "bytes size nextBytes bytes bytes",
                                            "signature": "    public static byte[] randomBytes(int size)",
                                            "signature_woname": "    public static byte[] (int size)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2186,
                                              2412
                                            ],
                                            "original_string": "    public static String getErrorMessage(Throwable e) {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getErrorMessage",
                                            "body": "                                                      {\n        Writer writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter(writer);\n        e.printStackTrace(pWriter);\n        return writer.toString();\n    }",
                                            "identifiers": "writer pWriter writer e printStackTrace pWriter writer toString",
                                            "signature": "    public static String getErrorMessage(Throwable e)",
                                            "signature_woname": "    public static String (Throwable e)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              2418,
                                              4165
                                            ],
                                            "original_string": "    public static String prettyPrintJson(JSONObject jObj) {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "prettyPrintJson",
                                            "body": "                                                          {\n        String retValue;\n        StringWriter writer = new StringWriter() {\n            private final static String indent = \"  \";\n            private final String LINE_SEP = System.getProperty(\"line.separator\");\n            private int indentLevel = 0;\n\n            @Override\n            public void write(int c) {\n                char ch = (char) c;\n                if (ch == '[' || ch == '{') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    indentLevel++;\n                    writeIndentation();\n                }\n                else if (ch == ']' || ch == '}') {\n                    super.write(LINE_SEP);\n                    indentLevel--;\n                    writeIndentation();\n                    super.write(c);\n                }\n                else if (ch == ':') {\n                    super.write(c);\n                    super.write(\" \");\n                }\n                else if (ch == ',') {\n                    super.write(c);\n                    super.write(LINE_SEP);\n                    writeIndentation();\n                }\n                else {\n                    super.write(c);\n                }\n\n            }\n\n            private void writeIndentation()\n            {\n                for (int i = 0; i < indentLevel; i++)\n                {\n                    super.write(indent);\n                }\n            }\n        };\n\n        try {\n            jObj.writeJSONString(writer);\n            retValue = writer.toString();\n        } catch (IOException e) {\n            // something wrong with writer, use the original method\n            retValue = jObj.toJSONString();\n        }\n\n        return retValue;\n    }",
                                            "identifiers": "retValue writer indent LINE_SEP System getProperty indentLevel Override write c ch c ch ch write c write LINE_SEP indentLevel writeIndentation ch ch write LINE_SEP indentLevel writeIndentation write c ch write c write ch write c write LINE_SEP writeIndentation write c writeIndentation i i indentLevel i write indent jObj writeJSONString writer retValue writer toString e retValue jObj toJSONString retValue",
                                            "signature": "    public static String prettyPrintJson(JSONObject jObj)",
                                            "signature_woname": "    public static String (JSONObject jObj)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              4171,
                                              5829
                                            ],
                                            "original_string": "    public static String getRequestedHostInfo(byte[] data) {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getRequestedHostInfo",
                                            "body": "                                                           {\n        String ret = \"\";\n        int port;\n        int neededLength;\n        switch (data[0]) {\n            case Socks5Proxy.ATYP_IP_V4:\n                // IP v4 Address\n                // 4 bytes of IP, 2 bytes of port\n                neededLength = 6;\n                if (data.length > neededLength) {\n                    port = getPort(data[5], data[6]);\n                    ret = String.format(\"%d.%d.%d.%d:%d\", data[1], data[2], data[3], data[4], port);\n                }\n                break;\n            case Socks5Proxy.ATYP_DOMAIN_NAME:\n                // domain\n                neededLength = data[1];\n                if (data.length > neededLength + 3) {\n                    port = getPort(data[neededLength + 2], data[neededLength + 3]);\n                    String domain = bytesToString(data, 2, neededLength);\n                    ret = String.format(\"%s:%d\", domain, port);\n                }\n                break;\n            case Socks5Proxy.ATYP_IP_V6:\n                // IP v6 Address\n                // 16 bytes of IP, 2 bytes of port\n                neededLength = 18;\n                if (data.length > neededLength) {\n                    port = getPort(data[17], data[18]);\n                    ret = String.format(\"%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%d\",\n                            data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8],\n                            data[9], data[10], data[11], data[12], data[13], data[14], data[15], data[16],\n                            port);\n                }\n                break;\n        }\n\n        return ret;\n    }",
                                            "identifiers": "ret port neededLength data Socks5Proxy ATYP_IP_V4 neededLength data length neededLength port getPort data data ret String format data data data data port Socks5Proxy ATYP_DOMAIN_NAME neededLength data data length neededLength port getPort data neededLength data neededLength domain bytesToString data neededLength ret String format domain port Socks5Proxy ATYP_IP_V6 neededLength data length neededLength port getPort data data ret String format data data data data data data data data data data data data data data data data port ret",
                                            "signature": "    public static String getRequestedHostInfo(byte[] data)",
                                            "signature_woname": "    public static String (byte[] data)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              5835,
                                              6128
                                            ],
                                            "original_string": "    public static String bytesToString(byte[] data, int start, int length) {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "bytesToString",
                                            "body": "                                                                           {\n        String str = \"\";\n\n        try {\n            str = new String(data, start, length, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return str;\n    }",
                                            "identifiers": "str str data start length e e printStackTrace str",
                                            "signature": "    public static String bytesToString(byte[] data, int start, int length)",
                                            "signature_woname": "    public static String (byte[] data, int start, int length)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6134,
                                              6648
                                            ],
                                            "original_string": "    public static byte[] composeSSHeader(String host, int port) {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "byte[]",
                                              "classes": []
                                            },
                                            "name": "composeSSHeader",
                                            "body": "                                                                {\n        // TYPE (1 byte) + LENGTH (1 byte) + HOST (var bytes) + PORT (2 bytes)\n        byte[] respData = new byte[host.length() + 4];\n\n        respData[0] = Socks5Proxy.ATYP_DOMAIN_NAME;\n        respData[1] = (byte)host.length();\n        System.arraycopy(host.getBytes(), 0, respData, 2, host.length());\n        respData[host.length() + 2] = (byte)(port >> 8);\n        respData[host.length() + 3] = (byte)(port & 0xFF);\n\n        return  respData;\n    }",
                                            "identifiers": "respData host length respData Socks5Proxy ATYP_DOMAIN_NAME respData host length System arraycopy host getBytes respData host length respData host length port respData host length port respData",
                                            "signature": "    public static byte[] composeSSHeader(String host, int port)",
                                            "signature_woname": "    public static byte[] (String host, int port)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6654,
                                              6969
                                            ],
                                            "original_string": "    public static boolean saveFile(String fn, String content) {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "boolean",
                                              "classes": []
                                            },
                                            "name": "saveFile",
                                            "body": "                                                              {\n        PrintWriter writer;\n        try {\n            writer = new PrintWriter(fn);\n            writer.println(content);\n            writer.close();\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n        return true;\n    }",
                                            "identifiers": "writer writer fn writer println content writer close e",
                                            "signature": "    public static boolean saveFile(String fn, String content)",
                                            "signature_woname": "    public static boolean (String fn, String content)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              6975,
                                              7262
                                            ],
                                            "original_string": "    public static String getFileContent(String fn) {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "public static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "public",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "String",
                                              "classes": []
                                            },
                                            "name": "getFileContent",
                                            "body": "                                                   {\n        Path path = Paths.get(fn);\n        String content = \"\";\n        try {\n            content = new String(Files.readAllBytes(path));\n        } catch (IOException e) {\n            // do nothing\n        }\n\n        return content;\n    }",
                                            "identifiers": "path Paths get fn content content Files readAllBytes path e content",
                                            "signature": "    public static String getFileContent(String fn)",
                                            "signature_woname": "    public static String (String fn)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              7268,
                                              7357
                                            ],
                                            "original_string": "    private static short byteToUnsignedByte(byte b) {\n        return (short)(b & 0xff);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "short",
                                              "classes": []
                                            },
                                            "name": "byteToUnsignedByte",
                                            "body": "                                                    {\n        return (short)(b & 0xff);\n    }",
                                            "identifiers": "b",
                                            "signature": "    private static short byteToUnsignedByte(byte b)",
                                            "signature_woname": "    private static short (byte b)"
                                          },
                                          {
                                            "syntax_pass": true,
                                            "byte_span": [
                                              7363,
                                              7482
                                            ],
                                            "original_string": "    private static int getPort(byte b, byte b1) {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                            "docstring": "",
                                            "attributes": {
                                              "modifiers": "private static",
                                              "marker_annotations": [],
                                              "non_marker_annotations": [
                                                "private",
                                                "static"
                                              ],
                                              "comments": [],
                                              "return_type": "int",
                                              "classes": []
                                            },
                                            "name": "getPort",
                                            "body": "                                                {\n        return byteToUnsignedByte(b) << 8 | byteToUnsignedByte(b1);\n    }",
                                            "identifiers": "byteToUnsignedByte b byteToUnsignedByte b1",
                                            "signature": "    private static int getPort(byte b, byte b1)",
                                            "signature_woname": "    private static int (byte b, byte b1)"
                                          }
                                        ]
                                      }
                                    ]
                                  }
                                ],
                                "subdirs": []
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "dir": "resources",
                "files": [],
                "subdirs": [
                  {
                    "dir": "resources",
                    "files": [],
                    "subdirs": [
                      {
                        "dir": "image",
                        "files": [],
                        "subdirs": []
                      },
                      {
                        "dir": "ui",
                        "files": [],
                        "subdirs": []
                      },
                      {
                        "dir": "bundle",
                        "files": [],
                        "subdirs": []
                      }
                    ]
                  },
                  {
                    "dir": "META-INF",
                    "files": [],
                    "subdirs": []
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  }
]